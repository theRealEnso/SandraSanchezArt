"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _react = require("react");
const _dynamicnossr = require("./dynamic-no-ssr");
// Normalize loader to return the module as form { default: Component } for `React.lazy`.
// Also for backward compatible since next/dynamic allows to resolve a component directly with loader
// Client component reference proxy need to be converted to a module.
function convertModule(mod) {
    return {
        default: (mod == null ? void 0 : mod.default) || mod
    };
}
function Loadable(options) {
    const opts = {
        loader: null,
        loading: null,
        ssr: true,
        ...options
    };
    const loader = ()=>opts.loader != null ? opts.loader().then(convertModule) : Promise.resolve(convertModule(()=>null));
    const Lazy = /*#__PURE__*/ (0, _react.lazy)(loader);
    const Loading = opts.loading;
    const Wrap = opts.ssr ? _react.Fragment : _dynamicnossr.NoSSR;
    function LoadableComponent(props) {
        const fallbackElement = Loading ? /*#__PURE__*/ (0, _jsxruntime.jsx)(Loading, {
            isLoading: true,
            pastDelay: true,
            error: null
        }) : null;
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.Suspense, {
            fallback: fallbackElement,
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(Wrap, {
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(Lazy, {
                    ...props
                })
            })
        });
    }
    LoadableComponent.displayName = "LoadableComponent";
    return LoadableComponent;
}
const _default = Loadable;

//# sourceMappingURL=loadable.js.map