"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    ImageResponse: null,
    experimental_FigmaImageResponse: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ImageResponse: function() {
        return ImageResponse;
    },
    experimental_FigmaImageResponse: function() {
        return experimental_FigmaImageResponse;
    }
});
function importModule() {
    return import(process.env.NEXT_RUNTIME === "edge" ? "next/dist/compiled/@vercel/og/index.edge.js" : "next/dist/compiled/@vercel/og/index.node.js");
}
class ImageResponse extends Response {
    static #_ = this.displayName = "ImageResponse";
    constructor(...args){
        const readable = new ReadableStream({
            async start (controller) {
                const OGImageResponse = // So far we have to manually determine which build to use,
                // as the auto resolving is not working
                (await importModule()).ImageResponse;
                const imageResponse = new OGImageResponse(...args);
                if (!imageResponse.body) {
                    return controller.close();
                }
                const reader = imageResponse.body.getReader();
                while(true){
                    const { done, value } = await reader.read();
                    if (done) {
                        return controller.close();
                    }
                    controller.enqueue(value);
                }
            }
        });
        const options = args[1] || {};
        super(readable, {
            headers: {
                "content-type": "image/png",
                "cache-control": process.env.NODE_ENV === "development" ? "no-cache, no-store" : "public, immutable, no-transform, max-age=31536000",
                ...options.headers
            },
            status: options.status,
            statusText: options.statusText
        });
    }
}
async function experimental_FigmaImageResponse(props) {
    const originExperimentalFigmaImageResponse = (await importModule()).experimental_FigmaImageResponse;
    return originExperimentalFigmaImageResponse(props);
}

//# sourceMappingURL=image-response.js.map