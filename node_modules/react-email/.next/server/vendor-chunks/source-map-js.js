/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/source-map-js";
exports.ids = ["vendor-chunks/source-map-js"];
exports.modules = {

/***/ "(action-browser)/../source-map-js/lib/array-set.js":
/*!*****************************************!*\
  !*** ../source-map-js/lib/array-set.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var util = __webpack_require__(/*! ./util */ \"(action-browser)/../source-map-js/lib/util.js\");\nvar has = Object.prototype.hasOwnProperty;\nvar hasNativeMap = typeof Map !== \"undefined\";\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */ function ArraySet() {\n    this._array = [];\n    this._set = hasNativeMap ? new Map() : Object.create(null);\n}\n/**\n * Static method for creating ArraySet instances from an existing array.\n */ ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n    var set = new ArraySet();\n    for(var i = 0, len = aArray.length; i < len; i++){\n        set.add(aArray[i], aAllowDuplicates);\n    }\n    return set;\n};\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */ ArraySet.prototype.size = function ArraySet_size() {\n    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */ ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n    var idx = this._array.length;\n    if (!isDuplicate || aAllowDuplicates) {\n        this._array.push(aStr);\n    }\n    if (!isDuplicate) {\n        if (hasNativeMap) {\n            this._set.set(aStr, idx);\n        } else {\n            this._set[sStr] = idx;\n        }\n    }\n};\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */ ArraySet.prototype.has = function ArraySet_has(aStr) {\n    if (hasNativeMap) {\n        return this._set.has(aStr);\n    } else {\n        var sStr = util.toSetString(aStr);\n        return has.call(this._set, sStr);\n    }\n};\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */ ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n    if (hasNativeMap) {\n        var idx = this._set.get(aStr);\n        if (idx >= 0) {\n            return idx;\n        }\n    } else {\n        var sStr = util.toSetString(aStr);\n        if (has.call(this._set, sStr)) {\n            return this._set[sStr];\n        }\n    }\n    throw new Error('\"' + aStr + '\" is not in the set.');\n};\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */ ArraySet.prototype.at = function ArraySet_at(aIdx) {\n    if (aIdx >= 0 && aIdx < this._array.length) {\n        return this._array[aIdx];\n    }\n    throw new Error(\"No element indexed by \" + aIdx);\n};\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */ ArraySet.prototype.toArray = function ArraySet_toArray() {\n    return this._array.slice();\n};\nexports.ArraySet = ArraySet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9zb3VyY2UtbWFwLWpzL2xpYi9hcnJheS1zZXQuanMiLCJtYXBwaW5ncyI6IkFBQUEseUNBQXlDLEdBQ3pDOzs7O0NBSUMsR0FFRCxJQUFJQSxPQUFPQyxtQkFBT0EsQ0FBQztBQUNuQixJQUFJQyxNQUFNQyxPQUFPQyxTQUFTLENBQUNDLGNBQWM7QUFDekMsSUFBSUMsZUFBZSxPQUFPQyxRQUFRO0FBRWxDOzs7OztDQUtDLEdBQ0QsU0FBU0M7SUFDUCxJQUFJLENBQUNDLE1BQU0sR0FBRyxFQUFFO0lBQ2hCLElBQUksQ0FBQ0MsSUFBSSxHQUFHSixlQUFlLElBQUlDLFFBQVFKLE9BQU9RLE1BQU0sQ0FBQztBQUN2RDtBQUVBOztDQUVDLEdBQ0RILFNBQVNJLFNBQVMsR0FBRyxTQUFTQyxtQkFBbUJDLE1BQU0sRUFBRUMsZ0JBQWdCO0lBQ3ZFLElBQUlDLE1BQU0sSUFBSVI7SUFDZCxJQUFLLElBQUlTLElBQUksR0FBR0MsTUFBTUosT0FBT0ssTUFBTSxFQUFFRixJQUFJQyxLQUFLRCxJQUFLO1FBQ2pERCxJQUFJSSxHQUFHLENBQUNOLE1BQU0sQ0FBQ0csRUFBRSxFQUFFRjtJQUNyQjtJQUNBLE9BQU9DO0FBQ1Q7QUFFQTs7Ozs7Q0FLQyxHQUNEUixTQUFTSixTQUFTLENBQUNpQixJQUFJLEdBQUcsU0FBU0M7SUFDakMsT0FBT2hCLGVBQWUsSUFBSSxDQUFDSSxJQUFJLENBQUNXLElBQUksR0FBR2xCLE9BQU9vQixtQkFBbUIsQ0FBQyxJQUFJLENBQUNiLElBQUksRUFBRVMsTUFBTTtBQUNyRjtBQUVBOzs7O0NBSUMsR0FDRFgsU0FBU0osU0FBUyxDQUFDZ0IsR0FBRyxHQUFHLFNBQVNJLGFBQWFDLElBQUksRUFBRVYsZ0JBQWdCO0lBQ25FLElBQUlXLE9BQU9wQixlQUFlbUIsT0FBT3pCLEtBQUsyQixXQUFXLENBQUNGO0lBQ2xELElBQUlHLGNBQWN0QixlQUFlLElBQUksQ0FBQ0osR0FBRyxDQUFDdUIsUUFBUXZCLElBQUkyQixJQUFJLENBQUMsSUFBSSxDQUFDbkIsSUFBSSxFQUFFZ0I7SUFDdEUsSUFBSUksTUFBTSxJQUFJLENBQUNyQixNQUFNLENBQUNVLE1BQU07SUFDNUIsSUFBSSxDQUFDUyxlQUFlYixrQkFBa0I7UUFDcEMsSUFBSSxDQUFDTixNQUFNLENBQUNzQixJQUFJLENBQUNOO0lBQ25CO0lBQ0EsSUFBSSxDQUFDRyxhQUFhO1FBQ2hCLElBQUl0QixjQUFjO1lBQ2hCLElBQUksQ0FBQ0ksSUFBSSxDQUFDTSxHQUFHLENBQUNTLE1BQU1LO1FBQ3RCLE9BQU87WUFDTCxJQUFJLENBQUNwQixJQUFJLENBQUNnQixLQUFLLEdBQUdJO1FBQ3BCO0lBQ0Y7QUFDRjtBQUVBOzs7O0NBSUMsR0FDRHRCLFNBQVNKLFNBQVMsQ0FBQ0YsR0FBRyxHQUFHLFNBQVM4QixhQUFhUCxJQUFJO0lBQ2pELElBQUluQixjQUFjO1FBQ2hCLE9BQU8sSUFBSSxDQUFDSSxJQUFJLENBQUNSLEdBQUcsQ0FBQ3VCO0lBQ3ZCLE9BQU87UUFDTCxJQUFJQyxPQUFPMUIsS0FBSzJCLFdBQVcsQ0FBQ0Y7UUFDNUIsT0FBT3ZCLElBQUkyQixJQUFJLENBQUMsSUFBSSxDQUFDbkIsSUFBSSxFQUFFZ0I7SUFDN0I7QUFDRjtBQUVBOzs7O0NBSUMsR0FDRGxCLFNBQVNKLFNBQVMsQ0FBQzZCLE9BQU8sR0FBRyxTQUFTQyxpQkFBaUJULElBQUk7SUFDekQsSUFBSW5CLGNBQWM7UUFDaEIsSUFBSXdCLE1BQU0sSUFBSSxDQUFDcEIsSUFBSSxDQUFDeUIsR0FBRyxDQUFDVjtRQUN4QixJQUFJSyxPQUFPLEdBQUc7WUFDVixPQUFPQTtRQUNYO0lBQ0YsT0FBTztRQUNMLElBQUlKLE9BQU8xQixLQUFLMkIsV0FBVyxDQUFDRjtRQUM1QixJQUFJdkIsSUFBSTJCLElBQUksQ0FBQyxJQUFJLENBQUNuQixJQUFJLEVBQUVnQixPQUFPO1lBQzdCLE9BQU8sSUFBSSxDQUFDaEIsSUFBSSxDQUFDZ0IsS0FBSztRQUN4QjtJQUNGO0lBRUEsTUFBTSxJQUFJVSxNQUFNLE1BQU1YLE9BQU87QUFDL0I7QUFFQTs7OztDQUlDLEdBQ0RqQixTQUFTSixTQUFTLENBQUNpQyxFQUFFLEdBQUcsU0FBU0MsWUFBWUMsSUFBSTtJQUMvQyxJQUFJQSxRQUFRLEtBQUtBLE9BQU8sSUFBSSxDQUFDOUIsTUFBTSxDQUFDVSxNQUFNLEVBQUU7UUFDMUMsT0FBTyxJQUFJLENBQUNWLE1BQU0sQ0FBQzhCLEtBQUs7SUFDMUI7SUFDQSxNQUFNLElBQUlILE1BQU0sMkJBQTJCRztBQUM3QztBQUVBOzs7O0NBSUMsR0FDRC9CLFNBQVNKLFNBQVMsQ0FBQ29DLE9BQU8sR0FBRyxTQUFTQztJQUNwQyxPQUFPLElBQUksQ0FBQ2hDLE1BQU0sQ0FBQ2lDLEtBQUs7QUFDMUI7QUFFQUMsZ0JBQWdCLEdBQUduQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWVtYWlsLy4uL3NvdXJjZS1tYXAtanMvbGliL2FycmF5LXNldC5qcz84MTFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGhhc05hdGl2ZU1hcCA9IHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCI7XG5cbi8qKlxuICogQSBkYXRhIHN0cnVjdHVyZSB3aGljaCBpcyBhIGNvbWJpbmF0aW9uIG9mIGFuIGFycmF5IGFuZCBhIHNldC4gQWRkaW5nIGEgbmV3XG4gKiBtZW1iZXIgaXMgTygxKSwgdGVzdGluZyBmb3IgbWVtYmVyc2hpcCBpcyBPKDEpLCBhbmQgZmluZGluZyB0aGUgaW5kZXggb2YgYW5cbiAqIGVsZW1lbnQgaXMgTygxKS4gUmVtb3ZpbmcgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGlzIG5vdCBzdXBwb3J0ZWQuIE9ubHlcbiAqIHN0cmluZ3MgYXJlIHN1cHBvcnRlZCBmb3IgbWVtYmVyc2hpcC5cbiAqL1xuZnVuY3Rpb24gQXJyYXlTZXQoKSB7XG4gIHRoaXMuX2FycmF5ID0gW107XG4gIHRoaXMuX3NldCA9IGhhc05hdGl2ZU1hcCA/IG5ldyBNYXAoKSA6IE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cbi8qKlxuICogU3RhdGljIG1ldGhvZCBmb3IgY3JlYXRpbmcgQXJyYXlTZXQgaW5zdGFuY2VzIGZyb20gYW4gZXhpc3RpbmcgYXJyYXkuXG4gKi9cbkFycmF5U2V0LmZyb21BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X2Zyb21BcnJheShhQXJyYXksIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgdmFyIHNldCA9IG5ldyBBcnJheVNldCgpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYUFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgc2V0LmFkZChhQXJyYXlbaV0sIGFBbGxvd0R1cGxpY2F0ZXMpO1xuICB9XG4gIHJldHVybiBzZXQ7XG59O1xuXG4vKipcbiAqIFJldHVybiBob3cgbWFueSB1bmlxdWUgaXRlbXMgYXJlIGluIHRoaXMgQXJyYXlTZXQuIElmIGR1cGxpY2F0ZXMgaGF2ZSBiZWVuXG4gKiBhZGRlZCwgdGhhbiB0aG9zZSBkbyBub3QgY291bnQgdG93YXJkcyB0aGUgc2l6ZS5cbiAqXG4gKiBAcmV0dXJucyBOdW1iZXJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBBcnJheVNldF9zaXplKCkge1xuICByZXR1cm4gaGFzTmF0aXZlTWFwID8gdGhpcy5fc2V0LnNpemUgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLl9zZXQpLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQWRkIHRoZSBnaXZlbiBzdHJpbmcgdG8gdGhpcyBzZXQuXG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBBcnJheVNldF9hZGQoYVN0ciwgYUFsbG93RHVwbGljYXRlcykge1xuICB2YXIgc1N0ciA9IGhhc05hdGl2ZU1hcCA/IGFTdHIgOiB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICB2YXIgaXNEdXBsaWNhdGUgPSBoYXNOYXRpdmVNYXAgPyB0aGlzLmhhcyhhU3RyKSA6IGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cik7XG4gIHZhciBpZHggPSB0aGlzLl9hcnJheS5sZW5ndGg7XG4gIGlmICghaXNEdXBsaWNhdGUgfHwgYUFsbG93RHVwbGljYXRlcykge1xuICAgIHRoaXMuX2FycmF5LnB1c2goYVN0cik7XG4gIH1cbiAgaWYgKCFpc0R1cGxpY2F0ZSkge1xuICAgIGlmIChoYXNOYXRpdmVNYXApIHtcbiAgICAgIHRoaXMuX3NldC5zZXQoYVN0ciwgaWR4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2V0W3NTdHJdID0gaWR4O1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBJcyB0aGUgZ2l2ZW4gc3RyaW5nIGEgbWVtYmVyIG9mIHRoaXMgc2V0P1xuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gQXJyYXlTZXRfaGFzKGFTdHIpIHtcbiAgaWYgKGhhc05hdGl2ZU1hcCkge1xuICAgIHJldHVybiB0aGlzLl9zZXQuaGFzKGFTdHIpO1xuICB9IGVsc2Uge1xuICAgIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgICByZXR1cm4gaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXaGF0IGlzIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gc3RyaW5nIGluIHRoZSBhcnJheT9cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBBcnJheVNldF9pbmRleE9mKGFTdHIpIHtcbiAgaWYgKGhhc05hdGl2ZU1hcCkge1xuICAgIHZhciBpZHggPSB0aGlzLl9zZXQuZ2V0KGFTdHIpO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICByZXR1cm4gaWR4O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cikpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXRbc1N0cl07XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU3RyICsgJ1wiIGlzIG5vdCBpbiB0aGUgc2V0LicpO1xufTtcblxuLyoqXG4gKiBXaGF0IGlzIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleD9cbiAqXG4gKiBAcGFyYW0gTnVtYmVyIGFJZHhcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gQXJyYXlTZXRfYXQoYUlkeCkge1xuICBpZiAoYUlkeCA+PSAwICYmIGFJZHggPCB0aGlzLl9hcnJheS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJyYXlbYUlkeF07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdObyBlbGVtZW50IGluZGV4ZWQgYnkgJyArIGFJZHgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNldCAod2hpY2ggaGFzIHRoZSBwcm9wZXIgaW5kaWNlc1xuICogaW5kaWNhdGVkIGJ5IGluZGV4T2YpLiBOb3RlIHRoYXQgdGhpcyBpcyBhIGNvcHkgb2YgdGhlIGludGVybmFsIGFycmF5IHVzZWRcbiAqIGZvciBzdG9yaW5nIHRoZSBtZW1iZXJzIHNvIHRoYXQgbm8gb25lIGNhbiBtZXNzIHdpdGggaW50ZXJuYWwgc3RhdGUuXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfdG9BcnJheSgpIHtcbiAgcmV0dXJuIHRoaXMuX2FycmF5LnNsaWNlKCk7XG59O1xuXG5leHBvcnRzLkFycmF5U2V0ID0gQXJyYXlTZXQ7XG4iXSwibmFtZXMiOlsidXRpbCIsInJlcXVpcmUiLCJoYXMiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImhhc05hdGl2ZU1hcCIsIk1hcCIsIkFycmF5U2V0IiwiX2FycmF5IiwiX3NldCIsImNyZWF0ZSIsImZyb21BcnJheSIsIkFycmF5U2V0X2Zyb21BcnJheSIsImFBcnJheSIsImFBbGxvd0R1cGxpY2F0ZXMiLCJzZXQiLCJpIiwibGVuIiwibGVuZ3RoIiwiYWRkIiwic2l6ZSIsIkFycmF5U2V0X3NpemUiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiQXJyYXlTZXRfYWRkIiwiYVN0ciIsInNTdHIiLCJ0b1NldFN0cmluZyIsImlzRHVwbGljYXRlIiwiY2FsbCIsImlkeCIsInB1c2giLCJBcnJheVNldF9oYXMiLCJpbmRleE9mIiwiQXJyYXlTZXRfaW5kZXhPZiIsImdldCIsIkVycm9yIiwiYXQiLCJBcnJheVNldF9hdCIsImFJZHgiLCJ0b0FycmF5IiwiQXJyYXlTZXRfdG9BcnJheSIsInNsaWNlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../source-map-js/lib/array-set.js\n");

/***/ }),

/***/ "(rsc)/../source-map-js/lib/array-set.js":
/*!*****************************************!*\
  !*** ../source-map-js/lib/array-set.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var util = __webpack_require__(/*! ./util */ \"(rsc)/../source-map-js/lib/util.js\");\nvar has = Object.prototype.hasOwnProperty;\nvar hasNativeMap = typeof Map !== \"undefined\";\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */ function ArraySet() {\n    this._array = [];\n    this._set = hasNativeMap ? new Map() : Object.create(null);\n}\n/**\n * Static method for creating ArraySet instances from an existing array.\n */ ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n    var set = new ArraySet();\n    for(var i = 0, len = aArray.length; i < len; i++){\n        set.add(aArray[i], aAllowDuplicates);\n    }\n    return set;\n};\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */ ArraySet.prototype.size = function ArraySet_size() {\n    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */ ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n    var idx = this._array.length;\n    if (!isDuplicate || aAllowDuplicates) {\n        this._array.push(aStr);\n    }\n    if (!isDuplicate) {\n        if (hasNativeMap) {\n            this._set.set(aStr, idx);\n        } else {\n            this._set[sStr] = idx;\n        }\n    }\n};\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */ ArraySet.prototype.has = function ArraySet_has(aStr) {\n    if (hasNativeMap) {\n        return this._set.has(aStr);\n    } else {\n        var sStr = util.toSetString(aStr);\n        return has.call(this._set, sStr);\n    }\n};\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */ ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n    if (hasNativeMap) {\n        var idx = this._set.get(aStr);\n        if (idx >= 0) {\n            return idx;\n        }\n    } else {\n        var sStr = util.toSetString(aStr);\n        if (has.call(this._set, sStr)) {\n            return this._set[sStr];\n        }\n    }\n    throw new Error('\"' + aStr + '\" is not in the set.');\n};\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */ ArraySet.prototype.at = function ArraySet_at(aIdx) {\n    if (aIdx >= 0 && aIdx < this._array.length) {\n        return this._array[aIdx];\n    }\n    throw new Error(\"No element indexed by \" + aIdx);\n};\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */ ArraySet.prototype.toArray = function ArraySet_toArray() {\n    return this._array.slice();\n};\nexports.ArraySet = ArraySet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vc291cmNlLW1hcC1qcy9saWIvYXJyYXktc2V0LmpzIiwibWFwcGluZ3MiOiJBQUFBLHlDQUF5QyxHQUN6Qzs7OztDQUlDLEdBRUQsSUFBSUEsT0FBT0MsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUMsTUFBTUMsT0FBT0MsU0FBUyxDQUFDQyxjQUFjO0FBQ3pDLElBQUlDLGVBQWUsT0FBT0MsUUFBUTtBQUVsQzs7Ozs7Q0FLQyxHQUNELFNBQVNDO0lBQ1AsSUFBSSxDQUFDQyxNQUFNLEdBQUcsRUFBRTtJQUNoQixJQUFJLENBQUNDLElBQUksR0FBR0osZUFBZSxJQUFJQyxRQUFRSixPQUFPUSxNQUFNLENBQUM7QUFDdkQ7QUFFQTs7Q0FFQyxHQUNESCxTQUFTSSxTQUFTLEdBQUcsU0FBU0MsbUJBQW1CQyxNQUFNLEVBQUVDLGdCQUFnQjtJQUN2RSxJQUFJQyxNQUFNLElBQUlSO0lBQ2QsSUFBSyxJQUFJUyxJQUFJLEdBQUdDLE1BQU1KLE9BQU9LLE1BQU0sRUFBRUYsSUFBSUMsS0FBS0QsSUFBSztRQUNqREQsSUFBSUksR0FBRyxDQUFDTixNQUFNLENBQUNHLEVBQUUsRUFBRUY7SUFDckI7SUFDQSxPQUFPQztBQUNUO0FBRUE7Ozs7O0NBS0MsR0FDRFIsU0FBU0osU0FBUyxDQUFDaUIsSUFBSSxHQUFHLFNBQVNDO0lBQ2pDLE9BQU9oQixlQUFlLElBQUksQ0FBQ0ksSUFBSSxDQUFDVyxJQUFJLEdBQUdsQixPQUFPb0IsbUJBQW1CLENBQUMsSUFBSSxDQUFDYixJQUFJLEVBQUVTLE1BQU07QUFDckY7QUFFQTs7OztDQUlDLEdBQ0RYLFNBQVNKLFNBQVMsQ0FBQ2dCLEdBQUcsR0FBRyxTQUFTSSxhQUFhQyxJQUFJLEVBQUVWLGdCQUFnQjtJQUNuRSxJQUFJVyxPQUFPcEIsZUFBZW1CLE9BQU96QixLQUFLMkIsV0FBVyxDQUFDRjtJQUNsRCxJQUFJRyxjQUFjdEIsZUFBZSxJQUFJLENBQUNKLEdBQUcsQ0FBQ3VCLFFBQVF2QixJQUFJMkIsSUFBSSxDQUFDLElBQUksQ0FBQ25CLElBQUksRUFBRWdCO0lBQ3RFLElBQUlJLE1BQU0sSUFBSSxDQUFDckIsTUFBTSxDQUFDVSxNQUFNO0lBQzVCLElBQUksQ0FBQ1MsZUFBZWIsa0JBQWtCO1FBQ3BDLElBQUksQ0FBQ04sTUFBTSxDQUFDc0IsSUFBSSxDQUFDTjtJQUNuQjtJQUNBLElBQUksQ0FBQ0csYUFBYTtRQUNoQixJQUFJdEIsY0FBYztZQUNoQixJQUFJLENBQUNJLElBQUksQ0FBQ00sR0FBRyxDQUFDUyxNQUFNSztRQUN0QixPQUFPO1lBQ0wsSUFBSSxDQUFDcEIsSUFBSSxDQUFDZ0IsS0FBSyxHQUFHSTtRQUNwQjtJQUNGO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ0R0QixTQUFTSixTQUFTLENBQUNGLEdBQUcsR0FBRyxTQUFTOEIsYUFBYVAsSUFBSTtJQUNqRCxJQUFJbkIsY0FBYztRQUNoQixPQUFPLElBQUksQ0FBQ0ksSUFBSSxDQUFDUixHQUFHLENBQUN1QjtJQUN2QixPQUFPO1FBQ0wsSUFBSUMsT0FBTzFCLEtBQUsyQixXQUFXLENBQUNGO1FBQzVCLE9BQU92QixJQUFJMkIsSUFBSSxDQUFDLElBQUksQ0FBQ25CLElBQUksRUFBRWdCO0lBQzdCO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ0RsQixTQUFTSixTQUFTLENBQUM2QixPQUFPLEdBQUcsU0FBU0MsaUJBQWlCVCxJQUFJO0lBQ3pELElBQUluQixjQUFjO1FBQ2hCLElBQUl3QixNQUFNLElBQUksQ0FBQ3BCLElBQUksQ0FBQ3lCLEdBQUcsQ0FBQ1Y7UUFDeEIsSUFBSUssT0FBTyxHQUFHO1lBQ1YsT0FBT0E7UUFDWDtJQUNGLE9BQU87UUFDTCxJQUFJSixPQUFPMUIsS0FBSzJCLFdBQVcsQ0FBQ0Y7UUFDNUIsSUFBSXZCLElBQUkyQixJQUFJLENBQUMsSUFBSSxDQUFDbkIsSUFBSSxFQUFFZ0IsT0FBTztZQUM3QixPQUFPLElBQUksQ0FBQ2hCLElBQUksQ0FBQ2dCLEtBQUs7UUFDeEI7SUFDRjtJQUVBLE1BQU0sSUFBSVUsTUFBTSxNQUFNWCxPQUFPO0FBQy9CO0FBRUE7Ozs7Q0FJQyxHQUNEakIsU0FBU0osU0FBUyxDQUFDaUMsRUFBRSxHQUFHLFNBQVNDLFlBQVlDLElBQUk7SUFDL0MsSUFBSUEsUUFBUSxLQUFLQSxPQUFPLElBQUksQ0FBQzlCLE1BQU0sQ0FBQ1UsTUFBTSxFQUFFO1FBQzFDLE9BQU8sSUFBSSxDQUFDVixNQUFNLENBQUM4QixLQUFLO0lBQzFCO0lBQ0EsTUFBTSxJQUFJSCxNQUFNLDJCQUEyQkc7QUFDN0M7QUFFQTs7OztDQUlDLEdBQ0QvQixTQUFTSixTQUFTLENBQUNvQyxPQUFPLEdBQUcsU0FBU0M7SUFDcEMsT0FBTyxJQUFJLENBQUNoQyxNQUFNLENBQUNpQyxLQUFLO0FBQzFCO0FBRUFDLGdCQUFnQixHQUFHbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1lbWFpbC8uLi9zb3VyY2UtbWFwLWpzL2xpYi9hcnJheS1zZXQuanM/ODExZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBoYXNOYXRpdmVNYXAgPSB0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiO1xuXG4vKipcbiAqIEEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggaXMgYSBjb21iaW5hdGlvbiBvZiBhbiBhcnJheSBhbmQgYSBzZXQuIEFkZGluZyBhIG5ld1xuICogbWVtYmVyIGlzIE8oMSksIHRlc3RpbmcgZm9yIG1lbWJlcnNoaXAgaXMgTygxKSwgYW5kIGZpbmRpbmcgdGhlIGluZGV4IG9mIGFuXG4gKiBlbGVtZW50IGlzIE8oMSkuIFJlbW92aW5nIGVsZW1lbnRzIGZyb20gdGhlIHNldCBpcyBub3Qgc3VwcG9ydGVkLiBPbmx5XG4gKiBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQgZm9yIG1lbWJlcnNoaXAuXG4gKi9cbmZ1bmN0aW9uIEFycmF5U2V0KCkge1xuICB0aGlzLl9hcnJheSA9IFtdO1xuICB0aGlzLl9zZXQgPSBoYXNOYXRpdmVNYXAgPyBuZXcgTWFwKCkgOiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG4vKipcbiAqIFN0YXRpYyBtZXRob2QgZm9yIGNyZWF0aW5nIEFycmF5U2V0IGluc3RhbmNlcyBmcm9tIGFuIGV4aXN0aW5nIGFycmF5LlxuICovXG5BcnJheVNldC5mcm9tQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF9mcm9tQXJyYXkoYUFycmF5LCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzZXQgPSBuZXcgQXJyYXlTZXQoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHNldC5hZGQoYUFycmF5W2ldLCBhQWxsb3dEdXBsaWNhdGVzKTtcbiAgfVxuICByZXR1cm4gc2V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gaG93IG1hbnkgdW5pcXVlIGl0ZW1zIGFyZSBpbiB0aGlzIEFycmF5U2V0LiBJZiBkdXBsaWNhdGVzIGhhdmUgYmVlblxuICogYWRkZWQsIHRoYW4gdGhvc2UgZG8gbm90IGNvdW50IHRvd2FyZHMgdGhlIHNpemUuXG4gKlxuICogQHJldHVybnMgTnVtYmVyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gQXJyYXlTZXRfc2l6ZSgpIHtcbiAgcmV0dXJuIGhhc05hdGl2ZU1hcCA/IHRoaXMuX3NldC5zaXplIDogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fc2V0KS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gc3RyaW5nIHRvIHRoaXMgc2V0LlxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gQXJyYXlTZXRfYWRkKGFTdHIsIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgdmFyIHNTdHIgPSBoYXNOYXRpdmVNYXAgPyBhU3RyIDogdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgdmFyIGlzRHVwbGljYXRlID0gaGFzTmF0aXZlTWFwID8gdGhpcy5oYXMoYVN0cikgOiBoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpO1xuICB2YXIgaWR4ID0gdGhpcy5fYXJyYXkubGVuZ3RoO1xuICBpZiAoIWlzRHVwbGljYXRlIHx8IGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFTdHIpO1xuICB9XG4gIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgICB0aGlzLl9zZXQuc2V0KGFTdHIsIGlkeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NldFtzU3RyXSA9IGlkeDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSXMgdGhlIGdpdmVuIHN0cmluZyBhIG1lbWJlciBvZiB0aGlzIHNldD9cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIEFycmF5U2V0X2hhcyhhU3RyKSB7XG4gIGlmIChoYXNOYXRpdmVNYXApIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0LmhhcyhhU3RyKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gICAgcmV0dXJuIGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cik7XG4gIH1cbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHN0cmluZyBpbiB0aGUgYXJyYXk/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gQXJyYXlTZXRfaW5kZXhPZihhU3RyKSB7XG4gIGlmIChoYXNOYXRpdmVNYXApIHtcbiAgICB2YXIgaWR4ID0gdGhpcy5fc2V0LmdldChhU3RyKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0W3NTdHJdO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignXCInICsgYVN0ciArICdcIiBpcyBub3QgaW4gdGhlIHNldC4nKTtcbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXg/XG4gKlxuICogQHBhcmFtIE51bWJlciBhSWR4XG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIEFycmF5U2V0X2F0KGFJZHgpIHtcbiAgaWYgKGFJZHggPj0gMCAmJiBhSWR4IDwgdGhpcy5fYXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5W2FJZHhdO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBpbmRleGVkIGJ5ICcgKyBhSWR4KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzZXQgKHdoaWNoIGhhcyB0aGUgcHJvcGVyIGluZGljZXNcbiAqIGluZGljYXRlZCBieSBpbmRleE9mKS4gTm90ZSB0aGF0IHRoaXMgaXMgYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBhcnJheSB1c2VkXG4gKiBmb3Igc3RvcmluZyB0aGUgbWVtYmVycyBzbyB0aGF0IG5vIG9uZSBjYW4gbWVzcyB3aXRoIGludGVybmFsIHN0YXRlLlxuICovXG5BcnJheVNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X3RvQXJyYXkoKSB7XG4gIHJldHVybiB0aGlzLl9hcnJheS5zbGljZSgpO1xufTtcblxuZXhwb3J0cy5BcnJheVNldCA9IEFycmF5U2V0O1xuIl0sIm5hbWVzIjpbInV0aWwiLCJyZXF1aXJlIiwiaGFzIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJoYXNOYXRpdmVNYXAiLCJNYXAiLCJBcnJheVNldCIsIl9hcnJheSIsIl9zZXQiLCJjcmVhdGUiLCJmcm9tQXJyYXkiLCJBcnJheVNldF9mcm9tQXJyYXkiLCJhQXJyYXkiLCJhQWxsb3dEdXBsaWNhdGVzIiwic2V0IiwiaSIsImxlbiIsImxlbmd0aCIsImFkZCIsInNpemUiLCJBcnJheVNldF9zaXplIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIkFycmF5U2V0X2FkZCIsImFTdHIiLCJzU3RyIiwidG9TZXRTdHJpbmciLCJpc0R1cGxpY2F0ZSIsImNhbGwiLCJpZHgiLCJwdXNoIiwiQXJyYXlTZXRfaGFzIiwiaW5kZXhPZiIsIkFycmF5U2V0X2luZGV4T2YiLCJnZXQiLCJFcnJvciIsImF0IiwiQXJyYXlTZXRfYXQiLCJhSWR4IiwidG9BcnJheSIsIkFycmF5U2V0X3RvQXJyYXkiLCJzbGljZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../source-map-js/lib/array-set.js\n");

/***/ }),

/***/ "(action-browser)/../source-map-js/lib/base64-vlq.js":
/*!******************************************!*\
  !*** ../source-map-js/lib/base64-vlq.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */ var base64 = __webpack_require__(/*! ./base64 */ \"(action-browser)/../source-map-js/lib/base64.js\");\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\nvar VLQ_BASE_SHIFT = 5;\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */ function toVLQSigned(aValue) {\n    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;\n}\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */ function fromVLQSigned(aValue) {\n    var isNegative = (aValue & 1) === 1;\n    var shifted = aValue >> 1;\n    return isNegative ? -shifted : shifted;\n}\n/**\n * Returns the base 64 VLQ encoded value.\n */ exports.encode = function base64VLQ_encode(aValue) {\n    var encoded = \"\";\n    var digit;\n    var vlq = toVLQSigned(aValue);\n    do {\n        digit = vlq & VLQ_BASE_MASK;\n        vlq >>>= VLQ_BASE_SHIFT;\n        if (vlq > 0) {\n            // There are still more digits in this value, so we must make sure the\n            // continuation bit is marked.\n            digit |= VLQ_CONTINUATION_BIT;\n        }\n        encoded += base64.encode(digit);\n    }while (vlq > 0);\n    return encoded;\n};\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */ exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n    var strLen = aStr.length;\n    var result = 0;\n    var shift = 0;\n    var continuation, digit;\n    do {\n        if (aIndex >= strLen) {\n            throw new Error(\"Expected more digits in base 64 VLQ value.\");\n        }\n        digit = base64.decode(aStr.charCodeAt(aIndex++));\n        if (digit === -1) {\n            throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n        }\n        continuation = !!(digit & VLQ_CONTINUATION_BIT);\n        digit &= VLQ_BASE_MASK;\n        result = result + (digit << shift);\n        shift += VLQ_BASE_SHIFT;\n    }while (continuation);\n    aOutParam.value = fromVLQSigned(result);\n    aOutParam.rest = aIndex;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9zb3VyY2UtbWFwLWpzL2xpYi9iYXNlNjQtdmxxLmpzIiwibWFwcGluZ3MiOiJBQUFBLHlDQUF5QyxHQUN6Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtDQyxHQUVELElBQUlBLFNBQVNDLG1CQUFPQSxDQUFDO0FBRXJCLDhFQUE4RTtBQUM5RSw4RUFBOEU7QUFDOUUsa0VBQWtFO0FBQ2xFLHlFQUF5RTtBQUN6RSw2Q0FBNkM7QUFDN0MsRUFBRTtBQUNGLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2QsV0FBVztBQUNYLFdBQVc7QUFDWCxXQUFXO0FBRVgsSUFBSUMsaUJBQWlCO0FBRXJCLGlCQUFpQjtBQUNqQixJQUFJQyxXQUFXLEtBQUtEO0FBRXBCLGlCQUFpQjtBQUNqQixJQUFJRSxnQkFBZ0JELFdBQVc7QUFFL0IsaUJBQWlCO0FBQ2pCLElBQUlFLHVCQUF1QkY7QUFFM0I7Ozs7O0NBS0MsR0FDRCxTQUFTRyxZQUFZQyxNQUFNO0lBQ3pCLE9BQU9BLFNBQVMsSUFDWixDQUFDLENBQUVBLFVBQVcsS0FBSyxJQUNuQixDQUFDQSxVQUFVLEtBQUs7QUFDdEI7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNDLGNBQWNELE1BQU07SUFDM0IsSUFBSUUsYUFBYSxDQUFDRixTQUFTLE9BQU87SUFDbEMsSUFBSUcsVUFBVUgsVUFBVTtJQUN4QixPQUFPRSxhQUNILENBQUNDLFVBQ0RBO0FBQ047QUFFQTs7Q0FFQyxHQUNEQyxjQUFjLEdBQUcsU0FBU0UsaUJBQWlCTixNQUFNO0lBQy9DLElBQUlPLFVBQVU7SUFDZCxJQUFJQztJQUVKLElBQUlDLE1BQU1WLFlBQVlDO0lBRXRCLEdBQUc7UUFDRFEsUUFBUUMsTUFBTVo7UUFDZFksU0FBU2Q7UUFDVCxJQUFJYyxNQUFNLEdBQUc7WUFDWCxzRUFBc0U7WUFDdEUsOEJBQThCO1lBQzlCRCxTQUFTVjtRQUNYO1FBQ0FTLFdBQVdkLE9BQU9ZLE1BQU0sQ0FBQ0c7SUFDM0IsUUFBU0MsTUFBTSxHQUFHO0lBRWxCLE9BQU9GO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDREgsY0FBYyxHQUFHLFNBQVNPLGlCQUFpQkMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLFNBQVM7SUFDaEUsSUFBSUMsU0FBU0gsS0FBS0ksTUFBTTtJQUN4QixJQUFJQyxTQUFTO0lBQ2IsSUFBSUMsUUFBUTtJQUNaLElBQUlDLGNBQWNYO0lBRWxCLEdBQUc7UUFDRCxJQUFJSyxVQUFVRSxRQUFRO1lBQ3BCLE1BQU0sSUFBSUssTUFBTTtRQUNsQjtRQUVBWixRQUFRZixPQUFPaUIsTUFBTSxDQUFDRSxLQUFLUyxVQUFVLENBQUNSO1FBQ3RDLElBQUlMLFVBQVUsQ0FBQyxHQUFHO1lBQ2hCLE1BQU0sSUFBSVksTUFBTSwyQkFBMkJSLEtBQUtVLE1BQU0sQ0FBQ1QsU0FBUztRQUNsRTtRQUVBTSxlQUFlLENBQUMsQ0FBRVgsQ0FBQUEsUUFBUVYsb0JBQW1CO1FBQzdDVSxTQUFTWDtRQUNUb0IsU0FBU0EsU0FBVVQsQ0FBQUEsU0FBU1UsS0FBSTtRQUNoQ0EsU0FBU3ZCO0lBQ1gsUUFBU3dCLGNBQWM7SUFFdkJMLFVBQVVTLEtBQUssR0FBR3RCLGNBQWNnQjtJQUNoQ0gsVUFBVVUsSUFBSSxHQUFHWDtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWVtYWlsLy4uL3NvdXJjZS1tYXAtanMvbGliL2Jhc2U2NC12bHEuanM/NDBiZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqIEJhc2VkIG9uIHRoZSBCYXNlIDY0IFZMUSBpbXBsZW1lbnRhdGlvbiBpbiBDbG9zdXJlIENvbXBpbGVyOlxuICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jbG9zdXJlLWNvbXBpbGVyL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvZGVidWdnaW5nL3NvdXJjZW1hcC9CYXNlNjRWTFEuamF2YVxuICpcbiAqIENvcHlyaWdodCAyMDExIFRoZSBDbG9zdXJlIENvbXBpbGVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxuICogICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkXG4gKiAgICBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpO1xuXG4vLyBBIHNpbmdsZSBiYXNlIDY0IGRpZ2l0IGNhbiBjb250YWluIDYgYml0cyBvZiBkYXRhLiBGb3IgdGhlIGJhc2UgNjQgdmFyaWFibGVcbi8vIGxlbmd0aCBxdWFudGl0aWVzIHdlIHVzZSBpbiB0aGUgc291cmNlIG1hcCBzcGVjLCB0aGUgZmlyc3QgYml0IGlzIHRoZSBzaWduLFxuLy8gdGhlIG5leHQgZm91ciBiaXRzIGFyZSB0aGUgYWN0dWFsIHZhbHVlLCBhbmQgdGhlIDZ0aCBiaXQgaXMgdGhlXG4vLyBjb250aW51YXRpb24gYml0LiBUaGUgY29udGludWF0aW9uIGJpdCB0ZWxscyB1cyB3aGV0aGVyIHRoZXJlIGFyZSBtb3JlXG4vLyBkaWdpdHMgaW4gdGhpcyB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBkaWdpdC5cbi8vXG4vLyAgIENvbnRpbnVhdGlvblxuLy8gICB8ICAgIFNpZ25cbi8vICAgfCAgICB8XG4vLyAgIFYgICAgVlxuLy8gICAxMDEwMTFcblxudmFyIFZMUV9CQVNFX1NISUZUID0gNTtcblxuLy8gYmluYXJ5OiAxMDAwMDBcbnZhciBWTFFfQkFTRSA9IDEgPDwgVkxRX0JBU0VfU0hJRlQ7XG5cbi8vIGJpbmFyeTogMDExMTExXG52YXIgVkxRX0JBU0VfTUFTSyA9IFZMUV9CQVNFIC0gMTtcblxuLy8gYmluYXJ5OiAxMDAwMDBcbnZhciBWTFFfQ09OVElOVUFUSU9OX0JJVCA9IFZMUV9CQVNFO1xuXG4vKipcbiAqIENvbnZlcnRzIGZyb20gYSB0d28tY29tcGxlbWVudCB2YWx1ZSB0byBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDEgYmVjb21lcyAyICgxMCBiaW5hcnkpLCAtMSBiZWNvbWVzIDMgKDExIGJpbmFyeSlcbiAqICAgMiBiZWNvbWVzIDQgKDEwMCBiaW5hcnkpLCAtMiBiZWNvbWVzIDUgKDEwMSBiaW5hcnkpXG4gKi9cbmZ1bmN0aW9uIHRvVkxRU2lnbmVkKGFWYWx1ZSkge1xuICByZXR1cm4gYVZhbHVlIDwgMFxuICAgID8gKCgtYVZhbHVlKSA8PCAxKSArIDFcbiAgICA6IChhVmFsdWUgPDwgMSkgKyAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRvIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgZnJvbSBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDIgKDEwIGJpbmFyeSkgYmVjb21lcyAxLCAzICgxMSBiaW5hcnkpIGJlY29tZXMgLTFcbiAqICAgNCAoMTAwIGJpbmFyeSkgYmVjb21lcyAyLCA1ICgxMDEgYmluYXJ5KSBiZWNvbWVzIC0yXG4gKi9cbmZ1bmN0aW9uIGZyb21WTFFTaWduZWQoYVZhbHVlKSB7XG4gIHZhciBpc05lZ2F0aXZlID0gKGFWYWx1ZSAmIDEpID09PSAxO1xuICB2YXIgc2hpZnRlZCA9IGFWYWx1ZSA+PiAxO1xuICByZXR1cm4gaXNOZWdhdGl2ZVxuICAgID8gLXNoaWZ0ZWRcbiAgICA6IHNoaWZ0ZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYmFzZSA2NCBWTFEgZW5jb2RlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZW5jb2RlKGFWYWx1ZSkge1xuICB2YXIgZW5jb2RlZCA9IFwiXCI7XG4gIHZhciBkaWdpdDtcblxuICB2YXIgdmxxID0gdG9WTFFTaWduZWQoYVZhbHVlKTtcblxuICBkbyB7XG4gICAgZGlnaXQgPSB2bHEgJiBWTFFfQkFTRV9NQVNLO1xuICAgIHZscSA+Pj49IFZMUV9CQVNFX1NISUZUO1xuICAgIGlmICh2bHEgPiAwKSB7XG4gICAgICAvLyBUaGVyZSBhcmUgc3RpbGwgbW9yZSBkaWdpdHMgaW4gdGhpcyB2YWx1ZSwgc28gd2UgbXVzdCBtYWtlIHN1cmUgdGhlXG4gICAgICAvLyBjb250aW51YXRpb24gYml0IGlzIG1hcmtlZC5cbiAgICAgIGRpZ2l0IHw9IFZMUV9DT05USU5VQVRJT05fQklUO1xuICAgIH1cbiAgICBlbmNvZGVkICs9IGJhc2U2NC5lbmNvZGUoZGlnaXQpO1xuICB9IHdoaWxlICh2bHEgPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyB0aGUgbmV4dCBiYXNlIDY0IFZMUSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgdGhlXG4gKiB2YWx1ZSBhbmQgdGhlIHJlc3Qgb2YgdGhlIHN0cmluZyB2aWEgdGhlIG91dCBwYXJhbWV0ZXIuXG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2RlY29kZShhU3RyLCBhSW5kZXgsIGFPdXRQYXJhbSkge1xuICB2YXIgc3RyTGVuID0gYVN0ci5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSAwO1xuICB2YXIgc2hpZnQgPSAwO1xuICB2YXIgY29udGludWF0aW9uLCBkaWdpdDtcblxuICBkbyB7XG4gICAgaWYgKGFJbmRleCA+PSBzdHJMZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG1vcmUgZGlnaXRzIGluIGJhc2UgNjQgVkxRIHZhbHVlLlwiKTtcbiAgICB9XG5cbiAgICBkaWdpdCA9IGJhc2U2NC5kZWNvZGUoYVN0ci5jaGFyQ29kZUF0KGFJbmRleCsrKSk7XG4gICAgaWYgKGRpZ2l0ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBiYXNlNjQgZGlnaXQ6IFwiICsgYVN0ci5jaGFyQXQoYUluZGV4IC0gMSkpO1xuICAgIH1cblxuICAgIGNvbnRpbnVhdGlvbiA9ICEhKGRpZ2l0ICYgVkxRX0NPTlRJTlVBVElPTl9CSVQpO1xuICAgIGRpZ2l0ICY9IFZMUV9CQVNFX01BU0s7XG4gICAgcmVzdWx0ID0gcmVzdWx0ICsgKGRpZ2l0IDw8IHNoaWZ0KTtcbiAgICBzaGlmdCArPSBWTFFfQkFTRV9TSElGVDtcbiAgfSB3aGlsZSAoY29udGludWF0aW9uKTtcblxuICBhT3V0UGFyYW0udmFsdWUgPSBmcm9tVkxRU2lnbmVkKHJlc3VsdCk7XG4gIGFPdXRQYXJhbS5yZXN0ID0gYUluZGV4O1xufTtcbiJdLCJuYW1lcyI6WyJiYXNlNjQiLCJyZXF1aXJlIiwiVkxRX0JBU0VfU0hJRlQiLCJWTFFfQkFTRSIsIlZMUV9CQVNFX01BU0siLCJWTFFfQ09OVElOVUFUSU9OX0JJVCIsInRvVkxRU2lnbmVkIiwiYVZhbHVlIiwiZnJvbVZMUVNpZ25lZCIsImlzTmVnYXRpdmUiLCJzaGlmdGVkIiwiZXhwb3J0cyIsImVuY29kZSIsImJhc2U2NFZMUV9lbmNvZGUiLCJlbmNvZGVkIiwiZGlnaXQiLCJ2bHEiLCJkZWNvZGUiLCJiYXNlNjRWTFFfZGVjb2RlIiwiYVN0ciIsImFJbmRleCIsImFPdXRQYXJhbSIsInN0ckxlbiIsImxlbmd0aCIsInJlc3VsdCIsInNoaWZ0IiwiY29udGludWF0aW9uIiwiRXJyb3IiLCJjaGFyQ29kZUF0IiwiY2hhckF0IiwidmFsdWUiLCJyZXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../source-map-js/lib/base64-vlq.js\n");

/***/ }),

/***/ "(rsc)/../source-map-js/lib/base64-vlq.js":
/*!******************************************!*\
  !*** ../source-map-js/lib/base64-vlq.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */ var base64 = __webpack_require__(/*! ./base64 */ \"(rsc)/../source-map-js/lib/base64.js\");\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\nvar VLQ_BASE_SHIFT = 5;\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */ function toVLQSigned(aValue) {\n    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;\n}\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */ function fromVLQSigned(aValue) {\n    var isNegative = (aValue & 1) === 1;\n    var shifted = aValue >> 1;\n    return isNegative ? -shifted : shifted;\n}\n/**\n * Returns the base 64 VLQ encoded value.\n */ exports.encode = function base64VLQ_encode(aValue) {\n    var encoded = \"\";\n    var digit;\n    var vlq = toVLQSigned(aValue);\n    do {\n        digit = vlq & VLQ_BASE_MASK;\n        vlq >>>= VLQ_BASE_SHIFT;\n        if (vlq > 0) {\n            // There are still more digits in this value, so we must make sure the\n            // continuation bit is marked.\n            digit |= VLQ_CONTINUATION_BIT;\n        }\n        encoded += base64.encode(digit);\n    }while (vlq > 0);\n    return encoded;\n};\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */ exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n    var strLen = aStr.length;\n    var result = 0;\n    var shift = 0;\n    var continuation, digit;\n    do {\n        if (aIndex >= strLen) {\n            throw new Error(\"Expected more digits in base 64 VLQ value.\");\n        }\n        digit = base64.decode(aStr.charCodeAt(aIndex++));\n        if (digit === -1) {\n            throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n        }\n        continuation = !!(digit & VLQ_CONTINUATION_BIT);\n        digit &= VLQ_BASE_MASK;\n        result = result + (digit << shift);\n        shift += VLQ_BASE_SHIFT;\n    }while (continuation);\n    aOutParam.value = fromVLQSigned(result);\n    aOutParam.rest = aIndex;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vc291cmNlLW1hcC1qcy9saWIvYmFzZTY0LXZscS5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5Q0FBeUMsR0FDekM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQ0MsR0FFRCxJQUFJQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUVyQiw4RUFBOEU7QUFDOUUsOEVBQThFO0FBQzlFLGtFQUFrRTtBQUNsRSx5RUFBeUU7QUFDekUsNkNBQTZDO0FBQzdDLEVBQUU7QUFDRixpQkFBaUI7QUFDakIsY0FBYztBQUNkLFdBQVc7QUFDWCxXQUFXO0FBQ1gsV0FBVztBQUVYLElBQUlDLGlCQUFpQjtBQUVyQixpQkFBaUI7QUFDakIsSUFBSUMsV0FBVyxLQUFLRDtBQUVwQixpQkFBaUI7QUFDakIsSUFBSUUsZ0JBQWdCRCxXQUFXO0FBRS9CLGlCQUFpQjtBQUNqQixJQUFJRSx1QkFBdUJGO0FBRTNCOzs7OztDQUtDLEdBQ0QsU0FBU0csWUFBWUMsTUFBTTtJQUN6QixPQUFPQSxTQUFTLElBQ1osQ0FBQyxDQUFFQSxVQUFXLEtBQUssSUFDbkIsQ0FBQ0EsVUFBVSxLQUFLO0FBQ3RCO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTQyxjQUFjRCxNQUFNO0lBQzNCLElBQUlFLGFBQWEsQ0FBQ0YsU0FBUyxPQUFPO0lBQ2xDLElBQUlHLFVBQVVILFVBQVU7SUFDeEIsT0FBT0UsYUFDSCxDQUFDQyxVQUNEQTtBQUNOO0FBRUE7O0NBRUMsR0FDREMsY0FBYyxHQUFHLFNBQVNFLGlCQUFpQk4sTUFBTTtJQUMvQyxJQUFJTyxVQUFVO0lBQ2QsSUFBSUM7SUFFSixJQUFJQyxNQUFNVixZQUFZQztJQUV0QixHQUFHO1FBQ0RRLFFBQVFDLE1BQU1aO1FBQ2RZLFNBQVNkO1FBQ1QsSUFBSWMsTUFBTSxHQUFHO1lBQ1gsc0VBQXNFO1lBQ3RFLDhCQUE4QjtZQUM5QkQsU0FBU1Y7UUFDWDtRQUNBUyxXQUFXZCxPQUFPWSxNQUFNLENBQUNHO0lBQzNCLFFBQVNDLE1BQU0sR0FBRztJQUVsQixPQUFPRjtBQUNUO0FBRUE7OztDQUdDLEdBQ0RILGNBQWMsR0FBRyxTQUFTTyxpQkFBaUJDLElBQUksRUFBRUMsTUFBTSxFQUFFQyxTQUFTO0lBQ2hFLElBQUlDLFNBQVNILEtBQUtJLE1BQU07SUFDeEIsSUFBSUMsU0FBUztJQUNiLElBQUlDLFFBQVE7SUFDWixJQUFJQyxjQUFjWDtJQUVsQixHQUFHO1FBQ0QsSUFBSUssVUFBVUUsUUFBUTtZQUNwQixNQUFNLElBQUlLLE1BQU07UUFDbEI7UUFFQVosUUFBUWYsT0FBT2lCLE1BQU0sQ0FBQ0UsS0FBS1MsVUFBVSxDQUFDUjtRQUN0QyxJQUFJTCxVQUFVLENBQUMsR0FBRztZQUNoQixNQUFNLElBQUlZLE1BQU0sMkJBQTJCUixLQUFLVSxNQUFNLENBQUNULFNBQVM7UUFDbEU7UUFFQU0sZUFBZSxDQUFDLENBQUVYLENBQUFBLFFBQVFWLG9CQUFtQjtRQUM3Q1UsU0FBU1g7UUFDVG9CLFNBQVNBLFNBQVVULENBQUFBLFNBQVNVLEtBQUk7UUFDaENBLFNBQVN2QjtJQUNYLFFBQVN3QixjQUFjO0lBRXZCTCxVQUFVUyxLQUFLLEdBQUd0QixjQUFjZ0I7SUFDaENILFVBQVVVLElBQUksR0FBR1g7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1lbWFpbC8uLi9zb3VyY2UtbWFwLWpzL2xpYi9iYXNlNjQtdmxxLmpzPzQwYmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqXG4gKiBCYXNlZCBvbiB0aGUgQmFzZSA2NCBWTFEgaW1wbGVtZW50YXRpb24gaW4gQ2xvc3VyZSBDb21waWxlcjpcbiAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2xvc3VyZS1jb21waWxlci9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9jb20vZ29vZ2xlL2RlYnVnZ2luZy9zb3VyY2VtYXAvQmFzZTY0VkxRLmphdmFcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBUaGUgQ2xvc3VyZSBDb21waWxlciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcbiAqICAgIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZFxuICogICAgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4gKiBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAqIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlNjQnKTtcblxuLy8gQSBzaW5nbGUgYmFzZSA2NCBkaWdpdCBjYW4gY29udGFpbiA2IGJpdHMgb2YgZGF0YS4gRm9yIHRoZSBiYXNlIDY0IHZhcmlhYmxlXG4vLyBsZW5ndGggcXVhbnRpdGllcyB3ZSB1c2UgaW4gdGhlIHNvdXJjZSBtYXAgc3BlYywgdGhlIGZpcnN0IGJpdCBpcyB0aGUgc2lnbixcbi8vIHRoZSBuZXh0IGZvdXIgYml0cyBhcmUgdGhlIGFjdHVhbCB2YWx1ZSwgYW5kIHRoZSA2dGggYml0IGlzIHRoZVxuLy8gY29udGludWF0aW9uIGJpdC4gVGhlIGNvbnRpbnVhdGlvbiBiaXQgdGVsbHMgdXMgd2hldGhlciB0aGVyZSBhcmUgbW9yZVxuLy8gZGlnaXRzIGluIHRoaXMgdmFsdWUgZm9sbG93aW5nIHRoaXMgZGlnaXQuXG4vL1xuLy8gICBDb250aW51YXRpb25cbi8vICAgfCAgICBTaWduXG4vLyAgIHwgICAgfFxuLy8gICBWICAgIFZcbi8vICAgMTAxMDExXG5cbnZhciBWTFFfQkFTRV9TSElGVCA9IDU7XG5cbi8vIGJpbmFyeTogMTAwMDAwXG52YXIgVkxRX0JBU0UgPSAxIDw8IFZMUV9CQVNFX1NISUZUO1xuXG4vLyBiaW5hcnk6IDAxMTExMVxudmFyIFZMUV9CQVNFX01BU0sgPSBWTFFfQkFTRSAtIDE7XG5cbi8vIGJpbmFyeTogMTAwMDAwXG52YXIgVkxRX0NPTlRJTlVBVElPTl9CSVQgPSBWTFFfQkFTRTtcblxuLyoqXG4gKiBDb252ZXJ0cyBmcm9tIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgdG8gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICogICAxIGJlY29tZXMgMiAoMTAgYmluYXJ5KSwgLTEgYmVjb21lcyAzICgxMSBiaW5hcnkpXG4gKiAgIDIgYmVjb21lcyA0ICgxMDAgYmluYXJ5KSwgLTIgYmVjb21lcyA1ICgxMDEgYmluYXJ5KVxuICovXG5mdW5jdGlvbiB0b1ZMUVNpZ25lZChhVmFsdWUpIHtcbiAgcmV0dXJuIGFWYWx1ZSA8IDBcbiAgICA/ICgoLWFWYWx1ZSkgPDwgMSkgKyAxXG4gICAgOiAoYVZhbHVlIDw8IDEpICsgMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0byBhIHR3by1jb21wbGVtZW50IHZhbHVlIGZyb20gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICogICAyICgxMCBiaW5hcnkpIGJlY29tZXMgMSwgMyAoMTEgYmluYXJ5KSBiZWNvbWVzIC0xXG4gKiAgIDQgKDEwMCBiaW5hcnkpIGJlY29tZXMgMiwgNSAoMTAxIGJpbmFyeSkgYmVjb21lcyAtMlxuICovXG5mdW5jdGlvbiBmcm9tVkxRU2lnbmVkKGFWYWx1ZSkge1xuICB2YXIgaXNOZWdhdGl2ZSA9IChhVmFsdWUgJiAxKSA9PT0gMTtcbiAgdmFyIHNoaWZ0ZWQgPSBhVmFsdWUgPj4gMTtcbiAgcmV0dXJuIGlzTmVnYXRpdmVcbiAgICA/IC1zaGlmdGVkXG4gICAgOiBzaGlmdGVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGJhc2UgNjQgVkxRIGVuY29kZWQgdmFsdWUuXG4gKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2VuY29kZShhVmFsdWUpIHtcbiAgdmFyIGVuY29kZWQgPSBcIlwiO1xuICB2YXIgZGlnaXQ7XG5cbiAgdmFyIHZscSA9IHRvVkxRU2lnbmVkKGFWYWx1ZSk7XG5cbiAgZG8ge1xuICAgIGRpZ2l0ID0gdmxxICYgVkxRX0JBU0VfTUFTSztcbiAgICB2bHEgPj4+PSBWTFFfQkFTRV9TSElGVDtcbiAgICBpZiAodmxxID4gMCkge1xuICAgICAgLy8gVGhlcmUgYXJlIHN0aWxsIG1vcmUgZGlnaXRzIGluIHRoaXMgdmFsdWUsIHNvIHdlIG11c3QgbWFrZSBzdXJlIHRoZVxuICAgICAgLy8gY29udGludWF0aW9uIGJpdCBpcyBtYXJrZWQuXG4gICAgICBkaWdpdCB8PSBWTFFfQ09OVElOVUFUSU9OX0JJVDtcbiAgICB9XG4gICAgZW5jb2RlZCArPSBiYXNlNjQuZW5jb2RlKGRpZ2l0KTtcbiAgfSB3aGlsZSAodmxxID4gMCk7XG5cbiAgcmV0dXJuIGVuY29kZWQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgdGhlIG5leHQgYmFzZSA2NCBWTFEgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCByZXR1cm5zIHRoZVxuICogdmFsdWUgYW5kIHRoZSByZXN0IG9mIHRoZSBzdHJpbmcgdmlhIHRoZSBvdXQgcGFyYW1ldGVyLlxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9kZWNvZGUoYVN0ciwgYUluZGV4LCBhT3V0UGFyYW0pIHtcbiAgdmFyIHN0ckxlbiA9IGFTdHIubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gMDtcbiAgdmFyIHNoaWZ0ID0gMDtcbiAgdmFyIGNvbnRpbnVhdGlvbiwgZGlnaXQ7XG5cbiAgZG8ge1xuICAgIGlmIChhSW5kZXggPj0gc3RyTGVuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBtb3JlIGRpZ2l0cyBpbiBiYXNlIDY0IFZMUSB2YWx1ZS5cIik7XG4gICAgfVxuXG4gICAgZGlnaXQgPSBiYXNlNjQuZGVjb2RlKGFTdHIuY2hhckNvZGVBdChhSW5kZXgrKykpO1xuICAgIGlmIChkaWdpdCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGRpZ2l0OiBcIiArIGFTdHIuY2hhckF0KGFJbmRleCAtIDEpKTtcbiAgICB9XG5cbiAgICBjb250aW51YXRpb24gPSAhIShkaWdpdCAmIFZMUV9DT05USU5VQVRJT05fQklUKTtcbiAgICBkaWdpdCAmPSBWTFFfQkFTRV9NQVNLO1xuICAgIHJlc3VsdCA9IHJlc3VsdCArIChkaWdpdCA8PCBzaGlmdCk7XG4gICAgc2hpZnQgKz0gVkxRX0JBU0VfU0hJRlQ7XG4gIH0gd2hpbGUgKGNvbnRpbnVhdGlvbik7XG5cbiAgYU91dFBhcmFtLnZhbHVlID0gZnJvbVZMUVNpZ25lZChyZXN1bHQpO1xuICBhT3V0UGFyYW0ucmVzdCA9IGFJbmRleDtcbn07XG4iXSwibmFtZXMiOlsiYmFzZTY0IiwicmVxdWlyZSIsIlZMUV9CQVNFX1NISUZUIiwiVkxRX0JBU0UiLCJWTFFfQkFTRV9NQVNLIiwiVkxRX0NPTlRJTlVBVElPTl9CSVQiLCJ0b1ZMUVNpZ25lZCIsImFWYWx1ZSIsImZyb21WTFFTaWduZWQiLCJpc05lZ2F0aXZlIiwic2hpZnRlZCIsImV4cG9ydHMiLCJlbmNvZGUiLCJiYXNlNjRWTFFfZW5jb2RlIiwiZW5jb2RlZCIsImRpZ2l0IiwidmxxIiwiZGVjb2RlIiwiYmFzZTY0VkxRX2RlY29kZSIsImFTdHIiLCJhSW5kZXgiLCJhT3V0UGFyYW0iLCJzdHJMZW4iLCJsZW5ndGgiLCJyZXN1bHQiLCJzaGlmdCIsImNvbnRpbnVhdGlvbiIsIkVycm9yIiwiY2hhckNvZGVBdCIsImNoYXJBdCIsInZhbHVlIiwicmVzdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../source-map-js/lib/base64-vlq.js\n");

/***/ }),

/***/ "(action-browser)/../source-map-js/lib/base64.js":
/*!**************************************!*\
  !*** ../source-map-js/lib/base64.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var intToCharMap = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */ exports.encode = function(number) {\n    if (0 <= number && number < intToCharMap.length) {\n        return intToCharMap[number];\n    }\n    throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */ exports.decode = function(charCode) {\n    var bigA = 65; // 'A'\n    var bigZ = 90; // 'Z'\n    var littleA = 97; // 'a'\n    var littleZ = 122; // 'z'\n    var zero = 48; // '0'\n    var nine = 57; // '9'\n    var plus = 43; // '+'\n    var slash = 47; // '/'\n    var littleOffset = 26;\n    var numberOffset = 52;\n    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n    if (bigA <= charCode && charCode <= bigZ) {\n        return charCode - bigA;\n    }\n    // 26 - 51: abcdefghijklmnopqrstuvwxyz\n    if (littleA <= charCode && charCode <= littleZ) {\n        return charCode - littleA + littleOffset;\n    }\n    // 52 - 61: 0123456789\n    if (zero <= charCode && charCode <= nine) {\n        return charCode - zero + numberOffset;\n    }\n    // 62: +\n    if (charCode == plus) {\n        return 62;\n    }\n    // 63: /\n    if (charCode == slash) {\n        return 63;\n    }\n    // Invalid base64 digit.\n    return -1;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9zb3VyY2UtbWFwLWpzL2xpYi9iYXNlNjQuanMiLCJtYXBwaW5ncyI6IkFBQUEseUNBQXlDLEdBQ3pDOzs7O0NBSUMsR0FFRCxJQUFJQSxlQUFlLG1FQUFtRUMsS0FBSyxDQUFDO0FBRTVGOztDQUVDLEdBQ0RDLGNBQWMsR0FBRyxTQUFVRSxNQUFNO0lBQy9CLElBQUksS0FBS0EsVUFBVUEsU0FBU0osYUFBYUssTUFBTSxFQUFFO1FBQy9DLE9BQU9MLFlBQVksQ0FBQ0ksT0FBTztJQUM3QjtJQUNBLE1BQU0sSUFBSUUsVUFBVSwrQkFBK0JGO0FBQ3JEO0FBRUE7OztDQUdDLEdBQ0RGLGNBQWMsR0FBRyxTQUFVTSxRQUFRO0lBQ2pDLElBQUlDLE9BQU8sSUFBUSxNQUFNO0lBQ3pCLElBQUlDLE9BQU8sSUFBUSxNQUFNO0lBRXpCLElBQUlDLFVBQVUsSUFBSyxNQUFNO0lBQ3pCLElBQUlDLFVBQVUsS0FBSyxNQUFNO0lBRXpCLElBQUlDLE9BQU8sSUFBUSxNQUFNO0lBQ3pCLElBQUlDLE9BQU8sSUFBUSxNQUFNO0lBRXpCLElBQUlDLE9BQU8sSUFBUSxNQUFNO0lBQ3pCLElBQUlDLFFBQVEsSUFBTyxNQUFNO0lBRXpCLElBQUlDLGVBQWU7SUFDbkIsSUFBSUMsZUFBZTtJQUVuQixxQ0FBcUM7SUFDckMsSUFBSVQsUUFBUUQsWUFBWUEsWUFBWUUsTUFBTTtRQUN4QyxPQUFRRixXQUFXQztJQUNyQjtJQUVBLHNDQUFzQztJQUN0QyxJQUFJRSxXQUFXSCxZQUFZQSxZQUFZSSxTQUFTO1FBQzlDLE9BQVFKLFdBQVdHLFVBQVVNO0lBQy9CO0lBRUEsc0JBQXNCO0lBQ3RCLElBQUlKLFFBQVFMLFlBQVlBLFlBQVlNLE1BQU07UUFDeEMsT0FBUU4sV0FBV0ssT0FBT0s7SUFDNUI7SUFFQSxRQUFRO0lBQ1IsSUFBSVYsWUFBWU8sTUFBTTtRQUNwQixPQUFPO0lBQ1Q7SUFFQSxRQUFRO0lBQ1IsSUFBSVAsWUFBWVEsT0FBTztRQUNyQixPQUFPO0lBQ1Q7SUFFQSx3QkFBd0I7SUFDeEIsT0FBTyxDQUFDO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1lbWFpbC8uLi9zb3VyY2UtbWFwLWpzL2xpYi9iYXNlNjQuanM/NGYyZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBpbnRUb0NoYXJNYXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycuc3BsaXQoJycpO1xuXG4vKipcbiAqIEVuY29kZSBhbiBpbnRlZ2VyIGluIHRoZSByYW5nZSBvZiAwIHRvIDYzIHRvIGEgc2luZ2xlIGJhc2UgNjQgZGlnaXQuXG4gKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG51bWJlcikge1xuICBpZiAoMCA8PSBudW1iZXIgJiYgbnVtYmVyIDwgaW50VG9DaGFyTWFwLmxlbmd0aCkge1xuICAgIHJldHVybiBpbnRUb0NoYXJNYXBbbnVtYmVyXTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYzOiBcIiArIG51bWJlcik7XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHNpbmdsZSBiYXNlIDY0IGNoYXJhY3RlciBjb2RlIGRpZ2l0IHRvIGFuIGludGVnZXIuIFJldHVybnMgLTEgb25cbiAqIGZhaWx1cmUuXG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gIHZhciBiaWdBID0gNjU7ICAgICAvLyAnQSdcbiAgdmFyIGJpZ1ogPSA5MDsgICAgIC8vICdaJ1xuXG4gIHZhciBsaXR0bGVBID0gOTc7ICAvLyAnYSdcbiAgdmFyIGxpdHRsZVogPSAxMjI7IC8vICd6J1xuXG4gIHZhciB6ZXJvID0gNDg7ICAgICAvLyAnMCdcbiAgdmFyIG5pbmUgPSA1NzsgICAgIC8vICc5J1xuXG4gIHZhciBwbHVzID0gNDM7ICAgICAvLyAnKydcbiAgdmFyIHNsYXNoID0gNDc7ICAgIC8vICcvJ1xuXG4gIHZhciBsaXR0bGVPZmZzZXQgPSAyNjtcbiAgdmFyIG51bWJlck9mZnNldCA9IDUyO1xuXG4gIC8vIDAgLSAyNTogQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcbiAgaWYgKGJpZ0EgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gYmlnWikge1xuICAgIHJldHVybiAoY2hhckNvZGUgLSBiaWdBKTtcbiAgfVxuXG4gIC8vIDI2IC0gNTE6IGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XG4gIGlmIChsaXR0bGVBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGxpdHRsZVopIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gbGl0dGxlQSArIGxpdHRsZU9mZnNldCk7XG4gIH1cblxuICAvLyA1MiAtIDYxOiAwMTIzNDU2Nzg5XG4gIGlmICh6ZXJvIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IG5pbmUpIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gemVybyArIG51bWJlck9mZnNldCk7XG4gIH1cblxuICAvLyA2MjogK1xuICBpZiAoY2hhckNvZGUgPT0gcGx1cykge1xuICAgIHJldHVybiA2MjtcbiAgfVxuXG4gIC8vIDYzOiAvXG4gIGlmIChjaGFyQ29kZSA9PSBzbGFzaCkge1xuICAgIHJldHVybiA2MztcbiAgfVxuXG4gIC8vIEludmFsaWQgYmFzZTY0IGRpZ2l0LlxuICByZXR1cm4gLTE7XG59O1xuIl0sIm5hbWVzIjpbImludFRvQ2hhck1hcCIsInNwbGl0IiwiZXhwb3J0cyIsImVuY29kZSIsIm51bWJlciIsImxlbmd0aCIsIlR5cGVFcnJvciIsImRlY29kZSIsImNoYXJDb2RlIiwiYmlnQSIsImJpZ1oiLCJsaXR0bGVBIiwibGl0dGxlWiIsInplcm8iLCJuaW5lIiwicGx1cyIsInNsYXNoIiwibGl0dGxlT2Zmc2V0IiwibnVtYmVyT2Zmc2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../source-map-js/lib/base64.js\n");

/***/ }),

/***/ "(rsc)/../source-map-js/lib/base64.js":
/*!**************************************!*\
  !*** ../source-map-js/lib/base64.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var intToCharMap = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */ exports.encode = function(number) {\n    if (0 <= number && number < intToCharMap.length) {\n        return intToCharMap[number];\n    }\n    throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */ exports.decode = function(charCode) {\n    var bigA = 65; // 'A'\n    var bigZ = 90; // 'Z'\n    var littleA = 97; // 'a'\n    var littleZ = 122; // 'z'\n    var zero = 48; // '0'\n    var nine = 57; // '9'\n    var plus = 43; // '+'\n    var slash = 47; // '/'\n    var littleOffset = 26;\n    var numberOffset = 52;\n    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n    if (bigA <= charCode && charCode <= bigZ) {\n        return charCode - bigA;\n    }\n    // 26 - 51: abcdefghijklmnopqrstuvwxyz\n    if (littleA <= charCode && charCode <= littleZ) {\n        return charCode - littleA + littleOffset;\n    }\n    // 52 - 61: 0123456789\n    if (zero <= charCode && charCode <= nine) {\n        return charCode - zero + numberOffset;\n    }\n    // 62: +\n    if (charCode == plus) {\n        return 62;\n    }\n    // 63: /\n    if (charCode == slash) {\n        return 63;\n    }\n    // Invalid base64 digit.\n    return -1;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vc291cmNlLW1hcC1qcy9saWIvYmFzZTY0LmpzIiwibWFwcGluZ3MiOiJBQUFBLHlDQUF5QyxHQUN6Qzs7OztDQUlDLEdBRUQsSUFBSUEsZUFBZSxtRUFBbUVDLEtBQUssQ0FBQztBQUU1Rjs7Q0FFQyxHQUNEQyxjQUFjLEdBQUcsU0FBVUUsTUFBTTtJQUMvQixJQUFJLEtBQUtBLFVBQVVBLFNBQVNKLGFBQWFLLE1BQU0sRUFBRTtRQUMvQyxPQUFPTCxZQUFZLENBQUNJLE9BQU87SUFDN0I7SUFDQSxNQUFNLElBQUlFLFVBQVUsK0JBQStCRjtBQUNyRDtBQUVBOzs7Q0FHQyxHQUNERixjQUFjLEdBQUcsU0FBVU0sUUFBUTtJQUNqQyxJQUFJQyxPQUFPLElBQVEsTUFBTTtJQUN6QixJQUFJQyxPQUFPLElBQVEsTUFBTTtJQUV6QixJQUFJQyxVQUFVLElBQUssTUFBTTtJQUN6QixJQUFJQyxVQUFVLEtBQUssTUFBTTtJQUV6QixJQUFJQyxPQUFPLElBQVEsTUFBTTtJQUN6QixJQUFJQyxPQUFPLElBQVEsTUFBTTtJQUV6QixJQUFJQyxPQUFPLElBQVEsTUFBTTtJQUN6QixJQUFJQyxRQUFRLElBQU8sTUFBTTtJQUV6QixJQUFJQyxlQUFlO0lBQ25CLElBQUlDLGVBQWU7SUFFbkIscUNBQXFDO0lBQ3JDLElBQUlULFFBQVFELFlBQVlBLFlBQVlFLE1BQU07UUFDeEMsT0FBUUYsV0FBV0M7SUFDckI7SUFFQSxzQ0FBc0M7SUFDdEMsSUFBSUUsV0FBV0gsWUFBWUEsWUFBWUksU0FBUztRQUM5QyxPQUFRSixXQUFXRyxVQUFVTTtJQUMvQjtJQUVBLHNCQUFzQjtJQUN0QixJQUFJSixRQUFRTCxZQUFZQSxZQUFZTSxNQUFNO1FBQ3hDLE9BQVFOLFdBQVdLLE9BQU9LO0lBQzVCO0lBRUEsUUFBUTtJQUNSLElBQUlWLFlBQVlPLE1BQU07UUFDcEIsT0FBTztJQUNUO0lBRUEsUUFBUTtJQUNSLElBQUlQLFlBQVlRLE9BQU87UUFDckIsT0FBTztJQUNUO0lBRUEsd0JBQXdCO0lBQ3hCLE9BQU8sQ0FBQztBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtZW1haWwvLi4vc291cmNlLW1hcC1qcy9saWIvYmFzZTY0LmpzPzRmMmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgaW50VG9DaGFyTWFwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLnNwbGl0KCcnKTtcblxuLyoqXG4gKiBFbmNvZGUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2YgMCB0byA2MyB0byBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0LlxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgaWYgKDAgPD0gbnVtYmVyICYmIG51bWJlciA8IGludFRvQ2hhck1hcC5sZW5ndGgpIHtcbiAgICByZXR1cm4gaW50VG9DaGFyTWFwW251bWJlcl07XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk11c3QgYmUgYmV0d2VlbiAwIGFuZCA2MzogXCIgKyBudW1iZXIpO1xufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBzaW5nbGUgYmFzZSA2NCBjaGFyYWN0ZXIgY29kZSBkaWdpdCB0byBhbiBpbnRlZ2VyLiBSZXR1cm5zIC0xIG9uXG4gKiBmYWlsdXJlLlxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICB2YXIgYmlnQSA9IDY1OyAgICAgLy8gJ0EnXG4gIHZhciBiaWdaID0gOTA7ICAgICAvLyAnWidcblxuICB2YXIgbGl0dGxlQSA9IDk3OyAgLy8gJ2EnXG4gIHZhciBsaXR0bGVaID0gMTIyOyAvLyAneidcblxuICB2YXIgemVybyA9IDQ4OyAgICAgLy8gJzAnXG4gIHZhciBuaW5lID0gNTc7ICAgICAvLyAnOSdcblxuICB2YXIgcGx1cyA9IDQzOyAgICAgLy8gJysnXG4gIHZhciBzbGFzaCA9IDQ3OyAgICAvLyAnLydcblxuICB2YXIgbGl0dGxlT2Zmc2V0ID0gMjY7XG4gIHZhciBudW1iZXJPZmZzZXQgPSA1MjtcblxuICAvLyAwIC0gMjU6IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXG4gIGlmIChiaWdBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGJpZ1opIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gYmlnQSk7XG4gIH1cblxuICAvLyAyNiAtIDUxOiBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elxuICBpZiAobGl0dGxlQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBsaXR0bGVaKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIGxpdHRsZUEgKyBsaXR0bGVPZmZzZXQpO1xuICB9XG5cbiAgLy8gNTIgLSA2MTogMDEyMzQ1Njc4OVxuICBpZiAoemVybyA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBuaW5lKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIHplcm8gKyBudW1iZXJPZmZzZXQpO1xuICB9XG5cbiAgLy8gNjI6ICtcbiAgaWYgKGNoYXJDb2RlID09IHBsdXMpIHtcbiAgICByZXR1cm4gNjI7XG4gIH1cblxuICAvLyA2MzogL1xuICBpZiAoY2hhckNvZGUgPT0gc2xhc2gpIHtcbiAgICByZXR1cm4gNjM7XG4gIH1cblxuICAvLyBJbnZhbGlkIGJhc2U2NCBkaWdpdC5cbiAgcmV0dXJuIC0xO1xufTtcbiJdLCJuYW1lcyI6WyJpbnRUb0NoYXJNYXAiLCJzcGxpdCIsImV4cG9ydHMiLCJlbmNvZGUiLCJudW1iZXIiLCJsZW5ndGgiLCJUeXBlRXJyb3IiLCJkZWNvZGUiLCJjaGFyQ29kZSIsImJpZ0EiLCJiaWdaIiwibGl0dGxlQSIsImxpdHRsZVoiLCJ6ZXJvIiwibmluZSIsInBsdXMiLCJzbGFzaCIsImxpdHRsZU9mZnNldCIsIm51bWJlck9mZnNldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../source-map-js/lib/base64.js\n");

/***/ }),

/***/ "(action-browser)/../source-map-js/lib/binary-search.js":
/*!*********************************************!*\
  !*** ../source-map-js/lib/binary-search.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ exports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */ function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n    // This function terminates when one of the following is true:\n    //\n    //   1. We find the exact element we are looking for.\n    //\n    //   2. We did not find the exact element, but we can return the index of\n    //      the next-closest element.\n    //\n    //   3. We did not find the exact element, and there is no next-closest\n    //      element than the one we are searching for, so we return -1.\n    var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n    var cmp = aCompare(aNeedle, aHaystack[mid], true);\n    if (cmp === 0) {\n        // Found the element we are looking for.\n        return mid;\n    } else if (cmp > 0) {\n        // Our needle is greater than aHaystack[mid].\n        if (aHigh - mid > 1) {\n            // The element is in the upper half.\n            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n        }\n        // The exact needle element was not found in this haystack. Determine if\n        // we are in termination case (3) or (2) and return the appropriate thing.\n        if (aBias == exports.LEAST_UPPER_BOUND) {\n            return aHigh < aHaystack.length ? aHigh : -1;\n        } else {\n            return mid;\n        }\n    } else {\n        // Our needle is less than aHaystack[mid].\n        if (mid - aLow > 1) {\n            // The element is in the lower half.\n            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n        }\n        // we are in termination case (3) or (2) and return the appropriate thing.\n        if (aBias == exports.LEAST_UPPER_BOUND) {\n            return mid;\n        } else {\n            return aLow < 0 ? -1 : aLow;\n        }\n    }\n}\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */ exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n    if (aHaystack.length === 0) {\n        return -1;\n    }\n    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n    if (index < 0) {\n        return -1;\n    }\n    // We have found either the exact element, or the next-closest element than\n    // the one we are searching for. However, there may be more than one such\n    // element. Make sure we always return the smallest of these.\n    while(index - 1 >= 0){\n        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n            break;\n        }\n        --index;\n    }\n    return index;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9zb3VyY2UtbWFwLWpzL2xpYi9iaW5hcnktc2VhcmNoLmpzIiwibWFwcGluZ3MiOiJBQUFBLHlDQUF5QyxHQUN6Qzs7OztDQUlDLEdBRURBLDRCQUE0QixHQUFHO0FBQy9CQSx5QkFBeUIsR0FBRztBQUU1Qjs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRCxTQUFTRyxnQkFBZ0JDLElBQUksRUFBRUMsS0FBSyxFQUFFQyxPQUFPLEVBQUVDLFNBQVMsRUFBRUMsUUFBUSxFQUFFQyxLQUFLO0lBQ3ZFLDhEQUE4RDtJQUM5RCxFQUFFO0lBQ0YscURBQXFEO0lBQ3JELEVBQUU7SUFDRix5RUFBeUU7SUFDekUsaUNBQWlDO0lBQ2pDLEVBQUU7SUFDRix1RUFBdUU7SUFDdkUsbUVBQW1FO0lBQ25FLElBQUlDLE1BQU1DLEtBQUtDLEtBQUssQ0FBQyxDQUFDUCxRQUFRRCxJQUFHLElBQUssS0FBS0E7SUFDM0MsSUFBSVMsTUFBTUwsU0FBU0YsU0FBU0MsU0FBUyxDQUFDRyxJQUFJLEVBQUU7SUFDNUMsSUFBSUcsUUFBUSxHQUFHO1FBQ2Isd0NBQXdDO1FBQ3hDLE9BQU9IO0lBQ1QsT0FDSyxJQUFJRyxNQUFNLEdBQUc7UUFDaEIsNkNBQTZDO1FBQzdDLElBQUlSLFFBQVFLLE1BQU0sR0FBRztZQUNuQixvQ0FBb0M7WUFDcEMsT0FBT1AsZ0JBQWdCTyxLQUFLTCxPQUFPQyxTQUFTQyxXQUFXQyxVQUFVQztRQUNuRTtRQUVBLHdFQUF3RTtRQUN4RSwwRUFBMEU7UUFDMUUsSUFBSUEsU0FBU1QsUUFBUUUsaUJBQWlCLEVBQUU7WUFDdEMsT0FBT0csUUFBUUUsVUFBVU8sTUFBTSxHQUFHVCxRQUFRLENBQUM7UUFDN0MsT0FBTztZQUNMLE9BQU9LO1FBQ1Q7SUFDRixPQUNLO1FBQ0gsMENBQTBDO1FBQzFDLElBQUlBLE1BQU1OLE9BQU8sR0FBRztZQUNsQixvQ0FBb0M7WUFDcEMsT0FBT0QsZ0JBQWdCQyxNQUFNTSxLQUFLSixTQUFTQyxXQUFXQyxVQUFVQztRQUNsRTtRQUVBLDBFQUEwRTtRQUMxRSxJQUFJQSxTQUFTVCxRQUFRRSxpQkFBaUIsRUFBRTtZQUN0QyxPQUFPUTtRQUNULE9BQU87WUFDTCxPQUFPTixPQUFPLElBQUksQ0FBQyxJQUFJQTtRQUN6QjtJQUNGO0FBQ0Y7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDREosY0FBYyxHQUFHLFNBQVNlLE9BQU9ULE9BQU8sRUFBRUMsU0FBUyxFQUFFQyxRQUFRLEVBQUVDLEtBQUs7SUFDbEUsSUFBSUYsVUFBVU8sTUFBTSxLQUFLLEdBQUc7UUFDMUIsT0FBTyxDQUFDO0lBQ1Y7SUFFQSxJQUFJRSxRQUFRYixnQkFBZ0IsQ0FBQyxHQUFHSSxVQUFVTyxNQUFNLEVBQUVSLFNBQVNDLFdBQy9CQyxVQUFVQyxTQUFTVCxRQUFRQyxvQkFBb0I7SUFDM0UsSUFBSWUsUUFBUSxHQUFHO1FBQ2IsT0FBTyxDQUFDO0lBQ1Y7SUFFQSwyRUFBMkU7SUFDM0UseUVBQXlFO0lBQ3pFLDZEQUE2RDtJQUM3RCxNQUFPQSxRQUFRLEtBQUssRUFBRztRQUNyQixJQUFJUixTQUFTRCxTQUFTLENBQUNTLE1BQU0sRUFBRVQsU0FBUyxDQUFDUyxRQUFRLEVBQUUsRUFBRSxVQUFVLEdBQUc7WUFDaEU7UUFDRjtRQUNBLEVBQUVBO0lBQ0o7SUFFQSxPQUFPQTtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtZW1haWwvLi4vc291cmNlLW1hcC1qcy9saWIvYmluYXJ5LXNlYXJjaC5qcz9iOTM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5leHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuLyoqXG4gKiBSZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaC5cbiAqXG4gKiBAcGFyYW0gYUxvdyBJbmRpY2VzIGhlcmUgYW5kIGxvd2VyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYUhpZ2ggSW5kaWNlcyBoZXJlIGFuZCBoaWdoZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IGJlaW5nIHNlYXJjaGVkIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIG5vbi1lbXB0eSBhcnJheSBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBhQ29tcGFyZSBGdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gZWxlbWVudHMgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEuXG4gKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ2JpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiB0ZXJtaW5hdGVzIHdoZW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZTpcbiAgLy9cbiAgLy8gICAxLiBXZSBmaW5kIHRoZSBleGFjdCBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgLy9cbiAgLy8gICAyLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGJ1dCB3ZSBjYW4gcmV0dXJuIHRoZSBpbmRleCBvZlxuICAvLyAgICAgIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudC5cbiAgLy9cbiAgLy8gICAzLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGFuZCB0aGVyZSBpcyBubyBuZXh0LWNsb3Nlc3RcbiAgLy8gICAgICBlbGVtZW50IHRoYW4gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgc28gd2UgcmV0dXJuIC0xLlxuICB2YXIgbWlkID0gTWF0aC5mbG9vcigoYUhpZ2ggLSBhTG93KSAvIDIpICsgYUxvdztcbiAgdmFyIGNtcCA9IGFDb21wYXJlKGFOZWVkbGUsIGFIYXlzdGFja1ttaWRdLCB0cnVlKTtcbiAgaWYgKGNtcCA9PT0gMCkge1xuICAgIC8vIEZvdW5kIHRoZSBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgICByZXR1cm4gbWlkO1xuICB9XG4gIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAvLyBPdXIgbmVlZGxlIGlzIGdyZWF0ZXIgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICBpZiAoYUhpZ2ggLSBtaWQgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2gobWlkLCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpO1xuICAgIH1cblxuICAgIC8vIFRoZSBleGFjdCBuZWVkbGUgZWxlbWVudCB3YXMgbm90IGZvdW5kIGluIHRoaXMgaGF5c3RhY2suIERldGVybWluZSBpZlxuICAgIC8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgzKSBvciAoMikgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuXG4gICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgIHJldHVybiBhSGlnaCA8IGFIYXlzdGFjay5sZW5ndGggPyBhSGlnaCA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBPdXIgbmVlZGxlIGlzIGxlc3MgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICBpZiAobWlkIC0gYUxvdyA+IDEpIHtcbiAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSBsb3dlciBoYWxmLlxuICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBtaWQsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYUxvdyA8IDAgPyAtMSA6IGFMb3c7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoIHdoaWNoIHdpbGwgYWx3YXlzIHRyeSBhbmQgcmV0dXJuXG4gKiB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgZWxlbWVudCBpZiB0aGVyZSBpcyBubyBleGFjdCBoaXQuIFRoaXMgaXMgYmVjYXVzZVxuICogbWFwcGluZ3MgYmV0d2VlbiBvcmlnaW5hbCBhbmQgZ2VuZXJhdGVkIGxpbmUvY29sIHBhaXJzIGFyZSBzaW5nbGUgcG9pbnRzLFxuICogYW5kIHRoZXJlIGlzIGFuIGltcGxpY2l0IHJlZ2lvbiBiZXR3ZWVuIGVhY2ggb2YgdGhlbSwgc28gYSBtaXNzIGp1c3QgbWVhbnNcbiAqIHRoYXQgeW91IGFyZW4ndCBvbiB0aGUgdmVyeSBzdGFydCBvZiBhIHJlZ2lvbi5cbiAqXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCB5b3UgYXJlIGxvb2tpbmcgZm9yLlxuICogQHBhcmFtIGFIYXlzdGFjayBUaGUgYXJyYXkgdGhhdCBpcyBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBhQ29tcGFyZSBBIGZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBuZWVkbGUgYW5kIGFuIGVsZW1lbnQgaW4gdGhlXG4gKiAgICAgYXJyYXkgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIG5lZWRsZSBpcyBsZXNzXG4gKiAgICAgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiB0aGUgZWxlbWVudCwgcmVzcGVjdGl2ZWx5LlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICovXG5leHBvcnRzLnNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcykge1xuICBpZiAoYUhheXN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHZhciBpbmRleCA9IHJlY3Vyc2l2ZVNlYXJjaCgtMSwgYUhheXN0YWNrLmxlbmd0aCwgYU5lZWRsZSwgYUhheXN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbXBhcmUsIGFCaWFzIHx8IGV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLy8gV2UgaGF2ZSBmb3VuZCBlaXRoZXIgdGhlIGV4YWN0IGVsZW1lbnQsIG9yIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudCB0aGFuXG4gIC8vIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuIEhvd2V2ZXIsIHRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIHN1Y2hcbiAgLy8gZWxlbWVudC4gTWFrZSBzdXJlIHdlIGFsd2F5cyByZXR1cm4gdGhlIHNtYWxsZXN0IG9mIHRoZXNlLlxuICB3aGlsZSAoaW5kZXggLSAxID49IDApIHtcbiAgICBpZiAoYUNvbXBhcmUoYUhheXN0YWNrW2luZGV4XSwgYUhheXN0YWNrW2luZGV4IC0gMV0sIHRydWUpICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLS1pbmRleDtcbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn07XG4iXSwibmFtZXMiOlsiZXhwb3J0cyIsIkdSRUFURVNUX0xPV0VSX0JPVU5EIiwiTEVBU1RfVVBQRVJfQk9VTkQiLCJyZWN1cnNpdmVTZWFyY2giLCJhTG93IiwiYUhpZ2giLCJhTmVlZGxlIiwiYUhheXN0YWNrIiwiYUNvbXBhcmUiLCJhQmlhcyIsIm1pZCIsIk1hdGgiLCJmbG9vciIsImNtcCIsImxlbmd0aCIsInNlYXJjaCIsImluZGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../source-map-js/lib/binary-search.js\n");

/***/ }),

/***/ "(rsc)/../source-map-js/lib/binary-search.js":
/*!*********************************************!*\
  !*** ../source-map-js/lib/binary-search.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ exports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */ function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n    // This function terminates when one of the following is true:\n    //\n    //   1. We find the exact element we are looking for.\n    //\n    //   2. We did not find the exact element, but we can return the index of\n    //      the next-closest element.\n    //\n    //   3. We did not find the exact element, and there is no next-closest\n    //      element than the one we are searching for, so we return -1.\n    var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n    var cmp = aCompare(aNeedle, aHaystack[mid], true);\n    if (cmp === 0) {\n        // Found the element we are looking for.\n        return mid;\n    } else if (cmp > 0) {\n        // Our needle is greater than aHaystack[mid].\n        if (aHigh - mid > 1) {\n            // The element is in the upper half.\n            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n        }\n        // The exact needle element was not found in this haystack. Determine if\n        // we are in termination case (3) or (2) and return the appropriate thing.\n        if (aBias == exports.LEAST_UPPER_BOUND) {\n            return aHigh < aHaystack.length ? aHigh : -1;\n        } else {\n            return mid;\n        }\n    } else {\n        // Our needle is less than aHaystack[mid].\n        if (mid - aLow > 1) {\n            // The element is in the lower half.\n            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n        }\n        // we are in termination case (3) or (2) and return the appropriate thing.\n        if (aBias == exports.LEAST_UPPER_BOUND) {\n            return mid;\n        } else {\n            return aLow < 0 ? -1 : aLow;\n        }\n    }\n}\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */ exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n    if (aHaystack.length === 0) {\n        return -1;\n    }\n    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n    if (index < 0) {\n        return -1;\n    }\n    // We have found either the exact element, or the next-closest element than\n    // the one we are searching for. However, there may be more than one such\n    // element. Make sure we always return the smallest of these.\n    while(index - 1 >= 0){\n        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n            break;\n        }\n        --index;\n    }\n    return index;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vc291cmNlLW1hcC1qcy9saWIvYmluYXJ5LXNlYXJjaC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5Q0FBeUMsR0FDekM7Ozs7Q0FJQyxHQUVEQSw0QkFBNEIsR0FBRztBQUMvQkEseUJBQXlCLEdBQUc7QUFFNUI7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0QsU0FBU0csZ0JBQWdCQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsT0FBTyxFQUFFQyxTQUFTLEVBQUVDLFFBQVEsRUFBRUMsS0FBSztJQUN2RSw4REFBOEQ7SUFDOUQsRUFBRTtJQUNGLHFEQUFxRDtJQUNyRCxFQUFFO0lBQ0YseUVBQXlFO0lBQ3pFLGlDQUFpQztJQUNqQyxFQUFFO0lBQ0YsdUVBQXVFO0lBQ3ZFLG1FQUFtRTtJQUNuRSxJQUFJQyxNQUFNQyxLQUFLQyxLQUFLLENBQUMsQ0FBQ1AsUUFBUUQsSUFBRyxJQUFLLEtBQUtBO0lBQzNDLElBQUlTLE1BQU1MLFNBQVNGLFNBQVNDLFNBQVMsQ0FBQ0csSUFBSSxFQUFFO0lBQzVDLElBQUlHLFFBQVEsR0FBRztRQUNiLHdDQUF3QztRQUN4QyxPQUFPSDtJQUNULE9BQ0ssSUFBSUcsTUFBTSxHQUFHO1FBQ2hCLDZDQUE2QztRQUM3QyxJQUFJUixRQUFRSyxNQUFNLEdBQUc7WUFDbkIsb0NBQW9DO1lBQ3BDLE9BQU9QLGdCQUFnQk8sS0FBS0wsT0FBT0MsU0FBU0MsV0FBV0MsVUFBVUM7UUFDbkU7UUFFQSx3RUFBd0U7UUFDeEUsMEVBQTBFO1FBQzFFLElBQUlBLFNBQVNULFFBQVFFLGlCQUFpQixFQUFFO1lBQ3RDLE9BQU9HLFFBQVFFLFVBQVVPLE1BQU0sR0FBR1QsUUFBUSxDQUFDO1FBQzdDLE9BQU87WUFDTCxPQUFPSztRQUNUO0lBQ0YsT0FDSztRQUNILDBDQUEwQztRQUMxQyxJQUFJQSxNQUFNTixPQUFPLEdBQUc7WUFDbEIsb0NBQW9DO1lBQ3BDLE9BQU9ELGdCQUFnQkMsTUFBTU0sS0FBS0osU0FBU0MsV0FBV0MsVUFBVUM7UUFDbEU7UUFFQSwwRUFBMEU7UUFDMUUsSUFBSUEsU0FBU1QsUUFBUUUsaUJBQWlCLEVBQUU7WUFDdEMsT0FBT1E7UUFDVCxPQUFPO1lBQ0wsT0FBT04sT0FBTyxJQUFJLENBQUMsSUFBSUE7UUFDekI7SUFDRjtBQUNGO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ0RKLGNBQWMsR0FBRyxTQUFTZSxPQUFPVCxPQUFPLEVBQUVDLFNBQVMsRUFBRUMsUUFBUSxFQUFFQyxLQUFLO0lBQ2xFLElBQUlGLFVBQVVPLE1BQU0sS0FBSyxHQUFHO1FBQzFCLE9BQU8sQ0FBQztJQUNWO0lBRUEsSUFBSUUsUUFBUWIsZ0JBQWdCLENBQUMsR0FBR0ksVUFBVU8sTUFBTSxFQUFFUixTQUFTQyxXQUMvQkMsVUFBVUMsU0FBU1QsUUFBUUMsb0JBQW9CO0lBQzNFLElBQUllLFFBQVEsR0FBRztRQUNiLE9BQU8sQ0FBQztJQUNWO0lBRUEsMkVBQTJFO0lBQzNFLHlFQUF5RTtJQUN6RSw2REFBNkQ7SUFDN0QsTUFBT0EsUUFBUSxLQUFLLEVBQUc7UUFDckIsSUFBSVIsU0FBU0QsU0FBUyxDQUFDUyxNQUFNLEVBQUVULFNBQVMsQ0FBQ1MsUUFBUSxFQUFFLEVBQUUsVUFBVSxHQUFHO1lBQ2hFO1FBQ0Y7UUFDQSxFQUFFQTtJQUNKO0lBRUEsT0FBT0E7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWVtYWlsLy4uL3NvdXJjZS1tYXAtanMvbGliL2JpbmFyeS1zZWFyY2guanM/YjkzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbmV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2guXG4gKlxuICogQHBhcmFtIGFMb3cgSW5kaWNlcyBoZXJlIGFuZCBsb3dlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICogQHBhcmFtIGFIaWdoIEluZGljZXMgaGVyZSBhbmQgaGlnaGVyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCBiZWluZyBzZWFyY2hlZCBmb3IuXG4gKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBub24tZW1wdHkgYXJyYXkgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGVsZW1lbnRzIGFuZCByZXR1cm5zIC0xLCAwLCBvciAxLlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICovXG5mdW5jdGlvbiByZWN1cnNpdmVTZWFyY2goYUxvdywgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gdGVybWluYXRlcyB3aGVuIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gIC8vXG4gIC8vICAgMS4gV2UgZmluZCB0aGUgZXhhY3QgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gIC8vXG4gIC8vICAgMi4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBidXQgd2UgY2FuIHJldHVybiB0aGUgaW5kZXggb2ZcbiAgLy8gICAgICB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQuXG4gIC8vXG4gIC8vICAgMy4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBhbmQgdGhlcmUgaXMgbm8gbmV4dC1jbG9zZXN0XG4gIC8vICAgICAgZWxlbWVudCB0aGFuIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IsIHNvIHdlIHJldHVybiAtMS5cbiAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGFIaWdoIC0gYUxvdykgLyAyKSArIGFMb3c7XG4gIHZhciBjbXAgPSBhQ29tcGFyZShhTmVlZGxlLCBhSGF5c3RhY2tbbWlkXSwgdHJ1ZSk7XG4gIGlmIChjbXAgPT09IDApIHtcbiAgICAvLyBGb3VuZCB0aGUgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgcmV0dXJuIG1pZDtcbiAgfVxuICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBncmVhdGVyIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKGFIaWdoIC0gbWlkID4gMSkge1xuICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKG1pZCwgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgZXhhY3QgbmVlZGxlIGVsZW1lbnQgd2FzIG5vdCBmb3VuZCBpbiB0aGlzIGhheXN0YWNrLiBEZXRlcm1pbmUgaWZcbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gYUhpZ2ggPCBhSGF5c3RhY2subGVuZ3RoID8gYUhpZ2ggOiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBsZXNzIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKG1pZCAtIGFMb3cgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgbG93ZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2goYUxvdywgbWlkLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgfVxuXG4gICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFMb3cgPCAwID8gLTEgOiBhTG93O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaCB3aGljaCB3aWxsIGFsd2F5cyB0cnkgYW5kIHJldHVyblxuICogdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IGVsZW1lbnQgaWYgdGhlcmUgaXMgbm8gZXhhY3QgaGl0LiBUaGlzIGlzIGJlY2F1c2VcbiAqIG1hcHBpbmdzIGJldHdlZW4gb3JpZ2luYWwgYW5kIGdlbmVyYXRlZCBsaW5lL2NvbCBwYWlycyBhcmUgc2luZ2xlIHBvaW50cyxcbiAqIGFuZCB0aGVyZSBpcyBhbiBpbXBsaWNpdCByZWdpb24gYmV0d2VlbiBlYWNoIG9mIHRoZW0sIHNvIGEgbWlzcyBqdXN0IG1lYW5zXG4gKiB0aGF0IHlvdSBhcmVuJ3Qgb24gdGhlIHZlcnkgc3RhcnQgb2YgYSByZWdpb24uXG4gKlxuICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgeW91IGFyZSBsb29raW5nIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIGFycmF5IHRoYXQgaXMgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgbmVlZGxlIGFuZCBhbiBlbGVtZW50IGluIHRoZVxuICogICAgIGFycmF5IGFuZCByZXR1cm5zIC0xLCAwLCBvciAxIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBuZWVkbGUgaXMgbGVzc1xuICogICAgIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIGVsZW1lbnQsIHJlc3BlY3RpdmVseS5cbiAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqL1xuZXhwb3J0cy5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgaWYgKGFIYXlzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICB2YXIgaW5kZXggPSByZWN1cnNpdmVTZWFyY2goLTEsIGFIYXlzdGFjay5sZW5ndGgsIGFOZWVkbGUsIGFIYXlzdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb21wYXJlLCBhQmlhcyB8fCBleHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EKTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8vIFdlIGhhdmUgZm91bmQgZWl0aGVyIHRoZSBleGFjdCBlbGVtZW50LCBvciB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQgdGhhblxuICAvLyB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLiBIb3dldmVyLCB0aGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBzdWNoXG4gIC8vIGVsZW1lbnQuIE1ha2Ugc3VyZSB3ZSBhbHdheXMgcmV0dXJuIHRoZSBzbWFsbGVzdCBvZiB0aGVzZS5cbiAgd2hpbGUgKGluZGV4IC0gMSA+PSAwKSB7XG4gICAgaWYgKGFDb21wYXJlKGFIYXlzdGFja1tpbmRleF0sIGFIYXlzdGFja1tpbmRleCAtIDFdLCB0cnVlKSAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC0taW5kZXg7XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59O1xuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJHUkVBVEVTVF9MT1dFUl9CT1VORCIsIkxFQVNUX1VQUEVSX0JPVU5EIiwicmVjdXJzaXZlU2VhcmNoIiwiYUxvdyIsImFIaWdoIiwiYU5lZWRsZSIsImFIYXlzdGFjayIsImFDb21wYXJlIiwiYUJpYXMiLCJtaWQiLCJNYXRoIiwiZmxvb3IiLCJjbXAiLCJsZW5ndGgiLCJzZWFyY2giLCJpbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../source-map-js/lib/binary-search.js\n");

/***/ }),

/***/ "(action-browser)/../source-map-js/lib/mapping-list.js":
/*!********************************************!*\
  !*** ../source-map-js/lib/mapping-list.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var util = __webpack_require__(/*! ./util */ \"(action-browser)/../source-map-js/lib/util.js\");\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */ function generatedPositionAfter(mappingA, mappingB) {\n    // Optimized for most common case\n    var lineA = mappingA.generatedLine;\n    var lineB = mappingB.generatedLine;\n    var columnA = mappingA.generatedColumn;\n    var columnB = mappingB.generatedColumn;\n    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */ function MappingList() {\n    this._array = [];\n    this._sorted = true;\n    // Serves as infimum\n    this._last = {\n        generatedLine: -1,\n        generatedColumn: 0\n    };\n}\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */ MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n};\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */ MappingList.prototype.add = function MappingList_add(aMapping) {\n    if (generatedPositionAfter(this._last, aMapping)) {\n        this._last = aMapping;\n        this._array.push(aMapping);\n    } else {\n        this._sorted = false;\n        this._array.push(aMapping);\n    }\n};\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */ MappingList.prototype.toArray = function MappingList_toArray() {\n    if (!this._sorted) {\n        this._array.sort(util.compareByGeneratedPositionsInflated);\n        this._sorted = true;\n    }\n    return this._array;\n};\nexports.MappingList = MappingList;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9zb3VyY2UtbWFwLWpzL2xpYi9tYXBwaW5nLWxpc3QuanMiLCJtYXBwaW5ncyI6IkFBQUEseUNBQXlDLEdBQ3pDOzs7O0NBSUMsR0FFRCxJQUFJQSxPQUFPQyxtQkFBT0EsQ0FBQztBQUVuQjs7O0NBR0MsR0FDRCxTQUFTQyx1QkFBdUJDLFFBQVEsRUFBRUMsUUFBUTtJQUNoRCxpQ0FBaUM7SUFDakMsSUFBSUMsUUFBUUYsU0FBU0csYUFBYTtJQUNsQyxJQUFJQyxRQUFRSCxTQUFTRSxhQUFhO0lBQ2xDLElBQUlFLFVBQVVMLFNBQVNNLGVBQWU7SUFDdEMsSUFBSUMsVUFBVU4sU0FBU0ssZUFBZTtJQUN0QyxPQUFPRixRQUFRRixTQUFTRSxTQUFTRixTQUFTSyxXQUFXRixXQUM5Q1IsS0FBS1csbUNBQW1DLENBQUNSLFVBQVVDLGFBQWE7QUFDekU7QUFFQTs7OztDQUlDLEdBQ0QsU0FBU1E7SUFDUCxJQUFJLENBQUNDLE1BQU0sR0FBRyxFQUFFO0lBQ2hCLElBQUksQ0FBQ0MsT0FBTyxHQUFHO0lBQ2Ysb0JBQW9CO0lBQ3BCLElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBQUNULGVBQWUsQ0FBQztRQUFHRyxpQkFBaUI7SUFBQztBQUNyRDtBQUVBOzs7OztDQUtDLEdBQ0RHLFlBQVlJLFNBQVMsQ0FBQ0MsZUFBZSxHQUNuQyxTQUFTQyxvQkFBb0JDLFNBQVMsRUFBRUMsUUFBUTtJQUM5QyxJQUFJLENBQUNQLE1BQU0sQ0FBQ1EsT0FBTyxDQUFDRixXQUFXQztBQUNqQztBQUVGOzs7O0NBSUMsR0FDRFIsWUFBWUksU0FBUyxDQUFDTSxHQUFHLEdBQUcsU0FBU0MsZ0JBQWdCQyxRQUFRO0lBQzNELElBQUl0Qix1QkFBdUIsSUFBSSxDQUFDYSxLQUFLLEVBQUVTLFdBQVc7UUFDaEQsSUFBSSxDQUFDVCxLQUFLLEdBQUdTO1FBQ2IsSUFBSSxDQUFDWCxNQUFNLENBQUNZLElBQUksQ0FBQ0Q7SUFDbkIsT0FBTztRQUNMLElBQUksQ0FBQ1YsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDRCxNQUFNLENBQUNZLElBQUksQ0FBQ0Q7SUFDbkI7QUFDRjtBQUVBOzs7Ozs7OztDQVFDLEdBQ0RaLFlBQVlJLFNBQVMsQ0FBQ1UsT0FBTyxHQUFHLFNBQVNDO0lBQ3ZDLElBQUksQ0FBQyxJQUFJLENBQUNiLE9BQU8sRUFBRTtRQUNqQixJQUFJLENBQUNELE1BQU0sQ0FBQ2UsSUFBSSxDQUFDNUIsS0FBS1csbUNBQW1DO1FBQ3pELElBQUksQ0FBQ0csT0FBTyxHQUFHO0lBQ2pCO0lBQ0EsT0FBTyxJQUFJLENBQUNELE1BQU07QUFDcEI7QUFFQWdCLG1CQUFtQixHQUFHakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1lbWFpbC8uLi9zb3VyY2UtbWFwLWpzL2xpYi9tYXBwaW5nLWxpc3QuanM/Njc5MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTQgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgbWFwcGluZ0IgaXMgYWZ0ZXIgbWFwcGluZ0Egd2l0aCByZXNwZWN0IHRvIGdlbmVyYXRlZFxuICogcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIC8vIE9wdGltaXplZCBmb3IgbW9zdCBjb21tb24gY2FzZVxuICB2YXIgbGluZUEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgbGluZUIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgY29sdW1uQSA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbjtcbiAgdmFyIGNvbHVtbkIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIHJldHVybiBsaW5lQiA+IGxpbmVBIHx8IGxpbmVCID09IGxpbmVBICYmIGNvbHVtbkIgPj0gY29sdW1uQSB8fFxuICAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIDw9IDA7XG59XG5cbi8qKlxuICogQSBkYXRhIHN0cnVjdHVyZSB0byBwcm92aWRlIGEgc29ydGVkIHZpZXcgb2YgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gYVxuICogcGVyZm9ybWFuY2UgY29uc2Npb3VzIG1hbm5lci4gSXQgdHJhZGVzIGEgbmVnbGliYWJsZSBvdmVyaGVhZCBpbiBnZW5lcmFsXG4gKiBjYXNlIGZvciBhIGxhcmdlIHNwZWVkdXAgaW4gY2FzZSBvZiBtYXBwaW5ncyBiZWluZyBhZGRlZCBpbiBvcmRlci5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZ0xpc3QoKSB7XG4gIHRoaXMuX2FycmF5ID0gW107XG4gIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gIC8vIFNlcnZlcyBhcyBpbmZpbXVtXG4gIHRoaXMuX2xhc3QgPSB7Z2VuZXJhdGVkTGluZTogLTEsIGdlbmVyYXRlZENvbHVtbjogMH07XG59XG5cbi8qKlxuICogSXRlcmF0ZSB0aHJvdWdoIGludGVybmFsIGl0ZW1zLiBUaGlzIG1ldGhvZCB0YWtlcyB0aGUgc2FtZSBhcmd1bWVudHMgdGhhdFxuICogYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCB0YWtlcy5cbiAqXG4gKiBOT1RFOiBUaGUgb3JkZXIgb2YgdGhlIG1hcHBpbmdzIGlzIE5PVCBndWFyYW50ZWVkLlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudW5zb3J0ZWRGb3JFYWNoID1cbiAgZnVuY3Rpb24gTWFwcGluZ0xpc3RfZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKSB7XG4gICAgdGhpcy5fYXJyYXkuZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKTtcbiAgfTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHNvdXJjZSBtYXBwaW5nLlxuICpcbiAqIEBwYXJhbSBPYmplY3QgYU1hcHBpbmdcbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2FkZChhTWFwcGluZykge1xuICBpZiAoZ2VuZXJhdGVkUG9zaXRpb25BZnRlcih0aGlzLl9sYXN0LCBhTWFwcGluZykpIHtcbiAgICB0aGlzLl9sYXN0ID0gYU1hcHBpbmc7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmxhdCwgc29ydGVkIGFycmF5IG9mIG1hcHBpbmdzLiBUaGUgbWFwcGluZ3MgYXJlIHNvcnRlZCBieVxuICogZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICpcbiAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHJldHVybnMgaW50ZXJuYWwgZGF0YSB3aXRob3V0IGNvcHlpbmcsIGZvclxuICogcGVyZm9ybWFuY2UuIFRoZSByZXR1cm4gdmFsdWUgbXVzdCBOT1QgYmUgbXV0YXRlZCwgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzXG4gKiBhbiBpbW11dGFibGUgYm9ycm93LiBJZiB5b3Ugd2FudCB0byB0YWtlIG93bmVyc2hpcCwgeW91IG11c3QgbWFrZSB5b3VyIG93blxuICogY29weS5cbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF90b0FycmF5KCkge1xuICBpZiAoIXRoaXMuX3NvcnRlZCkge1xuICAgIHRoaXMuX2FycmF5LnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCk7XG4gICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXk7XG59O1xuXG5leHBvcnRzLk1hcHBpbmdMaXN0ID0gTWFwcGluZ0xpc3Q7XG4iXSwibmFtZXMiOlsidXRpbCIsInJlcXVpcmUiLCJnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyIiwibWFwcGluZ0EiLCJtYXBwaW5nQiIsImxpbmVBIiwiZ2VuZXJhdGVkTGluZSIsImxpbmVCIiwiY29sdW1uQSIsImdlbmVyYXRlZENvbHVtbiIsImNvbHVtbkIiLCJjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCIsIk1hcHBpbmdMaXN0IiwiX2FycmF5IiwiX3NvcnRlZCIsIl9sYXN0IiwicHJvdG90eXBlIiwidW5zb3J0ZWRGb3JFYWNoIiwiTWFwcGluZ0xpc3RfZm9yRWFjaCIsImFDYWxsYmFjayIsImFUaGlzQXJnIiwiZm9yRWFjaCIsImFkZCIsIk1hcHBpbmdMaXN0X2FkZCIsImFNYXBwaW5nIiwicHVzaCIsInRvQXJyYXkiLCJNYXBwaW5nTGlzdF90b0FycmF5Iiwic29ydCIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../source-map-js/lib/mapping-list.js\n");

/***/ }),

/***/ "(rsc)/../source-map-js/lib/mapping-list.js":
/*!********************************************!*\
  !*** ../source-map-js/lib/mapping-list.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var util = __webpack_require__(/*! ./util */ \"(rsc)/../source-map-js/lib/util.js\");\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */ function generatedPositionAfter(mappingA, mappingB) {\n    // Optimized for most common case\n    var lineA = mappingA.generatedLine;\n    var lineB = mappingB.generatedLine;\n    var columnA = mappingA.generatedColumn;\n    var columnB = mappingB.generatedColumn;\n    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */ function MappingList() {\n    this._array = [];\n    this._sorted = true;\n    // Serves as infimum\n    this._last = {\n        generatedLine: -1,\n        generatedColumn: 0\n    };\n}\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */ MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n};\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */ MappingList.prototype.add = function MappingList_add(aMapping) {\n    if (generatedPositionAfter(this._last, aMapping)) {\n        this._last = aMapping;\n        this._array.push(aMapping);\n    } else {\n        this._sorted = false;\n        this._array.push(aMapping);\n    }\n};\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */ MappingList.prototype.toArray = function MappingList_toArray() {\n    if (!this._sorted) {\n        this._array.sort(util.compareByGeneratedPositionsInflated);\n        this._sorted = true;\n    }\n    return this._array;\n};\nexports.MappingList = MappingList;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vc291cmNlLW1hcC1qcy9saWIvbWFwcGluZy1saXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBLHlDQUF5QyxHQUN6Qzs7OztDQUlDLEdBRUQsSUFBSUEsT0FBT0MsbUJBQU9BLENBQUM7QUFFbkI7OztDQUdDLEdBQ0QsU0FBU0MsdUJBQXVCQyxRQUFRLEVBQUVDLFFBQVE7SUFDaEQsaUNBQWlDO0lBQ2pDLElBQUlDLFFBQVFGLFNBQVNHLGFBQWE7SUFDbEMsSUFBSUMsUUFBUUgsU0FBU0UsYUFBYTtJQUNsQyxJQUFJRSxVQUFVTCxTQUFTTSxlQUFlO0lBQ3RDLElBQUlDLFVBQVVOLFNBQVNLLGVBQWU7SUFDdEMsT0FBT0YsUUFBUUYsU0FBU0UsU0FBU0YsU0FBU0ssV0FBV0YsV0FDOUNSLEtBQUtXLG1DQUFtQyxDQUFDUixVQUFVQyxhQUFhO0FBQ3pFO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNRO0lBQ1AsSUFBSSxDQUFDQyxNQUFNLEdBQUcsRUFBRTtJQUNoQixJQUFJLENBQUNDLE9BQU8sR0FBRztJQUNmLG9CQUFvQjtJQUNwQixJQUFJLENBQUNDLEtBQUssR0FBRztRQUFDVCxlQUFlLENBQUM7UUFBR0csaUJBQWlCO0lBQUM7QUFDckQ7QUFFQTs7Ozs7Q0FLQyxHQUNERyxZQUFZSSxTQUFTLENBQUNDLGVBQWUsR0FDbkMsU0FBU0Msb0JBQW9CQyxTQUFTLEVBQUVDLFFBQVE7SUFDOUMsSUFBSSxDQUFDUCxNQUFNLENBQUNRLE9BQU8sQ0FBQ0YsV0FBV0M7QUFDakM7QUFFRjs7OztDQUlDLEdBQ0RSLFlBQVlJLFNBQVMsQ0FBQ00sR0FBRyxHQUFHLFNBQVNDLGdCQUFnQkMsUUFBUTtJQUMzRCxJQUFJdEIsdUJBQXVCLElBQUksQ0FBQ2EsS0FBSyxFQUFFUyxXQUFXO1FBQ2hELElBQUksQ0FBQ1QsS0FBSyxHQUFHUztRQUNiLElBQUksQ0FBQ1gsTUFBTSxDQUFDWSxJQUFJLENBQUNEO0lBQ25CLE9BQU87UUFDTCxJQUFJLENBQUNWLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0QsTUFBTSxDQUFDWSxJQUFJLENBQUNEO0lBQ25CO0FBQ0Y7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNEWixZQUFZSSxTQUFTLENBQUNVLE9BQU8sR0FBRyxTQUFTQztJQUN2QyxJQUFJLENBQUMsSUFBSSxDQUFDYixPQUFPLEVBQUU7UUFDakIsSUFBSSxDQUFDRCxNQUFNLENBQUNlLElBQUksQ0FBQzVCLEtBQUtXLG1DQUFtQztRQUN6RCxJQUFJLENBQUNHLE9BQU8sR0FBRztJQUNqQjtJQUNBLE9BQU8sSUFBSSxDQUFDRCxNQUFNO0FBQ3BCO0FBRUFnQixtQkFBbUIsR0FBR2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtZW1haWwvLi4vc291cmNlLW1hcC1qcy9saWIvbWFwcGluZy1saXN0LmpzPzY3OTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDE0IE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIG1hcHBpbmdCIGlzIGFmdGVyIG1hcHBpbmdBIHdpdGggcmVzcGVjdCB0byBnZW5lcmF0ZWRcbiAqIHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICAvLyBPcHRpbWl6ZWQgZm9yIG1vc3QgY29tbW9uIGNhc2VcbiAgdmFyIGxpbmVBID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZTtcbiAgdmFyIGxpbmVCID0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgdmFyIGNvbHVtbkEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW47XG4gIHZhciBjb2x1bW5CID0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICByZXR1cm4gbGluZUIgPiBsaW5lQSB8fCBsaW5lQiA9PSBsaW5lQSAmJiBjb2x1bW5CID49IGNvbHVtbkEgfHxcbiAgICAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCKSA8PSAwO1xufVxuXG4vKipcbiAqIEEgZGF0YSBzdHJ1Y3R1cmUgdG8gcHJvdmlkZSBhIHNvcnRlZCB2aWV3IG9mIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIGFcbiAqIHBlcmZvcm1hbmNlIGNvbnNjaW91cyBtYW5uZXIuIEl0IHRyYWRlcyBhIG5lZ2xpYmFibGUgb3ZlcmhlYWQgaW4gZ2VuZXJhbFxuICogY2FzZSBmb3IgYSBsYXJnZSBzcGVlZHVwIGluIGNhc2Ugb2YgbWFwcGluZ3MgYmVpbmcgYWRkZWQgaW4gb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIE1hcHBpbmdMaXN0KCkge1xuICB0aGlzLl9hcnJheSA9IFtdO1xuICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICAvLyBTZXJ2ZXMgYXMgaW5maW11bVxuICB0aGlzLl9sYXN0ID0ge2dlbmVyYXRlZExpbmU6IC0xLCBnZW5lcmF0ZWRDb2x1bW46IDB9O1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgdGhyb3VnaCBpbnRlcm5hbCBpdGVtcy4gVGhpcyBtZXRob2QgdGFrZXMgdGhlIHNhbWUgYXJndW1lbnRzIHRoYXRcbiAqIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgdGFrZXMuXG4gKlxuICogTk9URTogVGhlIG9yZGVyIG9mIHRoZSBtYXBwaW5ncyBpcyBOT1QgZ3VhcmFudGVlZC5cbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLnVuc29ydGVkRm9yRWFjaCA9XG4gIGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2ZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZykge1xuICAgIHRoaXMuX2FycmF5LmZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZyk7XG4gIH07XG5cbi8qKlxuICogQWRkIHRoZSBnaXZlbiBzb3VyY2UgbWFwcGluZy5cbiAqXG4gKiBAcGFyYW0gT2JqZWN0IGFNYXBwaW5nXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF9hZGQoYU1hcHBpbmcpIHtcbiAgaWYgKGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIodGhpcy5fbGFzdCwgYU1hcHBpbmcpKSB7XG4gICAgdGhpcy5fbGFzdCA9IGFNYXBwaW5nO1xuICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZsYXQsIHNvcnRlZCBhcnJheSBvZiBtYXBwaW5ncy4gVGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQgYnlcbiAqIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAqXG4gKiBXQVJOSU5HOiBUaGlzIG1ldGhvZCByZXR1cm5zIGludGVybmFsIGRhdGEgd2l0aG91dCBjb3B5aW5nLCBmb3JcbiAqIHBlcmZvcm1hbmNlLiBUaGUgcmV0dXJuIHZhbHVlIG11c3QgTk9UIGJlIG11dGF0ZWQsIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhc1xuICogYW4gaW1tdXRhYmxlIGJvcnJvdy4gSWYgeW91IHdhbnQgdG8gdGFrZSBvd25lcnNoaXAsIHlvdSBtdXN0IG1ha2UgeW91ciBvd25cbiAqIGNvcHkuXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfdG9BcnJheSgpIHtcbiAgaWYgKCF0aGlzLl9zb3J0ZWQpIHtcbiAgICB0aGlzLl9hcnJheS5zb3J0KHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQpO1xuICAgIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5O1xufTtcblxuZXhwb3J0cy5NYXBwaW5nTGlzdCA9IE1hcHBpbmdMaXN0O1xuIl0sIm5hbWVzIjpbInV0aWwiLCJyZXF1aXJlIiwiZ2VuZXJhdGVkUG9zaXRpb25BZnRlciIsIm1hcHBpbmdBIiwibWFwcGluZ0IiLCJsaW5lQSIsImdlbmVyYXRlZExpbmUiLCJsaW5lQiIsImNvbHVtbkEiLCJnZW5lcmF0ZWRDb2x1bW4iLCJjb2x1bW5CIiwiY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQiLCJNYXBwaW5nTGlzdCIsIl9hcnJheSIsIl9zb3J0ZWQiLCJfbGFzdCIsInByb3RvdHlwZSIsInVuc29ydGVkRm9yRWFjaCIsIk1hcHBpbmdMaXN0X2ZvckVhY2giLCJhQ2FsbGJhY2siLCJhVGhpc0FyZyIsImZvckVhY2giLCJhZGQiLCJNYXBwaW5nTGlzdF9hZGQiLCJhTWFwcGluZyIsInB1c2giLCJ0b0FycmF5IiwiTWFwcGluZ0xpc3RfdG9BcnJheSIsInNvcnQiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../source-map-js/lib/mapping-list.js\n");

/***/ }),

/***/ "(action-browser)/../source-map-js/lib/quick-sort.js":
/*!******************************************!*\
  !*** ../source-map-js/lib/quick-sort.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ // It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\nfunction SortTemplate(comparator) {\n    /**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */ function swap(ary, x, y) {\n        var temp = ary[x];\n        ary[x] = ary[y];\n        ary[y] = temp;\n    }\n    /**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */ function randomIntInRange(low, high) {\n        return Math.round(low + Math.random() * (high - low));\n    }\n    /**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */ function doQuickSort(ary, comparator, p, r) {\n        // If our lower bound is less than our upper bound, we (1) partition the\n        // array into two pieces and (2) recurse on each half. If it is not, this is\n        // the empty array and our base case.\n        if (p < r) {\n            // (1) Partitioning.\n            //\n            // The partitioning chooses a pivot between `p` and `r` and moves all\n            // elements that are less than or equal to the pivot to the before it, and\n            // all the elements that are greater than it after it. The effect is that\n            // once partition is done, the pivot is in the exact place it will be when\n            // the array is put in sorted order, and it will not need to be moved\n            // again. This runs in O(n) time.\n            // Always choose a random pivot so that an input array which is reverse\n            // sorted does not cause O(n^2) running time.\n            var pivotIndex = randomIntInRange(p, r);\n            var i = p - 1;\n            swap(ary, pivotIndex, r);\n            var pivot = ary[r];\n            // Immediately after `j` is incremented in this loop, the following hold\n            // true:\n            //\n            //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n            //\n            //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n            for(var j = p; j < r; j++){\n                if (comparator(ary[j], pivot, false) <= 0) {\n                    i += 1;\n                    swap(ary, i, j);\n                }\n            }\n            swap(ary, i + 1, j);\n            var q = i + 1;\n            // (2) Recurse on each half.\n            doQuickSort(ary, comparator, p, q - 1);\n            doQuickSort(ary, comparator, q + 1, r);\n        }\n    }\n    return doQuickSort;\n}\nfunction cloneSort(comparator) {\n    let template = SortTemplate.toString();\n    let templateFn = new Function(`return ${template}`)();\n    return templateFn(comparator);\n}\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */ let sortCache = new WeakMap();\nexports.quickSort = function(ary, comparator, start = 0) {\n    let doQuickSort = sortCache.get(comparator);\n    if (doQuickSort === void 0) {\n        doQuickSort = cloneSort(comparator);\n        sortCache.set(comparator, doQuickSort);\n    }\n    doQuickSort(ary, comparator, start, ary.length - 1);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9zb3VyY2UtbWFwLWpzL2xpYi9xdWljay1zb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFBLHlDQUF5QyxHQUN6Qzs7OztDQUlDLEdBRUQsb0VBQW9FO0FBQ3BFLDBFQUEwRTtBQUMxRSw2RUFBNkU7QUFDN0UsOEVBQThFO0FBQzlFLHlFQUF5RTtBQUN6RSw2RUFBNkU7QUFDN0UsNkVBQTZFO0FBQzdFLDZFQUE2RTtBQUM3RSxpREFBaUQ7QUFFakQsU0FBU0EsYUFBYUMsVUFBVTtJQUVoQzs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTQyxLQUFLQyxHQUFHLEVBQUVDLENBQUMsRUFBRUMsQ0FBQztRQUNyQixJQUFJQyxPQUFPSCxHQUFHLENBQUNDLEVBQUU7UUFDakJELEdBQUcsQ0FBQ0MsRUFBRSxHQUFHRCxHQUFHLENBQUNFLEVBQUU7UUFDZkYsR0FBRyxDQUFDRSxFQUFFLEdBQUdDO0lBQ1g7SUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU0MsaUJBQWlCQyxHQUFHLEVBQUVDLElBQUk7UUFDakMsT0FBT0MsS0FBS0MsS0FBSyxDQUFDSCxNQUFPRSxLQUFLRSxNQUFNLEtBQU1ILENBQUFBLE9BQU9ELEdBQUU7SUFDckQ7SUFFQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELFNBQVNLLFlBQVlWLEdBQUcsRUFBRUYsVUFBVSxFQUFFYSxDQUFDLEVBQUVDLENBQUM7UUFDeEMsd0VBQXdFO1FBQ3hFLDRFQUE0RTtRQUM1RSxxQ0FBcUM7UUFFckMsSUFBSUQsSUFBSUMsR0FBRztZQUNULG9CQUFvQjtZQUNwQixFQUFFO1lBQ0YscUVBQXFFO1lBQ3JFLDBFQUEwRTtZQUMxRSx5RUFBeUU7WUFDekUsMEVBQTBFO1lBQzFFLHFFQUFxRTtZQUNyRSxpQ0FBaUM7WUFFakMsdUVBQXVFO1lBQ3ZFLDZDQUE2QztZQUM3QyxJQUFJQyxhQUFhVCxpQkFBaUJPLEdBQUdDO1lBQ3JDLElBQUlFLElBQUlILElBQUk7WUFFWlosS0FBS0MsS0FBS2EsWUFBWUQ7WUFDdEIsSUFBSUcsUUFBUWYsR0FBRyxDQUFDWSxFQUFFO1lBRWxCLHdFQUF3RTtZQUN4RSxRQUFRO1lBQ1IsRUFBRTtZQUNGLHlFQUF5RTtZQUN6RSxFQUFFO1lBQ0Ysb0VBQW9FO1lBQ3BFLElBQUssSUFBSUksSUFBSUwsR0FBR0ssSUFBSUosR0FBR0ksSUFBSztnQkFDMUIsSUFBSWxCLFdBQVdFLEdBQUcsQ0FBQ2dCLEVBQUUsRUFBRUQsT0FBTyxVQUFVLEdBQUc7b0JBQ3pDRCxLQUFLO29CQUNMZixLQUFLQyxLQUFLYyxHQUFHRTtnQkFDZjtZQUNGO1lBRUFqQixLQUFLQyxLQUFLYyxJQUFJLEdBQUdFO1lBQ2pCLElBQUlDLElBQUlILElBQUk7WUFFWiw0QkFBNEI7WUFFNUJKLFlBQVlWLEtBQUtGLFlBQVlhLEdBQUdNLElBQUk7WUFDcENQLFlBQVlWLEtBQUtGLFlBQVltQixJQUFJLEdBQUdMO1FBQ3RDO0lBQ0Y7SUFFRSxPQUFPRjtBQUNUO0FBRUEsU0FBU1EsVUFBVXBCLFVBQVU7SUFDM0IsSUFBSXFCLFdBQVd0QixhQUFhdUIsUUFBUTtJQUNwQyxJQUFJQyxhQUFhLElBQUlDLFNBQVMsQ0FBQyxPQUFPLEVBQUVILFNBQVMsQ0FBQztJQUNsRCxPQUFPRSxXQUFXdkI7QUFDcEI7QUFFQTs7Ozs7OztDQU9DLEdBRUQsSUFBSXlCLFlBQVksSUFBSUM7QUFDcEJDLGlCQUFpQixHQUFHLFNBQVV6QixHQUFHLEVBQUVGLFVBQVUsRUFBRTZCLFFBQVEsQ0FBQztJQUN0RCxJQUFJakIsY0FBY2EsVUFBVUssR0FBRyxDQUFDOUI7SUFDaEMsSUFBSVksZ0JBQWdCLEtBQUssR0FBRztRQUMxQkEsY0FBY1EsVUFBVXBCO1FBQ3hCeUIsVUFBVU0sR0FBRyxDQUFDL0IsWUFBWVk7SUFDNUI7SUFDQUEsWUFBWVYsS0FBS0YsWUFBWTZCLE9BQU8zQixJQUFJOEIsTUFBTSxHQUFHO0FBQ25EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtZW1haWwvLi4vc291cmNlLW1hcC1qcy9saWIvcXVpY2stc29ydC5qcz9hNWI4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuLy8gSXQgdHVybnMgb3V0IHRoYXQgc29tZSAobW9zdD8pIEphdmFTY3JpcHQgZW5naW5lcyBkb24ndCBzZWxmLWhvc3Rcbi8vIGBBcnJheS5wcm90b3R5cGUuc29ydGAuIFRoaXMgbWFrZXMgc2Vuc2UgYmVjYXVzZSBDKysgd2lsbCBsaWtlbHkgcmVtYWluXG4vLyBmYXN0ZXIgdGhhbiBKUyB3aGVuIGRvaW5nIHJhdyBDUFUtaW50ZW5zaXZlIHNvcnRpbmcuIEhvd2V2ZXIsIHdoZW4gdXNpbmcgYVxuLy8gY3VzdG9tIGNvbXBhcmF0b3IgZnVuY3Rpb24sIGNhbGxpbmcgYmFjayBhbmQgZm9ydGggYmV0d2VlbiB0aGUgVk0ncyBDKysgYW5kXG4vLyBKSVQnZCBKUyBpcyByYXRoZXIgc2xvdyAqYW5kKiBsb3NlcyBKSVQgdHlwZSBpbmZvcm1hdGlvbiwgcmVzdWx0aW5nIGluXG4vLyB3b3JzZSBnZW5lcmF0ZWQgY29kZSBmb3IgdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24gdGhhbiB3b3VsZCBiZSBvcHRpbWFsLiBJblxuLy8gZmFjdCwgd2hlbiBzb3J0aW5nIHdpdGggYSBjb21wYXJhdG9yLCB0aGVzZSBjb3N0cyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgb2Zcbi8vIHNvcnRpbmcgaW4gQysrLiBCeSB1c2luZyBvdXIgb3duIEpTLWltcGxlbWVudGVkIFF1aWNrIFNvcnQgKGJlbG93KSwgd2UgZ2V0XG4vLyBhIH4zNTAwbXMgbWVhbiBzcGVlZC11cCBpbiBgYmVuY2gvYmVuY2guaHRtbGAuXG5cbmZ1bmN0aW9uIFNvcnRUZW1wbGF0ZShjb21wYXJhdG9yKSB7XG5cbi8qKlxuICogU3dhcCB0aGUgZWxlbWVudHMgaW5kZXhlZCBieSBgeGAgYW5kIGB5YCBpbiB0aGUgYXJyYXkgYGFyeWAuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgVGhlIGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0uXG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgc2Vjb25kIGl0ZW0uXG4gKi9cbmZ1bmN0aW9uIHN3YXAoYXJ5LCB4LCB5KSB7XG4gIHZhciB0ZW1wID0gYXJ5W3hdO1xuICBhcnlbeF0gPSBhcnlbeV07XG4gIGFyeVt5XSA9IHRlbXA7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIHdpdGhpbiB0aGUgcmFuZ2UgYGxvdyAuLiBoaWdoYCBpbmNsdXNpdmUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGxvd1xuICogICAgICAgIFRoZSBsb3dlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge051bWJlcn0gaGlnaFxuICogICAgICAgIFRoZSB1cHBlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUludEluUmFuZ2UobG93LCBoaWdoKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKGxvdyArIChNYXRoLnJhbmRvbSgpICogKGhpZ2ggLSBsb3cpKSk7XG59XG5cbi8qKlxuICogVGhlIFF1aWNrIFNvcnQgYWxnb3JpdGhtLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICogQHBhcmFtIHtOdW1iZXJ9IHBcbiAqICAgICAgICBTdGFydCBpbmRleCBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSByXG4gKiAgICAgICAgRW5kIGluZGV4IG9mIHRoZSBhcnJheVxuICovXG5mdW5jdGlvbiBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHIpIHtcbiAgLy8gSWYgb3VyIGxvd2VyIGJvdW5kIGlzIGxlc3MgdGhhbiBvdXIgdXBwZXIgYm91bmQsIHdlICgxKSBwYXJ0aXRpb24gdGhlXG4gIC8vIGFycmF5IGludG8gdHdvIHBpZWNlcyBhbmQgKDIpIHJlY3Vyc2Ugb24gZWFjaCBoYWxmLiBJZiBpdCBpcyBub3QsIHRoaXMgaXNcbiAgLy8gdGhlIGVtcHR5IGFycmF5IGFuZCBvdXIgYmFzZSBjYXNlLlxuXG4gIGlmIChwIDwgcikge1xuICAgIC8vICgxKSBQYXJ0aXRpb25pbmcuXG4gICAgLy9cbiAgICAvLyBUaGUgcGFydGl0aW9uaW5nIGNob29zZXMgYSBwaXZvdCBiZXR3ZWVuIGBwYCBhbmQgYHJgIGFuZCBtb3ZlcyBhbGxcbiAgICAvLyBlbGVtZW50cyB0aGF0IGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90IHRvIHRoZSBiZWZvcmUgaXQsIGFuZFxuICAgIC8vIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBhcmUgZ3JlYXRlciB0aGFuIGl0IGFmdGVyIGl0LiBUaGUgZWZmZWN0IGlzIHRoYXRcbiAgICAvLyBvbmNlIHBhcnRpdGlvbiBpcyBkb25lLCB0aGUgcGl2b3QgaXMgaW4gdGhlIGV4YWN0IHBsYWNlIGl0IHdpbGwgYmUgd2hlblxuICAgIC8vIHRoZSBhcnJheSBpcyBwdXQgaW4gc29ydGVkIG9yZGVyLCBhbmQgaXQgd2lsbCBub3QgbmVlZCB0byBiZSBtb3ZlZFxuICAgIC8vIGFnYWluLiBUaGlzIHJ1bnMgaW4gTyhuKSB0aW1lLlxuXG4gICAgLy8gQWx3YXlzIGNob29zZSBhIHJhbmRvbSBwaXZvdCBzbyB0aGF0IGFuIGlucHV0IGFycmF5IHdoaWNoIGlzIHJldmVyc2VcbiAgICAvLyBzb3J0ZWQgZG9lcyBub3QgY2F1c2UgTyhuXjIpIHJ1bm5pbmcgdGltZS5cbiAgICB2YXIgcGl2b3RJbmRleCA9IHJhbmRvbUludEluUmFuZ2UocCwgcik7XG4gICAgdmFyIGkgPSBwIC0gMTtcblxuICAgIHN3YXAoYXJ5LCBwaXZvdEluZGV4LCByKTtcbiAgICB2YXIgcGl2b3QgPSBhcnlbcl07XG5cbiAgICAvLyBJbW1lZGlhdGVseSBhZnRlciBgamAgaXMgaW5jcmVtZW50ZWQgaW4gdGhpcyBsb29wLCB0aGUgZm9sbG93aW5nIGhvbGRcbiAgICAvLyB0cnVlOlxuICAgIC8vXG4gICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtwIC4uIGldYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90LlxuICAgIC8vXG4gICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtpKzEgLi4gai0xXWAgaXMgZ3JlYXRlciB0aGFuIHRoZSBwaXZvdC5cbiAgICBmb3IgKHZhciBqID0gcDsgaiA8IHI7IGorKykge1xuICAgICAgaWYgKGNvbXBhcmF0b3IoYXJ5W2pdLCBwaXZvdCwgZmFsc2UpIDw9IDApIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgICBzd2FwKGFyeSwgaSwgaik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dhcChhcnksIGkgKyAxLCBqKTtcbiAgICB2YXIgcSA9IGkgKyAxO1xuXG4gICAgLy8gKDIpIFJlY3Vyc2Ugb24gZWFjaCBoYWxmLlxuXG4gICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCBxIC0gMSk7XG4gICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBxICsgMSwgcik7XG4gIH1cbn1cblxuICByZXR1cm4gZG9RdWlja1NvcnQ7XG59XG5cbmZ1bmN0aW9uIGNsb25lU29ydChjb21wYXJhdG9yKSB7XG4gIGxldCB0ZW1wbGF0ZSA9IFNvcnRUZW1wbGF0ZS50b1N0cmluZygpO1xuICBsZXQgdGVtcGxhdGVGbiA9IG5ldyBGdW5jdGlvbihgcmV0dXJuICR7dGVtcGxhdGV9YCkoKTtcbiAgcmV0dXJuIHRlbXBsYXRlRm4oY29tcGFyYXRvcik7XG59XG5cbi8qKlxuICogU29ydCB0aGUgZ2l2ZW4gYXJyYXkgaW4tcGxhY2Ugd2l0aCB0aGUgZ2l2ZW4gY29tcGFyYXRvciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAqL1xuXG5sZXQgc29ydENhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydHMucXVpY2tTb3J0ID0gZnVuY3Rpb24gKGFyeSwgY29tcGFyYXRvciwgc3RhcnQgPSAwKSB7XG4gIGxldCBkb1F1aWNrU29ydCA9IHNvcnRDYWNoZS5nZXQoY29tcGFyYXRvcik7XG4gIGlmIChkb1F1aWNrU29ydCA9PT0gdm9pZCAwKSB7XG4gICAgZG9RdWlja1NvcnQgPSBjbG9uZVNvcnQoY29tcGFyYXRvcik7XG4gICAgc29ydENhY2hlLnNldChjb21wYXJhdG9yLCBkb1F1aWNrU29ydCk7XG4gIH1cbiAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBzdGFydCwgYXJ5Lmxlbmd0aCAtIDEpO1xufTtcbiJdLCJuYW1lcyI6WyJTb3J0VGVtcGxhdGUiLCJjb21wYXJhdG9yIiwic3dhcCIsImFyeSIsIngiLCJ5IiwidGVtcCIsInJhbmRvbUludEluUmFuZ2UiLCJsb3ciLCJoaWdoIiwiTWF0aCIsInJvdW5kIiwicmFuZG9tIiwiZG9RdWlja1NvcnQiLCJwIiwiciIsInBpdm90SW5kZXgiLCJpIiwicGl2b3QiLCJqIiwicSIsImNsb25lU29ydCIsInRlbXBsYXRlIiwidG9TdHJpbmciLCJ0ZW1wbGF0ZUZuIiwiRnVuY3Rpb24iLCJzb3J0Q2FjaGUiLCJXZWFrTWFwIiwiZXhwb3J0cyIsInF1aWNrU29ydCIsInN0YXJ0IiwiZ2V0Iiwic2V0IiwibGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../source-map-js/lib/quick-sort.js\n");

/***/ }),

/***/ "(rsc)/../source-map-js/lib/quick-sort.js":
/*!******************************************!*\
  !*** ../source-map-js/lib/quick-sort.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ // It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\nfunction SortTemplate(comparator) {\n    /**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */ function swap(ary, x, y) {\n        var temp = ary[x];\n        ary[x] = ary[y];\n        ary[y] = temp;\n    }\n    /**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */ function randomIntInRange(low, high) {\n        return Math.round(low + Math.random() * (high - low));\n    }\n    /**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */ function doQuickSort(ary, comparator, p, r) {\n        // If our lower bound is less than our upper bound, we (1) partition the\n        // array into two pieces and (2) recurse on each half. If it is not, this is\n        // the empty array and our base case.\n        if (p < r) {\n            // (1) Partitioning.\n            //\n            // The partitioning chooses a pivot between `p` and `r` and moves all\n            // elements that are less than or equal to the pivot to the before it, and\n            // all the elements that are greater than it after it. The effect is that\n            // once partition is done, the pivot is in the exact place it will be when\n            // the array is put in sorted order, and it will not need to be moved\n            // again. This runs in O(n) time.\n            // Always choose a random pivot so that an input array which is reverse\n            // sorted does not cause O(n^2) running time.\n            var pivotIndex = randomIntInRange(p, r);\n            var i = p - 1;\n            swap(ary, pivotIndex, r);\n            var pivot = ary[r];\n            // Immediately after `j` is incremented in this loop, the following hold\n            // true:\n            //\n            //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n            //\n            //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n            for(var j = p; j < r; j++){\n                if (comparator(ary[j], pivot, false) <= 0) {\n                    i += 1;\n                    swap(ary, i, j);\n                }\n            }\n            swap(ary, i + 1, j);\n            var q = i + 1;\n            // (2) Recurse on each half.\n            doQuickSort(ary, comparator, p, q - 1);\n            doQuickSort(ary, comparator, q + 1, r);\n        }\n    }\n    return doQuickSort;\n}\nfunction cloneSort(comparator) {\n    let template = SortTemplate.toString();\n    let templateFn = new Function(`return ${template}`)();\n    return templateFn(comparator);\n}\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */ let sortCache = new WeakMap();\nexports.quickSort = function(ary, comparator, start = 0) {\n    let doQuickSort = sortCache.get(comparator);\n    if (doQuickSort === void 0) {\n        doQuickSort = cloneSort(comparator);\n        sortCache.set(comparator, doQuickSort);\n    }\n    doQuickSort(ary, comparator, start, ary.length - 1);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vc291cmNlLW1hcC1qcy9saWIvcXVpY2stc29ydC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5Q0FBeUMsR0FDekM7Ozs7Q0FJQyxHQUVELG9FQUFvRTtBQUNwRSwwRUFBMEU7QUFDMUUsNkVBQTZFO0FBQzdFLDhFQUE4RTtBQUM5RSx5RUFBeUU7QUFDekUsNkVBQTZFO0FBQzdFLDZFQUE2RTtBQUM3RSw2RUFBNkU7QUFDN0UsaURBQWlEO0FBRWpELFNBQVNBLGFBQWFDLFVBQVU7SUFFaEM7Ozs7Ozs7OztDQVNDLEdBQ0QsU0FBU0MsS0FBS0MsR0FBRyxFQUFFQyxDQUFDLEVBQUVDLENBQUM7UUFDckIsSUFBSUMsT0FBT0gsR0FBRyxDQUFDQyxFQUFFO1FBQ2pCRCxHQUFHLENBQUNDLEVBQUUsR0FBR0QsR0FBRyxDQUFDRSxFQUFFO1FBQ2ZGLEdBQUcsQ0FBQ0UsRUFBRSxHQUFHQztJQUNYO0lBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNDLGlCQUFpQkMsR0FBRyxFQUFFQyxJQUFJO1FBQ2pDLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0gsTUFBT0UsS0FBS0UsTUFBTSxLQUFNSCxDQUFBQSxPQUFPRCxHQUFFO0lBQ3JEO0lBRUE7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxTQUFTSyxZQUFZVixHQUFHLEVBQUVGLFVBQVUsRUFBRWEsQ0FBQyxFQUFFQyxDQUFDO1FBQ3hDLHdFQUF3RTtRQUN4RSw0RUFBNEU7UUFDNUUscUNBQXFDO1FBRXJDLElBQUlELElBQUlDLEdBQUc7WUFDVCxvQkFBb0I7WUFDcEIsRUFBRTtZQUNGLHFFQUFxRTtZQUNyRSwwRUFBMEU7WUFDMUUseUVBQXlFO1lBQ3pFLDBFQUEwRTtZQUMxRSxxRUFBcUU7WUFDckUsaUNBQWlDO1lBRWpDLHVFQUF1RTtZQUN2RSw2Q0FBNkM7WUFDN0MsSUFBSUMsYUFBYVQsaUJBQWlCTyxHQUFHQztZQUNyQyxJQUFJRSxJQUFJSCxJQUFJO1lBRVpaLEtBQUtDLEtBQUthLFlBQVlEO1lBQ3RCLElBQUlHLFFBQVFmLEdBQUcsQ0FBQ1ksRUFBRTtZQUVsQix3RUFBd0U7WUFDeEUsUUFBUTtZQUNSLEVBQUU7WUFDRix5RUFBeUU7WUFDekUsRUFBRTtZQUNGLG9FQUFvRTtZQUNwRSxJQUFLLElBQUlJLElBQUlMLEdBQUdLLElBQUlKLEdBQUdJLElBQUs7Z0JBQzFCLElBQUlsQixXQUFXRSxHQUFHLENBQUNnQixFQUFFLEVBQUVELE9BQU8sVUFBVSxHQUFHO29CQUN6Q0QsS0FBSztvQkFDTGYsS0FBS0MsS0FBS2MsR0FBR0U7Z0JBQ2Y7WUFDRjtZQUVBakIsS0FBS0MsS0FBS2MsSUFBSSxHQUFHRTtZQUNqQixJQUFJQyxJQUFJSCxJQUFJO1lBRVosNEJBQTRCO1lBRTVCSixZQUFZVixLQUFLRixZQUFZYSxHQUFHTSxJQUFJO1lBQ3BDUCxZQUFZVixLQUFLRixZQUFZbUIsSUFBSSxHQUFHTDtRQUN0QztJQUNGO0lBRUUsT0FBT0Y7QUFDVDtBQUVBLFNBQVNRLFVBQVVwQixVQUFVO0lBQzNCLElBQUlxQixXQUFXdEIsYUFBYXVCLFFBQVE7SUFDcEMsSUFBSUMsYUFBYSxJQUFJQyxTQUFTLENBQUMsT0FBTyxFQUFFSCxTQUFTLENBQUM7SUFDbEQsT0FBT0UsV0FBV3ZCO0FBQ3BCO0FBRUE7Ozs7Ozs7Q0FPQyxHQUVELElBQUl5QixZQUFZLElBQUlDO0FBQ3BCQyxpQkFBaUIsR0FBRyxTQUFVekIsR0FBRyxFQUFFRixVQUFVLEVBQUU2QixRQUFRLENBQUM7SUFDdEQsSUFBSWpCLGNBQWNhLFVBQVVLLEdBQUcsQ0FBQzlCO0lBQ2hDLElBQUlZLGdCQUFnQixLQUFLLEdBQUc7UUFDMUJBLGNBQWNRLFVBQVVwQjtRQUN4QnlCLFVBQVVNLEdBQUcsQ0FBQy9CLFlBQVlZO0lBQzVCO0lBQ0FBLFlBQVlWLEtBQUtGLFlBQVk2QixPQUFPM0IsSUFBSThCLE1BQU0sR0FBRztBQUNuRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWVtYWlsLy4uL3NvdXJjZS1tYXAtanMvbGliL3F1aWNrLXNvcnQuanM/YTViOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbi8vIEl0IHR1cm5zIG91dCB0aGF0IHNvbWUgKG1vc3Q/KSBKYXZhU2NyaXB0IGVuZ2luZXMgZG9uJ3Qgc2VsZi1ob3N0XG4vLyBgQXJyYXkucHJvdG90eXBlLnNvcnRgLiBUaGlzIG1ha2VzIHNlbnNlIGJlY2F1c2UgQysrIHdpbGwgbGlrZWx5IHJlbWFpblxuLy8gZmFzdGVyIHRoYW4gSlMgd2hlbiBkb2luZyByYXcgQ1BVLWludGVuc2l2ZSBzb3J0aW5nLiBIb3dldmVyLCB3aGVuIHVzaW5nIGFcbi8vIGN1c3RvbSBjb21wYXJhdG9yIGZ1bmN0aW9uLCBjYWxsaW5nIGJhY2sgYW5kIGZvcnRoIGJldHdlZW4gdGhlIFZNJ3MgQysrIGFuZFxuLy8gSklUJ2QgSlMgaXMgcmF0aGVyIHNsb3cgKmFuZCogbG9zZXMgSklUIHR5cGUgaW5mb3JtYXRpb24sIHJlc3VsdGluZyBpblxuLy8gd29yc2UgZ2VuZXJhdGVkIGNvZGUgZm9yIHRoZSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRoYW4gd291bGQgYmUgb3B0aW1hbC4gSW5cbi8vIGZhY3QsIHdoZW4gc29ydGluZyB3aXRoIGEgY29tcGFyYXRvciwgdGhlc2UgY29zdHMgb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIG9mXG4vLyBzb3J0aW5nIGluIEMrKy4gQnkgdXNpbmcgb3VyIG93biBKUy1pbXBsZW1lbnRlZCBRdWljayBTb3J0IChiZWxvdyksIHdlIGdldFxuLy8gYSB+MzUwMG1zIG1lYW4gc3BlZWQtdXAgaW4gYGJlbmNoL2JlbmNoLmh0bWxgLlxuXG5mdW5jdGlvbiBTb3J0VGVtcGxhdGUoY29tcGFyYXRvcikge1xuXG4vKipcbiAqIFN3YXAgdGhlIGVsZW1lbnRzIGluZGV4ZWQgYnkgYHhgIGFuZCBgeWAgaW4gdGhlIGFycmF5IGBhcnlgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIFRoZSBhcnJheS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtLlxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHNlY29uZCBpdGVtLlxuICovXG5mdW5jdGlvbiBzd2FwKGFyeSwgeCwgeSkge1xuICB2YXIgdGVtcCA9IGFyeVt4XTtcbiAgYXJ5W3hdID0gYXJ5W3ldO1xuICBhcnlbeV0gPSB0ZW1wO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciB3aXRoaW4gdGhlIHJhbmdlIGBsb3cgLi4gaGlnaGAgaW5jbHVzaXZlLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb3dcbiAqICAgICAgICBUaGUgbG93ZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2hcbiAqICAgICAgICBUaGUgdXBwZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICovXG5mdW5jdGlvbiByYW5kb21JbnRJblJhbmdlKGxvdywgaGlnaCkge1xuICByZXR1cm4gTWF0aC5yb3VuZChsb3cgKyAoTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93KSkpO1xufVxuXG4vKipcbiAqIFRoZSBRdWljayBTb3J0IGFsZ29yaXRobS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwXG4gKiAgICAgICAgU3RhcnQgaW5kZXggb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gclxuICogICAgICAgIEVuZCBpbmRleCBvZiB0aGUgYXJyYXlcbiAqL1xuZnVuY3Rpb24gZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCByKSB7XG4gIC8vIElmIG91ciBsb3dlciBib3VuZCBpcyBsZXNzIHRoYW4gb3VyIHVwcGVyIGJvdW5kLCB3ZSAoMSkgcGFydGl0aW9uIHRoZVxuICAvLyBhcnJheSBpbnRvIHR3byBwaWVjZXMgYW5kICgyKSByZWN1cnNlIG9uIGVhY2ggaGFsZi4gSWYgaXQgaXMgbm90LCB0aGlzIGlzXG4gIC8vIHRoZSBlbXB0eSBhcnJheSBhbmQgb3VyIGJhc2UgY2FzZS5cblxuICBpZiAocCA8IHIpIHtcbiAgICAvLyAoMSkgUGFydGl0aW9uaW5nLlxuICAgIC8vXG4gICAgLy8gVGhlIHBhcnRpdGlvbmluZyBjaG9vc2VzIGEgcGl2b3QgYmV0d2VlbiBgcGAgYW5kIGByYCBhbmQgbW92ZXMgYWxsXG4gICAgLy8gZWxlbWVudHMgdGhhdCBhcmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdCB0byB0aGUgYmVmb3JlIGl0LCBhbmRcbiAgICAvLyBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgYXJlIGdyZWF0ZXIgdGhhbiBpdCBhZnRlciBpdC4gVGhlIGVmZmVjdCBpcyB0aGF0XG4gICAgLy8gb25jZSBwYXJ0aXRpb24gaXMgZG9uZSwgdGhlIHBpdm90IGlzIGluIHRoZSBleGFjdCBwbGFjZSBpdCB3aWxsIGJlIHdoZW5cbiAgICAvLyB0aGUgYXJyYXkgaXMgcHV0IGluIHNvcnRlZCBvcmRlciwgYW5kIGl0IHdpbGwgbm90IG5lZWQgdG8gYmUgbW92ZWRcbiAgICAvLyBhZ2Fpbi4gVGhpcyBydW5zIGluIE8obikgdGltZS5cblxuICAgIC8vIEFsd2F5cyBjaG9vc2UgYSByYW5kb20gcGl2b3Qgc28gdGhhdCBhbiBpbnB1dCBhcnJheSB3aGljaCBpcyByZXZlcnNlXG4gICAgLy8gc29ydGVkIGRvZXMgbm90IGNhdXNlIE8obl4yKSBydW5uaW5nIHRpbWUuXG4gICAgdmFyIHBpdm90SW5kZXggPSByYW5kb21JbnRJblJhbmdlKHAsIHIpO1xuICAgIHZhciBpID0gcCAtIDE7XG5cbiAgICBzd2FwKGFyeSwgcGl2b3RJbmRleCwgcik7XG4gICAgdmFyIHBpdm90ID0gYXJ5W3JdO1xuXG4gICAgLy8gSW1tZWRpYXRlbHkgYWZ0ZXIgYGpgIGlzIGluY3JlbWVudGVkIGluIHRoaXMgbG9vcCwgdGhlIGZvbGxvd2luZyBob2xkXG4gICAgLy8gdHJ1ZTpcbiAgICAvL1xuICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbcCAuLiBpXWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdC5cbiAgICAvL1xuICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbaSsxIC4uIGotMV1gIGlzIGdyZWF0ZXIgdGhhbiB0aGUgcGl2b3QuXG4gICAgZm9yICh2YXIgaiA9IHA7IGogPCByOyBqKyspIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKGFyeVtqXSwgcGl2b3QsIGZhbHNlKSA8PSAwKSB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgc3dhcChhcnksIGksIGopO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3YXAoYXJ5LCBpICsgMSwgaik7XG4gICAgdmFyIHEgPSBpICsgMTtcblxuICAgIC8vICgyKSBSZWN1cnNlIG9uIGVhY2ggaGFsZi5cblxuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcSAtIDEpO1xuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcSArIDEsIHIpO1xuICB9XG59XG5cbiAgcmV0dXJuIGRvUXVpY2tTb3J0O1xufVxuXG5mdW5jdGlvbiBjbG9uZVNvcnQoY29tcGFyYXRvcikge1xuICBsZXQgdGVtcGxhdGUgPSBTb3J0VGVtcGxhdGUudG9TdHJpbmcoKTtcbiAgbGV0IHRlbXBsYXRlRm4gPSBuZXcgRnVuY3Rpb24oYHJldHVybiAke3RlbXBsYXRlfWApKCk7XG4gIHJldHVybiB0ZW1wbGF0ZUZuKGNvbXBhcmF0b3IpO1xufVxuXG4vKipcbiAqIFNvcnQgdGhlIGdpdmVuIGFycmF5IGluLXBsYWNlIHdpdGggdGhlIGdpdmVuIGNvbXBhcmF0b3IgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gKi9cblxubGV0IHNvcnRDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5leHBvcnRzLnF1aWNrU29ydCA9IGZ1bmN0aW9uIChhcnksIGNvbXBhcmF0b3IsIHN0YXJ0ID0gMCkge1xuICBsZXQgZG9RdWlja1NvcnQgPSBzb3J0Q2FjaGUuZ2V0KGNvbXBhcmF0b3IpO1xuICBpZiAoZG9RdWlja1NvcnQgPT09IHZvaWQgMCkge1xuICAgIGRvUXVpY2tTb3J0ID0gY2xvbmVTb3J0KGNvbXBhcmF0b3IpO1xuICAgIHNvcnRDYWNoZS5zZXQoY29tcGFyYXRvciwgZG9RdWlja1NvcnQpO1xuICB9XG4gIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgc3RhcnQsIGFyeS5sZW5ndGggLSAxKTtcbn07XG4iXSwibmFtZXMiOlsiU29ydFRlbXBsYXRlIiwiY29tcGFyYXRvciIsInN3YXAiLCJhcnkiLCJ4IiwieSIsInRlbXAiLCJyYW5kb21JbnRJblJhbmdlIiwibG93IiwiaGlnaCIsIk1hdGgiLCJyb3VuZCIsInJhbmRvbSIsImRvUXVpY2tTb3J0IiwicCIsInIiLCJwaXZvdEluZGV4IiwiaSIsInBpdm90IiwiaiIsInEiLCJjbG9uZVNvcnQiLCJ0ZW1wbGF0ZSIsInRvU3RyaW5nIiwidGVtcGxhdGVGbiIsIkZ1bmN0aW9uIiwic29ydENhY2hlIiwiV2Vha01hcCIsImV4cG9ydHMiLCJxdWlja1NvcnQiLCJzdGFydCIsImdldCIsInNldCIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../source-map-js/lib/quick-sort.js\n");

/***/ }),

/***/ "(action-browser)/../source-map-js/lib/source-map-consumer.js":
/*!***************************************************!*\
  !*** ../source-map-js/lib/source-map-consumer.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var util = __webpack_require__(/*! ./util */ \"(action-browser)/../source-map-js/lib/util.js\");\nvar binarySearch = __webpack_require__(/*! ./binary-search */ \"(action-browser)/../source-map-js/lib/binary-search.js\");\nvar ArraySet = (__webpack_require__(/*! ./array-set */ \"(action-browser)/../source-map-js/lib/array-set.js\").ArraySet);\nvar base64VLQ = __webpack_require__(/*! ./base64-vlq */ \"(action-browser)/../source-map-js/lib/base64-vlq.js\");\nvar quickSort = (__webpack_require__(/*! ./quick-sort */ \"(action-browser)/../source-map-js/lib/quick-sort.js\").quickSort);\nfunction SourceMapConsumer(aSourceMap, aSourceMapURL) {\n    var sourceMap = aSourceMap;\n    if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n    }\n    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n}\nSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {\n    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n};\n/**\n * The version of the source mapping spec that we are consuming.\n */ SourceMapConsumer.prototype._version = 3;\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, \"_generatedMappings\", {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n        if (!this.__generatedMappings) {\n            this._parseMappings(this._mappings, this.sourceRoot);\n        }\n        return this.__generatedMappings;\n    }\n});\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, \"_originalMappings\", {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n        if (!this.__originalMappings) {\n            this._parseMappings(this._mappings, this.sourceRoot);\n        }\n        return this.__originalMappings;\n    }\n});\nSourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n};\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */ SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n};\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */ SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n    var mappings;\n    switch(order){\n        case SourceMapConsumer.GENERATED_ORDER:\n            mappings = this._generatedMappings;\n            break;\n        case SourceMapConsumer.ORIGINAL_ORDER:\n            mappings = this._originalMappings;\n            break;\n        default:\n            throw new Error(\"Unknown order of iteration.\");\n    }\n    var sourceRoot = this.sourceRoot;\n    var boundCallback = aCallback.bind(context);\n    var names = this._names;\n    var sources = this._sources;\n    var sourceMapURL = this._sourceMapURL;\n    for(var i = 0, n = mappings.length; i < n; i++){\n        var mapping = mappings[i];\n        var source = mapping.source === null ? null : sources.at(mapping.source);\n        source = util.computeSourceURL(sourceRoot, source, sourceMapURL);\n        boundCallback({\n            source: source,\n            generatedLine: mapping.generatedLine,\n            generatedColumn: mapping.generatedColumn,\n            originalLine: mapping.originalLine,\n            originalColumn: mapping.originalColumn,\n            name: mapping.name === null ? null : names.at(mapping.name)\n        });\n    }\n};\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number is 1-based.\n *   - column: Optional. the column number in the original source.\n *    The column number is 0-based.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *    line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *    The column number is 0-based.\n */ SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, \"line\");\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n        source: util.getArg(aArgs, \"source\"),\n        originalLine: line,\n        originalColumn: util.getArg(aArgs, \"column\", 0)\n    };\n    needle.source = this._findSourceIndex(needle.source);\n    if (needle.source < 0) {\n        return [];\n    }\n    var mappings = [];\n    var index = this._findMapping(needle, this._originalMappings, \"originalLine\", \"originalColumn\", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n        var mapping = this._originalMappings[index];\n        if (aArgs.column === undefined) {\n            var originalLine = mapping.originalLine;\n            // Iterate until either we run out of mappings, or we run into\n            // a mapping for a different line than the one we found. Since\n            // mappings are sorted, this is guaranteed to find all mappings for\n            // the line we found.\n            while(mapping && mapping.originalLine === originalLine){\n                mappings.push({\n                    line: util.getArg(mapping, \"generatedLine\", null),\n                    column: util.getArg(mapping, \"generatedColumn\", null),\n                    lastColumn: util.getArg(mapping, \"lastGeneratedColumn\", null)\n                });\n                mapping = this._originalMappings[++index];\n            }\n        } else {\n            var originalColumn = mapping.originalColumn;\n            // Iterate until either we run out of mappings, or we run into\n            // a mapping for a different line than the one we were searching for.\n            // Since mappings are sorted, this is guaranteed to find all mappings for\n            // the line we are searching for.\n            while(mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn){\n                mappings.push({\n                    line: util.getArg(mapping, \"generatedLine\", null),\n                    column: util.getArg(mapping, \"generatedColumn\", null),\n                    lastColumn: util.getArg(mapping, \"lastGeneratedColumn\", null)\n                });\n                mapping = this._originalMappings[++index];\n            }\n        }\n    }\n    return mappings;\n};\nexports.SourceMapConsumer = SourceMapConsumer;\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */ function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\n    var sourceMap = aSourceMap;\n    if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n    }\n    var version = util.getArg(sourceMap, \"version\");\n    var sources = util.getArg(sourceMap, \"sources\");\n    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n    // requires the array) to play nice here.\n    var names = util.getArg(sourceMap, \"names\", []);\n    var sourceRoot = util.getArg(sourceMap, \"sourceRoot\", null);\n    var sourcesContent = util.getArg(sourceMap, \"sourcesContent\", null);\n    var mappings = util.getArg(sourceMap, \"mappings\");\n    var file = util.getArg(sourceMap, \"file\", null);\n    // Once again, Sass deviates from the spec and supplies the version as a\n    // string rather than a number, so we use loose equality checking here.\n    if (version != this._version) {\n        throw new Error(\"Unsupported version: \" + version);\n    }\n    if (sourceRoot) {\n        sourceRoot = util.normalize(sourceRoot);\n    }\n    sources = sources.map(String)// Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)// Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function(source) {\n        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;\n    });\n    // Pass `true` below to allow duplicate names and sources. While source maps\n    // are intended to be compressed and deduplicated, the TypeScript compiler\n    // sometimes generates source maps with duplicates in them. See Github issue\n    // #72 and bugzil.la/889492.\n    this._names = ArraySet.fromArray(names.map(String), true);\n    this._sources = ArraySet.fromArray(sources, true);\n    this._absoluteSources = this._sources.toArray().map(function(s) {\n        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n    });\n    this.sourceRoot = sourceRoot;\n    this.sourcesContent = sourcesContent;\n    this._mappings = mappings;\n    this._sourceMapURL = aSourceMapURL;\n    this.file = file;\n}\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n/**\n * Utility function to find the index of a source.  Returns -1 if not\n * found.\n */ BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {\n    var relativeSource = aSource;\n    if (this.sourceRoot != null) {\n        relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n    if (this._sources.has(relativeSource)) {\n        return this._sources.indexOf(relativeSource);\n    }\n    // Maybe aSource is an absolute URL as returned by |sources|.  In\n    // this case we can't simply undo the transform.\n    var i;\n    for(i = 0; i < this._absoluteSources.length; ++i){\n        if (this._absoluteSources[i] == aSource) {\n            return i;\n        }\n    }\n    return -1;\n};\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @param String aSourceMapURL\n *        The URL at which the source map can be found (optional)\n * @returns BasicSourceMapConsumer\n */ BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);\n    smc.file = aSourceMap._file;\n    smc._sourceMapURL = aSourceMapURL;\n    smc._absoluteSources = smc._sources.toArray().map(function(s) {\n        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);\n    });\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n    for(var i = 0, length = generatedMappings.length; i < length; i++){\n        var srcMapping = generatedMappings[i];\n        var destMapping = new Mapping;\n        destMapping.generatedLine = srcMapping.generatedLine;\n        destMapping.generatedColumn = srcMapping.generatedColumn;\n        if (srcMapping.source) {\n            destMapping.source = sources.indexOf(srcMapping.source);\n            destMapping.originalLine = srcMapping.originalLine;\n            destMapping.originalColumn = srcMapping.originalColumn;\n            if (srcMapping.name) {\n                destMapping.name = names.indexOf(srcMapping.name);\n            }\n            destOriginalMappings.push(destMapping);\n        }\n        destGeneratedMappings.push(destMapping);\n    }\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n    return smc;\n};\n/**\n * The version of the source mapping spec that we are consuming.\n */ BasicSourceMapConsumer.prototype._version = 3;\n/**\n * The list of original sources.\n */ Object.defineProperty(BasicSourceMapConsumer.prototype, \"sources\", {\n    get: function() {\n        return this._absoluteSources.slice();\n    }\n});\n/**\n * Provide the JIT with a nice shape / hidden class.\n */ function Mapping() {\n    this.generatedLine = 0;\n    this.generatedColumn = 0;\n    this.source = null;\n    this.originalLine = null;\n    this.originalColumn = null;\n    this.name = null;\n}\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */ const compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;\nfunction sortGenerated(array, start) {\n    let l = array.length;\n    let n = array.length - start;\n    if (n <= 1) {\n        return;\n    } else if (n == 2) {\n        let a = array[start];\n        let b = array[start + 1];\n        if (compareGenerated(a, b) > 0) {\n            array[start] = b;\n            array[start + 1] = a;\n        }\n    } else if (n < 20) {\n        for(let i = start; i < l; i++){\n            for(let j = i; j > start; j--){\n                let a = array[j - 1];\n                let b = array[j];\n                if (compareGenerated(a, b) <= 0) {\n                    break;\n                }\n                array[j - 1] = b;\n                array[j] = a;\n            }\n        }\n    } else {\n        quickSort(array, compareGenerated, start);\n    }\n}\nBasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n    let subarrayStart = 0;\n    while(index < length){\n        if (aStr.charAt(index) === \";\") {\n            generatedLine++;\n            index++;\n            previousGeneratedColumn = 0;\n            sortGenerated(generatedMappings, subarrayStart);\n            subarrayStart = generatedMappings.length;\n        } else if (aStr.charAt(index) === \",\") {\n            index++;\n        } else {\n            mapping = new Mapping();\n            mapping.generatedLine = generatedLine;\n            for(end = index; end < length; end++){\n                if (this._charIsMappingSeparator(aStr, end)) {\n                    break;\n                }\n            }\n            str = aStr.slice(index, end);\n            segment = [];\n            while(index < end){\n                base64VLQ.decode(aStr, index, temp);\n                value = temp.value;\n                index = temp.rest;\n                segment.push(value);\n            }\n            if (segment.length === 2) {\n                throw new Error(\"Found a source, but no line and column\");\n            }\n            if (segment.length === 3) {\n                throw new Error(\"Found a source and line, but no column\");\n            }\n            // Generated column.\n            mapping.generatedColumn = previousGeneratedColumn + segment[0];\n            previousGeneratedColumn = mapping.generatedColumn;\n            if (segment.length > 1) {\n                // Original source.\n                mapping.source = previousSource + segment[1];\n                previousSource += segment[1];\n                // Original line.\n                mapping.originalLine = previousOriginalLine + segment[2];\n                previousOriginalLine = mapping.originalLine;\n                // Lines are stored 0-based\n                mapping.originalLine += 1;\n                // Original column.\n                mapping.originalColumn = previousOriginalColumn + segment[3];\n                previousOriginalColumn = mapping.originalColumn;\n                if (segment.length > 4) {\n                    // Original name.\n                    mapping.name = previousName + segment[4];\n                    previousName += segment[4];\n                }\n            }\n            generatedMappings.push(mapping);\n            if (typeof mapping.originalLine === \"number\") {\n                let currentSource = mapping.source;\n                while(originalMappings.length <= currentSource){\n                    originalMappings.push(null);\n                }\n                if (originalMappings[currentSource] === null) {\n                    originalMappings[currentSource] = [];\n                }\n                originalMappings[currentSource].push(mapping);\n            }\n        }\n    }\n    sortGenerated(generatedMappings, subarrayStart);\n    this.__generatedMappings = generatedMappings;\n    for(var i = 0; i < originalMappings.length; i++){\n        if (originalMappings[i] != null) {\n            quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);\n        }\n    }\n    this.__originalMappings = [].concat(...originalMappings);\n};\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */ BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n    if (aNeedle[aLineName] <= 0) {\n        throw new TypeError(\"Line must be greater than or equal to 1, got \" + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n        throw new TypeError(\"Column must be greater than or equal to 0, got \" + aNeedle[aColumnName]);\n    }\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n};\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */ BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {\n    for(var index = 0; index < this._generatedMappings.length; ++index){\n        var mapping = this._generatedMappings[index];\n        // Mappings do not contain a field for the last generated columnt. We\n        // can come up with an optimistic estimate, however, by assuming that\n        // mappings are contiguous (i.e. given two consecutive mappings, the\n        // first mapping ends where the second one starts).\n        if (index + 1 < this._generatedMappings.length) {\n            var nextMapping = this._generatedMappings[index + 1];\n            if (mapping.generatedLine === nextMapping.generatedLine) {\n                mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n                continue;\n            }\n        }\n        // The last mapping for each line spans the entire line.\n        mapping.lastGeneratedColumn = Infinity;\n    }\n};\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */ BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n        generatedLine: util.getArg(aArgs, \"line\"),\n        generatedColumn: util.getArg(aArgs, \"column\")\n    };\n    var index = this._findMapping(needle, this._generatedMappings, \"generatedLine\", \"generatedColumn\", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND));\n    if (index >= 0) {\n        var mapping = this._generatedMappings[index];\n        if (mapping.generatedLine === needle.generatedLine) {\n            var source = util.getArg(mapping, \"source\", null);\n            if (source !== null) {\n                source = this._sources.at(source);\n                source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n            }\n            var name = util.getArg(mapping, \"name\", null);\n            if (name !== null) {\n                name = this._names.at(name);\n            }\n            return {\n                source: source,\n                line: util.getArg(mapping, \"originalLine\", null),\n                column: util.getArg(mapping, \"originalColumn\", null),\n                name: name\n            };\n        }\n    }\n    return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n    };\n};\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */ BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n        return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {\n        return sc == null;\n    });\n};\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */ BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n        return null;\n    }\n    var index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n        return this.sourcesContent[index];\n    }\n    var relativeSource = aSource;\n    if (this.sourceRoot != null) {\n        relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n    var url;\n    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {\n        // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n        // many users. We can help them out when they expect file:// URIs to\n        // behave like it would if they were running a local HTTP server. See\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n        var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n        if (url.scheme == \"file\" && this._sources.has(fileUriAbsPath)) {\n            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n        }\n        if ((!url.path || url.path == \"/\") && this._sources.has(\"/\" + relativeSource)) {\n            return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n        }\n    }\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n        return null;\n    } else {\n        throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n    }\n};\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */ BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, \"source\");\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n        return {\n            line: null,\n            column: null,\n            lastColumn: null\n        };\n    }\n    var needle = {\n        source: source,\n        originalLine: util.getArg(aArgs, \"line\"),\n        originalColumn: util.getArg(aArgs, \"column\")\n    };\n    var index = this._findMapping(needle, this._originalMappings, \"originalLine\", \"originalColumn\", util.compareByOriginalPositions, util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND));\n    if (index >= 0) {\n        var mapping = this._originalMappings[index];\n        if (mapping.source === needle.source) {\n            return {\n                line: util.getArg(mapping, \"generatedLine\", null),\n                column: util.getArg(mapping, \"generatedColumn\", null),\n                lastColumn: util.getArg(mapping, \"lastGeneratedColumn\", null)\n            };\n        }\n    }\n    return {\n        line: null,\n        column: null,\n        lastColumn: null\n    };\n};\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */ function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\n    var sourceMap = aSourceMap;\n    if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n    }\n    var version = util.getArg(sourceMap, \"version\");\n    var sections = util.getArg(sourceMap, \"sections\");\n    if (version != this._version) {\n        throw new Error(\"Unsupported version: \" + version);\n    }\n    this._sources = new ArraySet();\n    this._names = new ArraySet();\n    var lastOffset = {\n        line: -1,\n        column: 0\n    };\n    this._sections = sections.map(function(s) {\n        if (s.url) {\n            // The url field will require support for asynchronicity.\n            // See https://github.com/mozilla/source-map/issues/16\n            throw new Error(\"Support for url field in sections not implemented.\");\n        }\n        var offset = util.getArg(s, \"offset\");\n        var offsetLine = util.getArg(offset, \"line\");\n        var offsetColumn = util.getArg(offset, \"column\");\n        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {\n            throw new Error(\"Section offsets must be ordered and non-overlapping.\");\n        }\n        lastOffset = offset;\n        return {\n            generatedOffset: {\n                // The offset fields are 0-based, but we use 1-based indices when\n                // encoding/decoding from VLQ.\n                generatedLine: offsetLine + 1,\n                generatedColumn: offsetColumn + 1\n            },\n            consumer: new SourceMapConsumer(util.getArg(s, \"map\"), aSourceMapURL)\n        };\n    });\n}\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n/**\n * The version of the source mapping spec that we are consuming.\n */ IndexedSourceMapConsumer.prototype._version = 3;\n/**\n * The list of original sources.\n */ Object.defineProperty(IndexedSourceMapConsumer.prototype, \"sources\", {\n    get: function() {\n        var sources = [];\n        for(var i = 0; i < this._sections.length; i++){\n            for(var j = 0; j < this._sections[i].consumer.sources.length; j++){\n                sources.push(this._sections[i].consumer.sources[j]);\n            }\n        }\n        return sources;\n    }\n});\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */ IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n        generatedLine: util.getArg(aArgs, \"line\"),\n        generatedColumn: util.getArg(aArgs, \"column\")\n    };\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections, function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n            return cmp;\n        }\n        return needle.generatedColumn - section.generatedOffset.generatedColumn;\n    });\n    var section = this._sections[sectionIndex];\n    if (!section) {\n        return {\n            source: null,\n            line: null,\n            column: null,\n            name: null\n        };\n    }\n    return section.consumer.originalPositionFor({\n        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),\n        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n        bias: aArgs.bias\n    });\n};\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */ IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function(s) {\n        return s.consumer.hasContentsOfAllSources();\n    });\n};\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */ IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for(var i = 0; i < this._sections.length; i++){\n        var section = this._sections[i];\n        var content = section.consumer.sourceContentFor(aSource, true);\n        if (content) {\n            return content;\n        }\n    }\n    if (nullOnMissing) {\n        return null;\n    } else {\n        throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n};\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based. \n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */ IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for(var i = 0; i < this._sections.length; i++){\n        var section = this._sections[i];\n        // Only consider this section if the requested source is in the list of\n        // sources of the consumer.\n        if (section.consumer._findSourceIndex(util.getArg(aArgs, \"source\")) === -1) {\n            continue;\n        }\n        var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n        if (generatedPosition) {\n            var ret = {\n                line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),\n                column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)\n            };\n            return ret;\n        }\n    }\n    return {\n        line: null,\n        column: null\n    };\n};\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */ IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for(var i = 0; i < this._sections.length; i++){\n        var section = this._sections[i];\n        var sectionMappings = section.consumer._generatedMappings;\n        for(var j = 0; j < sectionMappings.length; j++){\n            var mapping = sectionMappings[j];\n            var source = section.consumer._sources.at(mapping.source);\n            source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);\n            this._sources.add(source);\n            source = this._sources.indexOf(source);\n            var name = null;\n            if (mapping.name) {\n                name = section.consumer._names.at(mapping.name);\n                this._names.add(name);\n                name = this._names.indexOf(name);\n            }\n            // The mappings coming from the consumer for the section have\n            // generated positions relative to the start of the section, so we\n            // need to offset them to be relative to the start of the concatenated\n            // generated file.\n            var adjustedMapping = {\n                source: source,\n                generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),\n                generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n                originalLine: mapping.originalLine,\n                originalColumn: mapping.originalColumn,\n                name: name\n            };\n            this.__generatedMappings.push(adjustedMapping);\n            if (typeof adjustedMapping.originalLine === \"number\") {\n                this.__originalMappings.push(adjustedMapping);\n            }\n        }\n    }\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n};\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9zb3VyY2UtbWFwLWpzL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLHlDQUF5QyxHQUN6Qzs7OztDQUlDLEdBRUQsSUFBSUEsT0FBT0MsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUMsZUFBZUQsbUJBQU9BLENBQUM7QUFDM0IsSUFBSUUsV0FBV0YsdUdBQStCO0FBQzlDLElBQUlHLFlBQVlILG1CQUFPQSxDQUFDO0FBQ3hCLElBQUlJLFlBQVlKLDBHQUFpQztBQUVqRCxTQUFTSyxrQkFBa0JDLFVBQVUsRUFBRUMsYUFBYTtJQUNsRCxJQUFJQyxZQUFZRjtJQUNoQixJQUFJLE9BQU9BLGVBQWUsVUFBVTtRQUNsQ0UsWUFBWVQsS0FBS1UsbUJBQW1CLENBQUNIO0lBQ3ZDO0lBRUEsT0FBT0UsVUFBVUUsUUFBUSxJQUFJLE9BQ3pCLElBQUlDLHlCQUF5QkgsV0FBV0QsaUJBQ3hDLElBQUlLLHVCQUF1QkosV0FBV0Q7QUFDNUM7QUFFQUYsa0JBQWtCUSxhQUFhLEdBQUcsU0FBU1AsVUFBVSxFQUFFQyxhQUFhO0lBQ2xFLE9BQU9LLHVCQUF1QkMsYUFBYSxDQUFDUCxZQUFZQztBQUMxRDtBQUVBOztDQUVDLEdBQ0RGLGtCQUFrQlMsU0FBUyxDQUFDQyxRQUFRLEdBQUc7QUFFdkMsMEVBQTBFO0FBQzFFLDhFQUE4RTtBQUM5RSxxRUFBcUU7QUFDckUsMkVBQTJFO0FBQzNFLDhFQUE4RTtBQUM5RSwyRUFBMkU7QUFDM0UsMERBQTBEO0FBQzFELEVBQUU7QUFDRiw0Q0FBNEM7QUFDNUMsRUFBRTtBQUNGLFFBQVE7QUFDUiw4REFBOEQ7QUFDOUQsa0VBQWtFO0FBQ2xFLHlFQUF5RTtBQUN6RSwrQkFBK0I7QUFDL0Isa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSxzRUFBc0U7QUFDdEUscUVBQXFFO0FBQ3JFLDRFQUE0RTtBQUM1RSxvQkFBb0I7QUFDcEIsUUFBUTtBQUNSLEVBQUU7QUFDRix5RUFBeUU7QUFD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Q2pDc0gsQ0FBQUEsUUFBUUosZUFBZSxDQUFDbEgsYUFBYSxHQUFHO2dCQUMzQ0MsaUJBQWlCTCxRQUFRSyxlQUFlLEdBQ3JDcUgsQ0FBQUEsUUFBUUosZUFBZSxDQUFDbEgsYUFBYSxLQUFLSixRQUFRSSxhQUFhLEdBQzlEc0gsUUFBUUosZUFBZSxDQUFDakgsZUFBZSxHQUFHLElBQzFDO2dCQUNKQyxjQUFjTixRQUFRTSxZQUFZO2dCQUNsQ0MsZ0JBQWdCUCxRQUFRTyxjQUFjO2dCQUN0Q0MsTUFBTUE7WUFDUjtZQUVBLElBQUksQ0FBQ3BELG1CQUFtQixDQUFDZ0UsSUFBSSxDQUFDbUg7WUFDOUIsSUFBSSxPQUFPQSxnQkFBZ0JqSSxZQUFZLEtBQUssVUFBVTtnQkFDcEQsSUFBSSxDQUFDekMsa0JBQWtCLENBQUN1RCxJQUFJLENBQUNtSDtZQUMvQjtRQUNGO0lBQ0Y7SUFFQS9MLFVBQVUsSUFBSSxDQUFDWSxtQkFBbUIsRUFBRWpCLEtBQUs2SixtQ0FBbUM7SUFDNUV4SixVQUFVLElBQUksQ0FBQ3FCLGtCQUFrQixFQUFFMUIsS0FBSzhFLDBCQUEwQjtBQUNwRTtBQUVGSyxnQ0FBZ0MsR0FBR3ZFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtZW1haWwvLi4vc291cmNlLW1hcC1qcy9saWIvc291cmNlLW1hcC1jb25zdW1lci5qcz8wNjNlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBiaW5hcnlTZWFyY2ggPSByZXF1aXJlKCcuL2JpbmFyeS1zZWFyY2gnKTtcbnZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG52YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG52YXIgcXVpY2tTb3J0ID0gcmVxdWlyZSgnLi9xdWljay1zb3J0JykucXVpY2tTb3J0O1xuXG5mdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gdXRpbC5wYXJzZVNvdXJjZU1hcElucHV0KGFTb3VyY2VNYXApO1xuICB9XG5cbiAgcmV0dXJuIHNvdXJjZU1hcC5zZWN0aW9ucyAhPSBudWxsXG4gICAgPyBuZXcgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTClcbiAgICA6IG5ldyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCk7XG59XG5cblNvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPSBmdW5jdGlvbihhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gIHJldHVybiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCk7XG59XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vLyBgX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kIGBfX29yaWdpbmFsTWFwcGluZ3NgIGFyZSBhcnJheXMgdGhhdCBob2xkIHRoZVxuLy8gcGFyc2VkIG1hcHBpbmcgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlIG1hcCdzIFwibWFwcGluZ3NcIiBhdHRyaWJ1dGUuIFRoZXlcbi8vIGFyZSBsYXppbHkgaW5zdGFudGlhdGVkLCBhY2Nlc3NlZCB2aWEgdGhlIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBnZXR0ZXJzIHJlc3BlY3RpdmVseSwgYW5kIHdlIG9ubHkgcGFyc2UgdGhlIG1hcHBpbmdzXG4vLyBhbmQgY3JlYXRlIHRoZXNlIGFycmF5cyBvbmNlIHF1ZXJpZWQgZm9yIGEgc291cmNlIGxvY2F0aW9uLiBXZSBqdW1wIHRocm91Z2hcbi8vIHRoZXNlIGhvb3BzIGJlY2F1c2UgdGhlcmUgY2FuIGJlIG1hbnkgdGhvdXNhbmRzIG9mIG1hcHBpbmdzLCBhbmQgcGFyc2luZ1xuLy8gdGhlbSBpcyBleHBlbnNpdmUsIHNvIHdlIG9ubHkgd2FudCB0byBkbyBpdCBpZiB3ZSBtdXN0LlxuLy9cbi8vIEVhY2ggb2JqZWN0IGluIHRoZSBhcnJheXMgaXMgb2YgdGhlIGZvcm06XG4vL1xuLy8gICAgIHtcbi8vICAgICAgIGdlbmVyYXRlZExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBnZW5lcmF0ZWRDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIHNvdXJjZTogVGhlIHBhdGggdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIHRoYXQgZ2VuZXJhdGVkIHRoaXNcbi8vICAgICAgICAgICAgICAgY2h1bmsgb2YgY29kZSxcbi8vICAgICAgIG9yaWdpbmFsTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuLy8gICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgb3JpZ2luYWxDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuLy8gICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgb3JpZ2luYWwgc3ltYm9sIHdoaWNoIGdlbmVyYXRlZCB0aGlzIGNodW5rIG9mXG4vLyAgICAgICAgICAgICBjb2RlLlxuLy8gICAgIH1cbi8vXG4vLyBBbGwgcHJvcGVydGllcyBleGNlcHQgZm9yIGBnZW5lcmF0ZWRMaW5lYCBhbmQgYGdlbmVyYXRlZENvbHVtbmAgY2FuIGJlXG4vLyBgbnVsbGAuXG4vL1xuLy8gYF9nZW5lcmF0ZWRNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucy5cbi8vXG4vLyBgX29yaWdpbmFsTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucy5cblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBudWxsO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19nZW5lcmF0ZWRNYXBwaW5ncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncykge1xuICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG51bGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX29yaWdpbmFsTWFwcGluZ3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncykge1xuICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fX29yaWdpbmFsTWFwcGluZ3M7XG4gIH1cbn0pO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsIGluZGV4KSB7XG4gICAgdmFyIGMgPSBhU3RyLmNoYXJBdChpbmRleCk7XG4gICAgcmV0dXJuIGMgPT09IFwiO1wiIHx8IGMgPT09IFwiLFwiO1xuICB9O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnQgX3BhcnNlTWFwcGluZ3NcIik7XG4gIH07XG5cblNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUiA9IDE7XG5Tb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUiA9IDI7XG5cblNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EID0gMTtcblNvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgZWFjaCBtYXBwaW5nIGJldHdlZW4gYW4gb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uIGFuZCBhXG4gKiBnZW5lcmF0ZWQgbGluZS9jb2x1bW4gaW4gdGhpcyBzb3VyY2UgbWFwLlxuICpcbiAqIEBwYXJhbSBGdW5jdGlvbiBhQ2FsbGJhY2tcbiAqICAgICAgICBUaGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBlYWNoIG1hcHBpbmcuXG4gKiBAcGFyYW0gT2JqZWN0IGFDb250ZXh0XG4gKiAgICAgICAgT3B0aW9uYWwuIElmIHNwZWNpZmllZCwgdGhpcyBvYmplY3Qgd2lsbCBiZSB0aGUgdmFsdWUgb2YgYHRoaXNgIGV2ZXJ5XG4gKiAgICAgICAgdGltZSB0aGF0IGBhQ2FsbGJhY2tgIGlzIGNhbGxlZC5cbiAqIEBwYXJhbSBhT3JkZXJcbiAqICAgICAgICBFaXRoZXIgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAgb3JcbiAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVJgLiBTcGVjaWZpZXMgd2hldGhlciB5b3Ugd2FudCB0b1xuICogICAgICAgIGl0ZXJhdGUgb3ZlciB0aGUgbWFwcGluZ3Mgc29ydGVkIGJ5IHRoZSBnZW5lcmF0ZWQgZmlsZSdzIGxpbmUvY29sdW1uXG4gKiAgICAgICAgb3JkZXIgb3IgdGhlIG9yaWdpbmFsJ3Mgc291cmNlL2xpbmUvY29sdW1uIG9yZGVyLCByZXNwZWN0aXZlbHkuIERlZmF1bHRzIHRvXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5lYWNoTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2VhY2hNYXBwaW5nKGFDYWxsYmFjaywgYUNvbnRleHQsIGFPcmRlcikge1xuICAgIHZhciBjb250ZXh0ID0gYUNvbnRleHQgfHwgbnVsbDtcbiAgICB2YXIgb3JkZXIgPSBhT3JkZXIgfHwgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSO1xuXG4gICAgdmFyIG1hcHBpbmdzO1xuICAgIHN3aXRjaCAob3JkZXIpIHtcbiAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjpcbiAgICAgIG1hcHBpbmdzID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSOlxuICAgICAgbWFwcGluZ3MgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3JkZXIgb2YgaXRlcmF0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuc291cmNlUm9vdDtcbiAgICB2YXIgYm91bmRDYWxsYmFjayA9IGFDYWxsYmFjay5iaW5kKGNvbnRleHQpO1xuICAgIHZhciBuYW1lcyA9IHRoaXMuX25hbWVzO1xuICAgIHZhciBzb3VyY2VzID0gdGhpcy5fc291cmNlcztcbiAgICB2YXIgc291cmNlTWFwVVJMID0gdGhpcy5fc291cmNlTWFwVVJMO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBtYXBwaW5ncy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHZhciBtYXBwaW5nID0gbWFwcGluZ3NbaV07XG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2UgPT09IG51bGwgPyBudWxsIDogc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc291cmNlUm9vdCwgc291cmNlLCBzb3VyY2VNYXBVUkwpO1xuICAgICAgYm91bmRDYWxsYmFjayh7XG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4sXG4gICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICBuYW1lOiBtYXBwaW5nLm5hbWUgPT09IG51bGwgPyBudWxsIDogbmFtZXMuYXQobWFwcGluZy5uYW1lKVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgYWxsIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHByb3ZpZGVkLiBJZiBubyBjb2x1bW4gaXMgcHJvdmlkZWQsIHJldHVybnMgYWxsIG1hcHBpbmdzXG4gKiBjb3JyZXNwb25kaW5nIHRvIGEgZWl0aGVyIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yIG9yIHRoZSBuZXh0XG4gKiBjbG9zZXN0IGxpbmUgdGhhdCBoYXMgYW55IG1hcHBpbmdzLiBPdGhlcndpc2UsIHJldHVybnMgYWxsIG1hcHBpbmdzXG4gKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBsaW5lIGFuZCBlaXRoZXIgdGhlIGNvbHVtbiB3ZSBhcmUgc2VhcmNoaW5nIGZvclxuICogb3IgdGhlIG5leHQgY2xvc2VzdCBjb2x1bW4gdGhhdCBoYXMgYW55IG9mZnNldHMuXG4gKlxuICogVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBPcHRpb25hbC4gdGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKlxuICogYW5kIGFuIGFycmF5IG9mIG9iamVjdHMgaXMgcmV0dXJuZWQsIGVhY2ggd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2FsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvcihhQXJncykge1xuICAgIHZhciBsaW5lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyk7XG5cbiAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIGV4YWN0IG1hdGNoLCBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmdcbiAgICAvLyByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBtYXBwaW5nIGxlc3MgdGhhbiB0aGUgbmVlZGxlLiBCeVxuICAgIC8vIHNldHRpbmcgbmVlZGxlLm9yaWdpbmFsQ29sdW1uIHRvIDAsIHdlIHRodXMgZmluZCB0aGUgbGFzdCBtYXBwaW5nIGZvclxuICAgIC8vIHRoZSBnaXZlbiBsaW5lLCBwcm92aWRlZCBzdWNoIGEgbWFwcGluZyBleGlzdHMuXG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIHNvdXJjZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSxcbiAgICAgIG9yaWdpbmFsTGluZTogbGluZSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicsIDApXG4gICAgfTtcblxuICAgIG5lZWRsZS5zb3VyY2UgPSB0aGlzLl9maW5kU291cmNlSW5kZXgobmVlZGxlLnNvdXJjZSk7XG4gICAgaWYgKG5lZWRsZS5zb3VyY2UgPCAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIG1hcHBpbmdzID0gW107XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChhQXJncy5jb2x1bW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgb3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSBmb3VuZC4gU2luY2VcbiAgICAgICAgLy8gbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAvLyB0aGUgbGluZSB3ZSBmb3VuZC5cbiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IG9yaWdpbmFsTGluZSkge1xuICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSB3ZXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgIC8vIFNpbmNlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgLy8gdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgIHdoaWxlIChtYXBwaW5nICYmXG4gICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gbGluZSAmJlxuICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9PSBvcmlnaW5hbENvbHVtbikge1xuICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFwcGluZ3M7XG4gIH07XG5cbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBBIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoIHdlIGNhblxuICogcXVlcnkgZm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmlnaW5hbCBmaWxlIHBvc2l0aW9ucyBieSBnaXZpbmcgaXQgYSBmaWxlXG4gKiBwb3NpdGlvbiBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqXG4gKiBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIHRoZSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yXG4gKiBhbHJlYWR5IHBhcnNlZCB0byBhbiBvYmplY3QpLiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMsIHNvdXJjZSBtYXBzIGhhdmUgdGhlXG4gKiBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAqICAgLSBzb3VyY2VzOiBBbiBhcnJheSBvZiBVUkxzIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gKiAgIC0gbmFtZXM6IEFuIGFycmF5IG9mIGlkZW50aWZpZXJzIHdoaWNoIGNhbiBiZSByZWZlcnJlbmNlZCBieSBpbmRpdmlkdWFsIG1hcHBpbmdzLlxuICogICAtIHNvdXJjZVJvb3Q6IE9wdGlvbmFsLiBUaGUgVVJMIHJvb3QgZnJvbSB3aGljaCBhbGwgc291cmNlcyBhcmUgcmVsYXRpdmUuXG4gKiAgIC0gc291cmNlc0NvbnRlbnQ6IE9wdGlvbmFsLiBBbiBhcnJheSBvZiBjb250ZW50cyBvZiB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICogICAtIG1hcHBpbmdzOiBBIHN0cmluZyBvZiBiYXNlNjQgVkxRcyB3aGljaCBjb250YWluIHRoZSBhY3R1YWwgbWFwcGluZ3MuXG4gKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICpcbiAqIEhlcmUgaXMgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF06XG4gKlxuICogICAgIHtcbiAqICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgZmlsZTogXCJvdXQuanNcIixcbiAqICAgICAgIHNvdXJjZVJvb3QgOiBcIlwiLFxuICogICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICogICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gKiAgICAgICBtYXBwaW5nczogXCJBQSxBQjs7QUJDREU7XCJcbiAqICAgICB9XG4gKlxuICogVGhlIHNlY29uZCBwYXJhbWV0ZXIsIGlmIGdpdmVuLCBpcyBhIHN0cmluZyB3aG9zZSB2YWx1ZSBpcyB0aGUgVVJMXG4gKiBhdCB3aGljaCB0aGUgc291cmNlIG1hcCB3YXMgZm91bmQuICBUaGlzIFVSTCBpcyB1c2VkIHRvIGNvbXB1dGUgdGhlXG4gKiBzb3VyY2VzIGFycmF5LlxuICpcbiAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0P3BsaT0xI1xuICovXG5mdW5jdGlvbiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSB1dGlsLnBhcnNlU291cmNlTWFwSW5wdXQoYVNvdXJjZU1hcCk7XG4gIH1cblxuICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgdmFyIHNvdXJjZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzJyk7XG4gIC8vIFNhc3MgMy4zIGxlYXZlcyBvdXQgdGhlICduYW1lcycgYXJyYXksIHNvIHdlIGRldmlhdGUgZnJvbSB0aGUgc3BlYyAod2hpY2hcbiAgLy8gcmVxdWlyZXMgdGhlIGFycmF5KSB0byBwbGF5IG5pY2UgaGVyZS5cbiAgdmFyIG5hbWVzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbmFtZXMnLCBbXSk7XG4gIHZhciBzb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICB2YXIgc291cmNlc0NvbnRlbnQgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzQ29udGVudCcsIG51bGwpO1xuICB2YXIgbWFwcGluZ3MgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdtYXBwaW5ncycpO1xuICB2YXIgZmlsZSA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ2ZpbGUnLCBudWxsKTtcblxuICAvLyBPbmNlIGFnYWluLCBTYXNzIGRldmlhdGVzIGZyb20gdGhlIHNwZWMgYW5kIHN1cHBsaWVzIHRoZSB2ZXJzaW9uIGFzIGFcbiAgLy8gc3RyaW5nIHJhdGhlciB0aGFuIGEgbnVtYmVyLCBzbyB3ZSB1c2UgbG9vc2UgZXF1YWxpdHkgY2hlY2tpbmcgaGVyZS5cbiAgaWYgKHZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICB9XG5cbiAgaWYgKHNvdXJjZVJvb3QpIHtcbiAgICBzb3VyY2VSb290ID0gdXRpbC5ub3JtYWxpemUoc291cmNlUm9vdCk7XG4gIH1cblxuICBzb3VyY2VzID0gc291cmNlc1xuICAgIC5tYXAoU3RyaW5nKVxuICAgIC8vIFNvbWUgc291cmNlIG1hcHMgcHJvZHVjZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbGlrZSBcIi4vZm9vLmpzXCIgaW5zdGVhZCBvZlxuICAgIC8vIFwiZm9vLmpzXCIuICBOb3JtYWxpemUgdGhlc2UgZmlyc3Qgc28gdGhhdCBmdXR1cmUgY29tcGFyaXNvbnMgd2lsbCBzdWNjZWVkLlxuICAgIC8vIFNlZSBidWd6aWwubGEvMTA5MDc2OC5cbiAgICAubWFwKHV0aWwubm9ybWFsaXplKVxuICAgIC8vIEFsd2F5cyBlbnN1cmUgdGhhdCBhYnNvbHV0ZSBzb3VyY2VzIGFyZSBpbnRlcm5hbGx5IHN0b3JlZCByZWxhdGl2ZSB0b1xuICAgIC8vIHRoZSBzb3VyY2Ugcm9vdCwgaWYgdGhlIHNvdXJjZSByb290IGlzIGFic29sdXRlLiBOb3QgZG9pbmcgdGhpcyB3b3VsZFxuICAgIC8vIGJlIHBhcnRpY3VsYXJseSBwcm9ibGVtYXRpYyB3aGVuIHRoZSBzb3VyY2Ugcm9vdCBpcyBhIHByZWZpeCBvZiB0aGVcbiAgICAvLyBzb3VyY2UgKHZhbGlkLCBidXQgd2h5Pz8pLiBTZWUgZ2l0aHViIGlzc3VlICMxOTkgYW5kIGJ1Z3ppbC5sYS8xMTg4OTgyLlxuICAgIC5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHNvdXJjZVJvb3QgJiYgdXRpbC5pc0Fic29sdXRlKHNvdXJjZVJvb3QpICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2UpXG4gICAgICAgID8gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2UpXG4gICAgICAgIDogc291cmNlO1xuICAgIH0pO1xuXG4gIC8vIFBhc3MgYHRydWVgIGJlbG93IHRvIGFsbG93IGR1cGxpY2F0ZSBuYW1lcyBhbmQgc291cmNlcy4gV2hpbGUgc291cmNlIG1hcHNcbiAgLy8gYXJlIGludGVuZGVkIHRvIGJlIGNvbXByZXNzZWQgYW5kIGRlZHVwbGljYXRlZCwgdGhlIFR5cGVTY3JpcHQgY29tcGlsZXJcbiAgLy8gc29tZXRpbWVzIGdlbmVyYXRlcyBzb3VyY2UgbWFwcyB3aXRoIGR1cGxpY2F0ZXMgaW4gdGhlbS4gU2VlIEdpdGh1YiBpc3N1ZVxuICAvLyAjNzIgYW5kIGJ1Z3ppbC5sYS84ODk0OTIuXG4gIHRoaXMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KG5hbWVzLm1hcChTdHJpbmcpLCB0cnVlKTtcbiAgdGhpcy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShzb3VyY2VzLCB0cnVlKTtcblxuICB0aGlzLl9hYnNvbHV0ZVNvdXJjZXMgPSB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gdXRpbC5jb21wdXRlU291cmNlVVJMKHNvdXJjZVJvb3QsIHMsIGFTb3VyY2VNYXBVUkwpO1xuICB9KTtcblxuICB0aGlzLnNvdXJjZVJvb3QgPSBzb3VyY2VSb290O1xuICB0aGlzLnNvdXJjZXNDb250ZW50ID0gc291cmNlc0NvbnRlbnQ7XG4gIHRoaXMuX21hcHBpbmdzID0gbWFwcGluZ3M7XG4gIHRoaXMuX3NvdXJjZU1hcFVSTCA9IGFTb3VyY2VNYXBVUkw7XG4gIHRoaXMuZmlsZSA9IGZpbGU7XG59XG5cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGluZGV4IG9mIGEgc291cmNlLiAgUmV0dXJucyAtMSBpZiBub3RcbiAqIGZvdW5kLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZFNvdXJjZUluZGV4ID0gZnVuY3Rpb24oYVNvdXJjZSkge1xuICB2YXIgcmVsYXRpdmVTb3VyY2UgPSBhU291cmNlO1xuICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICByZWxhdGl2ZVNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCByZWxhdGl2ZVNvdXJjZSk7XG4gIH1cblxuICBpZiAodGhpcy5fc291cmNlcy5oYXMocmVsYXRpdmVTb3VyY2UpKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZXMuaW5kZXhPZihyZWxhdGl2ZVNvdXJjZSk7XG4gIH1cblxuICAvLyBNYXliZSBhU291cmNlIGlzIGFuIGFic29sdXRlIFVSTCBhcyByZXR1cm5lZCBieSB8c291cmNlc3wuICBJblxuICAvLyB0aGlzIGNhc2Ugd2UgY2FuJ3Qgc2ltcGx5IHVuZG8gdGhlIHRyYW5zZm9ybS5cbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9hYnNvbHV0ZVNvdXJjZXMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAodGhpcy5fYWJzb2x1dGVTb3VyY2VzW2ldID09IGFTb3VyY2UpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgQmFzaWNTb3VyY2VNYXBDb25zdW1lciBmcm9tIGEgU291cmNlTWFwR2VuZXJhdG9yLlxuICpcbiAqIEBwYXJhbSBTb3VyY2VNYXBHZW5lcmF0b3IgYVNvdXJjZU1hcFxuICogICAgICAgIFRoZSBzb3VyY2UgbWFwIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbiAqIEBwYXJhbSBTdHJpbmcgYVNvdXJjZU1hcFVSTFxuICogICAgICAgIFRoZSBVUkwgYXQgd2hpY2ggdGhlIHNvdXJjZSBtYXAgY2FuIGJlIGZvdW5kIChvcHRpb25hbClcbiAqIEByZXR1cm5zIEJhc2ljU291cmNlTWFwQ29uc3VtZXJcbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gICAgdmFyIHNtYyA9IE9iamVjdC5jcmVhdGUoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuXG4gICAgdmFyIG5hbWVzID0gc21jLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9uYW1lcy50b0FycmF5KCksIHRydWUpO1xuICAgIHZhciBzb3VyY2VzID0gc21jLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX3NvdXJjZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICBzbWMuc291cmNlUm9vdCA9IGFTb3VyY2VNYXAuX3NvdXJjZVJvb3Q7XG4gICAgc21jLnNvdXJjZXNDb250ZW50ID0gYVNvdXJjZU1hcC5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChzbWMuX3NvdXJjZXMudG9BcnJheSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21jLnNvdXJjZVJvb3QpO1xuICAgIHNtYy5maWxlID0gYVNvdXJjZU1hcC5fZmlsZTtcbiAgICBzbWMuX3NvdXJjZU1hcFVSTCA9IGFTb3VyY2VNYXBVUkw7XG4gICAgc21jLl9hYnNvbHV0ZVNvdXJjZXMgPSBzbWMuX3NvdXJjZXMudG9BcnJheSgpLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHV0aWwuY29tcHV0ZVNvdXJjZVVSTChzbWMuc291cmNlUm9vdCwgcywgYVNvdXJjZU1hcFVSTCk7XG4gICAgfSk7XG5cbiAgICAvLyBCZWNhdXNlIHdlIGFyZSBtb2RpZnlpbmcgdGhlIGVudHJpZXMgKGJ5IGNvbnZlcnRpbmcgc3RyaW5nIHNvdXJjZXMgYW5kXG4gICAgLy8gbmFtZXMgdG8gaW5kaWNlcyBpbnRvIHRoZSBzb3VyY2VzIGFuZCBuYW1lcyBBcnJheVNldHMpLCB3ZSBoYXZlIHRvIG1ha2VcbiAgICAvLyBhIGNvcHkgb2YgdGhlIGVudHJ5IG9yIGVsc2UgYmFkIHRoaW5ncyBoYXBwZW4uIFNoYXJlZCBtdXRhYmxlIHN0YXRlXG4gICAgLy8gc3RyaWtlcyBhZ2FpbiEgU2VlIGdpdGh1YiBpc3N1ZSAjMTkxLlxuXG4gICAgdmFyIGdlbmVyYXRlZE1hcHBpbmdzID0gYVNvdXJjZU1hcC5fbWFwcGluZ3MudG9BcnJheSgpLnNsaWNlKCk7XG4gICAgdmFyIGRlc3RHZW5lcmF0ZWRNYXBwaW5ncyA9IHNtYy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdmFyIGRlc3RPcmlnaW5hbE1hcHBpbmdzID0gc21jLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3JjTWFwcGluZyA9IGdlbmVyYXRlZE1hcHBpbmdzW2ldO1xuICAgICAgdmFyIGRlc3RNYXBwaW5nID0gbmV3IE1hcHBpbmc7XG4gICAgICBkZXN0TWFwcGluZy5nZW5lcmF0ZWRMaW5lID0gc3JjTWFwcGluZy5nZW5lcmF0ZWRMaW5lO1xuICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gc3JjTWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgIGlmIChzcmNNYXBwaW5nLnNvdXJjZSkge1xuICAgICAgICBkZXN0TWFwcGluZy5zb3VyY2UgPSBzb3VyY2VzLmluZGV4T2Yoc3JjTWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBkZXN0TWFwcGluZy5vcmlnaW5hbExpbmUgPSBzcmNNYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBzcmNNYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIGlmIChzcmNNYXBwaW5nLm5hbWUpIHtcbiAgICAgICAgICBkZXN0TWFwcGluZy5uYW1lID0gbmFtZXMuaW5kZXhPZihzcmNNYXBwaW5nLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzdE9yaWdpbmFsTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgICB9XG5cbiAgICAgIGRlc3RHZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKGRlc3RNYXBwaW5nKTtcbiAgICB9XG5cbiAgICBxdWlja1NvcnQoc21jLl9fb3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG5cbiAgICByZXR1cm4gc21jO1xuICB9O1xuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIFRoZSBsaXN0IG9mIG9yaWdpbmFsIHNvdXJjZXMuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9hYnNvbHV0ZVNvdXJjZXMuc2xpY2UoKTtcbiAgfVxufSk7XG5cbi8qKlxuICogUHJvdmlkZSB0aGUgSklUIHdpdGggYSBuaWNlIHNoYXBlIC8gaGlkZGVuIGNsYXNzLlxuICovXG5mdW5jdGlvbiBNYXBwaW5nKCkge1xuICB0aGlzLmdlbmVyYXRlZExpbmUgPSAwO1xuICB0aGlzLmdlbmVyYXRlZENvbHVtbiA9IDA7XG4gIHRoaXMuc291cmNlID0gbnVsbDtcbiAgdGhpcy5vcmlnaW5hbExpbmUgPSBudWxsO1xuICB0aGlzLm9yaWdpbmFsQ29sdW1uID0gbnVsbDtcbiAgdGhpcy5uYW1lID0gbnVsbDtcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cblxuY29uc3QgY29tcGFyZUdlbmVyYXRlZCA9IHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWROb0xpbmU7XG5mdW5jdGlvbiBzb3J0R2VuZXJhdGVkKGFycmF5LCBzdGFydCkge1xuICBsZXQgbCA9IGFycmF5Lmxlbmd0aDtcbiAgbGV0IG4gPSBhcnJheS5sZW5ndGggLSBzdGFydDtcbiAgaWYgKG4gPD0gMSkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChuID09IDIpIHtcbiAgICBsZXQgYSA9IGFycmF5W3N0YXJ0XTtcbiAgICBsZXQgYiA9IGFycmF5W3N0YXJ0ICsgMV07XG4gICAgaWYgKGNvbXBhcmVHZW5lcmF0ZWQoYSwgYikgPiAwKSB7XG4gICAgICBhcnJheVtzdGFydF0gPSBiO1xuICAgICAgYXJyYXlbc3RhcnQgKyAxXSA9IGE7XG4gICAgfVxuICB9IGVsc2UgaWYgKG4gPCAyMCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGw7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IGk7IGogPiBzdGFydDsgai0tKSB7XG4gICAgICAgIGxldCBhID0gYXJyYXlbaiAtIDFdO1xuICAgICAgICBsZXQgYiA9IGFycmF5W2pdO1xuICAgICAgICBpZiAoY29tcGFyZUdlbmVyYXRlZChhLCBiKSA8PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbaiAtIDFdID0gYjtcbiAgICAgICAgYXJyYXlbal0gPSBhO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBxdWlja1NvcnQoYXJyYXksIGNvbXBhcmVHZW5lcmF0ZWQsIHN0YXJ0KTtcbiAgfVxufVxuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdmFyIGdlbmVyYXRlZExpbmUgPSAxO1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gYVN0ci5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY2FjaGVkU2VnbWVudHMgPSB7fTtcbiAgICB2YXIgdGVtcCA9IHt9O1xuICAgIHZhciBvcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgdmFyIGdlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdmFyIG1hcHBpbmcsIHN0ciwgc2VnbWVudCwgZW5kLCB2YWx1ZTtcblxuICAgIGxldCBzdWJhcnJheVN0YXJ0ID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICc7Jykge1xuICAgICAgICBnZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcblxuICAgICAgICBzb3J0R2VuZXJhdGVkKGdlbmVyYXRlZE1hcHBpbmdzLCBzdWJhcnJheVN0YXJ0KTtcbiAgICAgICAgc3ViYXJyYXlTdGFydCA9IGdlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFTdHIuY2hhckF0KGluZGV4KSA9PT0gJywnKSB7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbWFwcGluZyA9IG5ldyBNYXBwaW5nKCk7XG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IGdlbmVyYXRlZExpbmU7XG5cbiAgICAgICAgZm9yIChlbmQgPSBpbmRleDsgZW5kIDwgbGVuZ3RoOyBlbmQrKykge1xuICAgICAgICAgIGlmICh0aGlzLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsIGVuZCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBhU3RyLnNsaWNlKGluZGV4LCBlbmQpO1xuXG4gICAgICAgIHNlZ21lbnQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kKSB7XG4gICAgICAgICAgYmFzZTY0VkxRLmRlY29kZShhU3RyLCBpbmRleCwgdGVtcCk7XG4gICAgICAgICAgdmFsdWUgPSB0ZW1wLnZhbHVlO1xuICAgICAgICAgIGluZGV4ID0gdGVtcC5yZXN0O1xuICAgICAgICAgIHNlZ21lbnQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlLCBidXQgbm8gbGluZSBhbmQgY29sdW1uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlIGFuZCBsaW5lLCBidXQgbm8gY29sdW1uJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZWQgY29sdW1uLlxuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uICsgc2VnbWVudFswXTtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgLy8gT3JpZ2luYWwgc291cmNlLlxuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gcHJldmlvdXNTb3VyY2UgKyBzZWdtZW50WzFdO1xuICAgICAgICAgIHByZXZpb3VzU291cmNlICs9IHNlZ21lbnRbMV07XG5cbiAgICAgICAgICAvLyBPcmlnaW5hbCBsaW5lLlxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gcHJldmlvdXNPcmlnaW5hbExpbmUgKyBzZWdtZW50WzJdO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgICAgLy8gTGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgKz0gMTtcblxuICAgICAgICAgIC8vIE9yaWdpbmFsIGNvbHVtbi5cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gcHJldmlvdXNPcmlnaW5hbENvbHVtbiArIHNlZ21lbnRbM107XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBuYW1lLlxuICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gcHJldmlvdXNOYW1lICsgc2VnbWVudFs0XTtcbiAgICAgICAgICAgIHByZXZpb3VzTmFtZSArPSBzZWdtZW50WzRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdlbmVyYXRlZE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgbGV0IGN1cnJlbnRTb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgICB3aGlsZSAob3JpZ2luYWxNYXBwaW5ncy5sZW5ndGggPD0gY3VycmVudFNvdXJjZSkge1xuICAgICAgICAgICAgb3JpZ2luYWxNYXBwaW5ncy5wdXNoKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3JpZ2luYWxNYXBwaW5nc1tjdXJyZW50U291cmNlXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgb3JpZ2luYWxNYXBwaW5nc1tjdXJyZW50U291cmNlXSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcmlnaW5hbE1hcHBpbmdzW2N1cnJlbnRTb3VyY2VdLnB1c2gobWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzb3J0R2VuZXJhdGVkKGdlbmVyYXRlZE1hcHBpbmdzLCBzdWJhcnJheVN0YXJ0KTtcbiAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBnZW5lcmF0ZWRNYXBwaW5ncztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JpZ2luYWxNYXBwaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG9yaWdpbmFsTWFwcGluZ3NbaV0gIT0gbnVsbCkge1xuICAgICAgICBxdWlja1NvcnQob3JpZ2luYWxNYXBwaW5nc1tpXSwgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9uc05vU291cmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXS5jb25jYXQoLi4ub3JpZ2luYWxNYXBwaW5ncyk7XG4gIH07XG5cbi8qKlxuICogRmluZCB0aGUgbWFwcGluZyB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgaHlwb3RoZXRpY2FsIFwibmVlZGxlXCIgbWFwcGluZyB0aGF0XG4gKiB3ZSBhcmUgc2VhcmNoaW5nIGZvciBpbiB0aGUgZ2l2ZW4gXCJoYXlzdGFja1wiIG9mIG1hcHBpbmdzLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9maW5kTWFwcGluZyhhTmVlZGxlLCBhTWFwcGluZ3MsIGFMaW5lTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbHVtbk5hbWUsIGFDb21wYXJhdG9yLCBhQmlhcykge1xuICAgIC8vIFRvIHJldHVybiB0aGUgcG9zaXRpb24gd2UgYXJlIHNlYXJjaGluZyBmb3IsIHdlIG11c3QgZmlyc3QgZmluZCB0aGVcbiAgICAvLyBtYXBwaW5nIGZvciB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHRoZW4gcmV0dXJuIHRoZSBvcHBvc2l0ZSBwb3NpdGlvbiBpdFxuICAgIC8vIHBvaW50cyB0by4gQmVjYXVzZSB0aGUgbWFwcGluZ3MgYXJlIHNvcnRlZCwgd2UgY2FuIHVzZSBiaW5hcnkgc2VhcmNoIHRvXG4gICAgLy8gZmluZCB0aGUgYmVzdCBtYXBwaW5nLlxuXG4gICAgaWYgKGFOZWVkbGVbYUxpbmVOYW1lXSA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMaW5lIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthTGluZU5hbWVdKTtcbiAgICB9XG4gICAgaWYgKGFOZWVkbGVbYUNvbHVtbk5hbWVdIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29sdW1uIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthQ29sdW1uTmFtZV0pO1xuICAgIH1cblxuICAgIHJldHVybiBiaW5hcnlTZWFyY2guc2VhcmNoKGFOZWVkbGUsIGFNYXBwaW5ncywgYUNvbXBhcmF0b3IsIGFCaWFzKTtcbiAgfTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBsYXN0IGNvbHVtbiBmb3IgZWFjaCBnZW5lcmF0ZWQgbWFwcGluZy4gVGhlIGxhc3QgY29sdW1uIGlzXG4gKiBpbmNsdXNpdmUuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbXB1dGVDb2x1bW5TcGFucyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NvbXB1dGVDb2x1bW5TcGFucygpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgLy8gTWFwcGluZ3MgZG8gbm90IGNvbnRhaW4gYSBmaWVsZCBmb3IgdGhlIGxhc3QgZ2VuZXJhdGVkIGNvbHVtbnQuIFdlXG4gICAgICAvLyBjYW4gY29tZSB1cCB3aXRoIGFuIG9wdGltaXN0aWMgZXN0aW1hdGUsIGhvd2V2ZXIsIGJ5IGFzc3VtaW5nIHRoYXRcbiAgICAgIC8vIG1hcHBpbmdzIGFyZSBjb250aWd1b3VzIChpLmUuIGdpdmVuIHR3byBjb25zZWN1dGl2ZSBtYXBwaW5ncywgdGhlXG4gICAgICAvLyBmaXJzdCBtYXBwaW5nIGVuZHMgd2hlcmUgdGhlIHNlY29uZCBvbmUgc3RhcnRzKS5cbiAgICAgIGlmIChpbmRleCArIDEgPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHRNYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXggKyAxXTtcblxuICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC0gMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgbGFzdCBtYXBwaW5nIGZvciBlYWNoIGxpbmUgc3BhbnMgdGhlIGVudGlyZSBsaW5lLlxuICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gSW5maW5pdHk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgbmVlZGxlLFxuICAgICAgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MsXG4gICAgICBcImdlbmVyYXRlZExpbmVcIixcbiAgICAgIFwiZ2VuZXJhdGVkQ29sdW1uXCIsXG4gICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkLFxuICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuYXQoc291cmNlKTtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwodGhpcy5zb3VyY2VSb290LCBzb3VyY2UsIHRoaXMuX3NvdXJjZU1hcFVSTCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbmFtZScsIG51bGwpO1xuICAgICAgICBpZiAobmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5hdChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbENvbHVtbicsIG51bGwpLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgIG5hbWU6IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcygpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnQubGVuZ3RoID49IHRoaXMuX3NvdXJjZXMuc2l6ZSgpICYmXG4gICAgICAhdGhpcy5zb3VyY2VzQ29udGVudC5zb21lKGZ1bmN0aW9uIChzYykgeyByZXR1cm4gc2MgPT0gbnVsbDsgfSk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gKiBhdmFpbGFibGUuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRTb3VyY2VJbmRleChhU291cmNlKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbaW5kZXhdO1xuICAgIH1cblxuICAgIHZhciByZWxhdGl2ZVNvdXJjZSA9IGFTb3VyY2U7XG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICByZWxhdGl2ZVNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCByZWxhdGl2ZVNvdXJjZSk7XG4gICAgfVxuXG4gICAgdmFyIHVybDtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGxcbiAgICAgICAgJiYgKHVybCA9IHV0aWwudXJsUGFyc2UodGhpcy5zb3VyY2VSb290KSkpIHtcbiAgICAgIC8vIFhYWDogZmlsZTovLyBVUklzIGFuZCBhYnNvbHV0ZSBwYXRocyBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IgZm9yXG4gICAgICAvLyBtYW55IHVzZXJzLiBXZSBjYW4gaGVscCB0aGVtIG91dCB3aGVuIHRoZXkgZXhwZWN0IGZpbGU6Ly8gVVJJcyB0b1xuICAgICAgLy8gYmVoYXZlIGxpa2UgaXQgd291bGQgaWYgdGhleSB3ZXJlIHJ1bm5pbmcgYSBsb2NhbCBIVFRQIHNlcnZlci4gU2VlXG4gICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04ODU1OTcuXG4gICAgICB2YXIgZmlsZVVyaUFic1BhdGggPSByZWxhdGl2ZVNvdXJjZS5yZXBsYWNlKC9eZmlsZTpcXC9cXC8vLCBcIlwiKTtcbiAgICAgIGlmICh1cmwuc2NoZW1lID09IFwiZmlsZVwiXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoZmlsZVVyaUFic1BhdGgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihmaWxlVXJpQWJzUGF0aCldXG4gICAgICB9XG5cbiAgICAgIGlmICgoIXVybC5wYXRoIHx8IHVybC5wYXRoID09IFwiL1wiKVxuICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKFwiL1wiICsgcmVsYXRpdmVTb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihcIi9cIiArIHJlbGF0aXZlU291cmNlKV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHJlY3Vyc2l2ZWx5IGZyb21cbiAgICAvLyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IuIEluIHRoYXQgY2FzZSwgd2VcbiAgICAvLyBkb24ndCB3YW50IHRvIHRocm93IGlmIHdlIGNhbid0IGZpbmQgdGhlIHNvdXJjZSAtIHdlIGp1c3Qgd2FudCB0b1xuICAgIC8vIHJldHVybiBudWxsLCBzbyB3ZSBwcm92aWRlIGEgZmxhZyB0byBleGl0IGdyYWNlZnVsbHkuXG4gICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgcmVsYXRpdmVTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyk7XG4gICAgc291cmNlID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KHNvdXJjZSk7XG4gICAgaWYgKHNvdXJjZSA8IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBvcmlnaW5hbExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gbmVlZGxlLnNvdXJjZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbmV4cG9ydHMuQmFzaWNTb3VyY2VNYXBDb25zdW1lciA9IEJhc2ljU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQW4gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaFxuICogd2UgY2FuIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbi4gSXQgZGlmZmVycyBmcm9tIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5cbiAqIHRoYXQgaXQgdGFrZXMgXCJpbmRleGVkXCIgc291cmNlIG1hcHMgKGkuZS4gb25lcyB3aXRoIGEgXCJzZWN0aW9uc1wiIGZpZWxkKSBhc1xuICogaW5wdXQuXG4gKlxuICogVGhlIGZpcnN0IHBhcmFtZXRlciBpcyBhIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3IgYWxyZWFkeVxuICogcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYyBmb3IgaW5kZXhlZCBzb3VyY2UgbWFwcywgdGhleVxuICogaGF2ZSB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICogICAtIHNlY3Rpb25zOiBBIGxpc3Qgb2Ygc2VjdGlvbiBkZWZpbml0aW9ucy5cbiAqXG4gKiBFYWNoIHZhbHVlIHVuZGVyIHRoZSBcInNlY3Rpb25zXCIgZmllbGQgaGFzIHR3byBmaWVsZHM6XG4gKiAgIC0gb2Zmc2V0OiBUaGUgb2Zmc2V0IGludG8gdGhlIG9yaWdpbmFsIHNwZWNpZmllZCBhdCB3aGljaCB0aGlzIHNlY3Rpb25cbiAqICAgICAgIGJlZ2lucyB0byBhcHBseSwgZGVmaW5lZCBhcyBhbiBvYmplY3Qgd2l0aCBhIFwibGluZVwiIGFuZCBcImNvbHVtblwiXG4gKiAgICAgICBmaWVsZC5cbiAqICAgLSBtYXA6IEEgc291cmNlIG1hcCBkZWZpbml0aW9uLiBUaGlzIHNvdXJjZSBtYXAgY291bGQgYWxzbyBiZSBpbmRleGVkLFxuICogICAgICAgYnV0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbiAqXG4gKiBJbnN0ZWFkIG9mIHRoZSBcIm1hcFwiIGZpZWxkLCBpdCdzIGFsc28gcG9zc2libGUgdG8gaGF2ZSBhIFwidXJsXCIgZmllbGRcbiAqIHNwZWNpZnlpbmcgYSBVUkwgdG8gcmV0cmlldmUgYSBzb3VyY2UgbWFwIGZyb20sIGJ1dCB0aGF0J3MgY3VycmVudGx5XG4gKiB1bnN1cHBvcnRlZC5cbiAqXG4gKiBIZXJlJ3MgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF0sIGJ1dFxuICogbW9kaWZpZWQgdG8gb21pdCBhIHNlY3Rpb24gd2hpY2ggdXNlcyB0aGUgXCJ1cmxcIiBmaWVsZC5cbiAqXG4gKiAge1xuICogICAgdmVyc2lvbiA6IDMsXG4gKiAgICBmaWxlOiBcImFwcC5qc1wiLFxuICogICAgc2VjdGlvbnM6IFt7XG4gKiAgICAgIG9mZnNldDoge2xpbmU6MTAwLCBjb2x1bW46MTB9LFxuICogICAgICBtYXA6IHtcbiAqICAgICAgICB2ZXJzaW9uIDogMyxcbiAqICAgICAgICBmaWxlOiBcInNlY3Rpb24uanNcIixcbiAqICAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gKiAgICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gKiAgICAgICAgbWFwcGluZ3M6IFwiQUFBQSxFOztBQkNERTtcIlxuICogICAgICB9XG4gKiAgICB9XSxcbiAqICB9XG4gKlxuICogVGhlIHNlY29uZCBwYXJhbWV0ZXIsIGlmIGdpdmVuLCBpcyBhIHN0cmluZyB3aG9zZSB2YWx1ZSBpcyB0aGUgVVJMXG4gKiBhdCB3aGljaCB0aGUgc291cmNlIG1hcCB3YXMgZm91bmQuICBUaGlzIFVSTCBpcyB1c2VkIHRvIGNvbXB1dGUgdGhlXG4gKiBzb3VyY2VzIGFycmF5LlxuICpcbiAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0I2hlYWRpbmc9aC41MzVlczN4ZXByZ3RcbiAqL1xuZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSB1dGlsLnBhcnNlU291cmNlTWFwSW5wdXQoYVNvdXJjZU1hcCk7XG4gIH1cblxuICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgdmFyIHNlY3Rpb25zID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc2VjdGlvbnMnKTtcblxuICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgdmFyIGxhc3RPZmZzZXQgPSB7XG4gICAgbGluZTogLTEsXG4gICAgY29sdW1uOiAwXG4gIH07XG4gIHRoaXMuX3NlY3Rpb25zID0gc2VjdGlvbnMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgaWYgKHMudXJsKSB7XG4gICAgICAvLyBUaGUgdXJsIGZpZWxkIHdpbGwgcmVxdWlyZSBzdXBwb3J0IGZvciBhc3luY2hyb25pY2l0eS5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8xNlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwb3J0IGZvciB1cmwgZmllbGQgaW4gc2VjdGlvbnMgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0ID0gdXRpbC5nZXRBcmcocywgJ29mZnNldCcpO1xuICAgIHZhciBvZmZzZXRMaW5lID0gdXRpbC5nZXRBcmcob2Zmc2V0LCAnbGluZScpO1xuICAgIHZhciBvZmZzZXRDb2x1bW4gPSB1dGlsLmdldEFyZyhvZmZzZXQsICdjb2x1bW4nKTtcblxuICAgIGlmIChvZmZzZXRMaW5lIDwgbGFzdE9mZnNldC5saW5lIHx8XG4gICAgICAgIChvZmZzZXRMaW5lID09PSBsYXN0T2Zmc2V0LmxpbmUgJiYgb2Zmc2V0Q29sdW1uIDwgbGFzdE9mZnNldC5jb2x1bW4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3Rpb24gb2Zmc2V0cyBtdXN0IGJlIG9yZGVyZWQgYW5kIG5vbi1vdmVybGFwcGluZy4nKTtcbiAgICB9XG4gICAgbGFzdE9mZnNldCA9IG9mZnNldDtcblxuICAgIHJldHVybiB7XG4gICAgICBnZW5lcmF0ZWRPZmZzZXQ6IHtcbiAgICAgICAgLy8gVGhlIG9mZnNldCBmaWVsZHMgYXJlIDAtYmFzZWQsIGJ1dCB3ZSB1c2UgMS1iYXNlZCBpbmRpY2VzIHdoZW5cbiAgICAgICAgLy8gZW5jb2RpbmcvZGVjb2RpbmcgZnJvbSBWTFEuXG4gICAgICAgIGdlbmVyYXRlZExpbmU6IG9mZnNldExpbmUgKyAxLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG9mZnNldENvbHVtbiArIDFcbiAgICAgIH0sXG4gICAgICBjb25zdW1lcjogbmV3IFNvdXJjZU1hcENvbnN1bWVyKHV0aWwuZ2V0QXJnKHMsICdtYXAnKSwgYVNvdXJjZU1hcFVSTClcbiAgICB9XG4gIH0pO1xufVxuXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBzb3VyY2VzLnB1c2godGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlc1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VzO1xuICB9XG59KTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4gIFRoZSBjb2x1bW5cbiAqICAgICBudW1iZXIgaXMgMC1iYXNlZC5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICAvLyBGaW5kIHRoZSBzZWN0aW9uIGNvbnRhaW5pbmcgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbiB3ZSdyZSB0cnlpbmcgdG8gbWFwXG4gICAgLy8gdG8gYW4gb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgdmFyIHNlY3Rpb25JbmRleCA9IGJpbmFyeVNlYXJjaC5zZWFyY2gobmVlZGxlLCB0aGlzLl9zZWN0aW9ucyxcbiAgICAgIGZ1bmN0aW9uKG5lZWRsZSwgc2VjdGlvbikge1xuICAgICAgICB2YXIgY21wID0gbmVlZGxlLmdlbmVyYXRlZExpbmUgLSBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lO1xuICAgICAgICBpZiAoY21wKSB7XG4gICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgIH0pO1xuICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbc2VjdGlvbkluZGV4XTtcblxuICAgIGlmICghc2VjdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb24uY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICBsaW5lOiBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICBjb2x1bW46IG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmVcbiAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgOiAwKSxcbiAgICAgIGJpYXM6IGFBcmdzLmJpYXNcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWN0aW9ucy5ldmVyeShmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHMuY29uc3VtZXIuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKTtcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIHZhciBjb250ZW50ID0gc2VjdGlvbi5jb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIHRydWUpO1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuIFxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIC8vIE9ubHkgY29uc2lkZXIgdGhpcyBzZWN0aW9uIGlmIHRoZSByZXF1ZXN0ZWQgc291cmNlIGlzIGluIHRoZSBsaXN0IG9mXG4gICAgICAvLyBzb3VyY2VzIG9mIHRoZSBjb25zdW1lci5cbiAgICAgIGlmIChzZWN0aW9uLmNvbnN1bWVyLl9maW5kU291cmNlSW5kZXgodXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSkgPT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGdlbmVyYXRlZFBvc2l0aW9uID0gc2VjdGlvbi5jb25zdW1lci5nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncyk7XG4gICAgICBpZiAoZ2VuZXJhdGVkUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWRQb3NpdGlvbi5jb2x1bW4gK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmVcbiAgICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgICA6IDApXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuICAgICAgdmFyIHNlY3Rpb25NYXBwaW5ncyA9IHNlY3Rpb24uY29uc3VtZXIuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWN0aW9uTWFwcGluZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBzZWN0aW9uTWFwcGluZ3Nbal07XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IHNlY3Rpb24uY29uc3VtZXIuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290LCBzb3VyY2UsIHRoaXMuX3NvdXJjZU1hcFVSTCk7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuXG4gICAgICAgIHZhciBuYW1lID0gbnVsbDtcbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSkge1xuICAgICAgICAgIG5hbWUgPSBzZWN0aW9uLmNvbnN1bWVyLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBtYXBwaW5ncyBjb21pbmcgZnJvbSB0aGUgY29uc3VtZXIgZm9yIHRoZSBzZWN0aW9uIGhhdmVcbiAgICAgICAgLy8gZ2VuZXJhdGVkIHBvc2l0aW9ucyByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIHNlY3Rpb24sIHNvIHdlXG4gICAgICAgIC8vIG5lZWQgdG8gb2Zmc2V0IHRoZW0gdG8gYmUgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb25jYXRlbmF0ZWRcbiAgICAgICAgLy8gZ2VuZXJhdGVkIGZpbGUuXG4gICAgICAgIHZhciBhZGp1c3RlZE1hcHBpbmcgPSB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbWFwcGluZy5nZW5lcmF0ZWRMaW5lXG4gICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgIDogMCksXG4gICAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhZGp1c3RlZE1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHF1aWNrU29ydCh0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgIHF1aWNrU29ydCh0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gIH07XG5cbmV4cG9ydHMuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyID0gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyO1xuIl0sIm5hbWVzIjpbInV0aWwiLCJyZXF1aXJlIiwiYmluYXJ5U2VhcmNoIiwiQXJyYXlTZXQiLCJiYXNlNjRWTFEiLCJxdWlja1NvcnQiLCJTb3VyY2VNYXBDb25zdW1lciIsImFTb3VyY2VNYXAiLCJhU291cmNlTWFwVVJMIiwic291cmNlTWFwIiwicGFyc2VTb3VyY2VNYXBJbnB1dCIsInNlY3Rpb25zIiwiSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyIiwiQmFzaWNTb3VyY2VNYXBDb25zdW1lciIsImZyb21Tb3VyY2VNYXAiLCJwcm90b3R5cGUiLCJfdmVyc2lvbiIsIl9fZ2VuZXJhdGVkTWFwcGluZ3MiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJfcGFyc2VNYXBwaW5ncyIsIl9tYXBwaW5ncyIsInNvdXJjZVJvb3QiLCJfX29yaWdpbmFsTWFwcGluZ3MiLCJfY2hhcklzTWFwcGluZ1NlcGFyYXRvciIsIlNvdXJjZU1hcENvbnN1bWVyX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IiLCJhU3RyIiwiaW5kZXgiLCJjIiwiY2hhckF0IiwiU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyIsImFTb3VyY2VSb290IiwiRXJyb3IiLCJHRU5FUkFURURfT1JERVIiLCJPUklHSU5BTF9PUkRFUiIsIkdSRUFURVNUX0xPV0VSX0JPVU5EIiwiTEVBU1RfVVBQRVJfQk9VTkQiLCJlYWNoTWFwcGluZyIsIlNvdXJjZU1hcENvbnN1bWVyX2VhY2hNYXBwaW5nIiwiYUNhbGxiYWNrIiwiYUNvbnRleHQiLCJhT3JkZXIiLCJjb250ZXh0Iiwib3JkZXIiLCJtYXBwaW5ncyIsIl9nZW5lcmF0ZWRNYXBwaW5ncyIsIl9vcmlnaW5hbE1hcHBpbmdzIiwiYm91bmRDYWxsYmFjayIsImJpbmQiLCJuYW1lcyIsIl9uYW1lcyIsInNvdXJjZXMiLCJfc291cmNlcyIsInNvdXJjZU1hcFVSTCIsIl9zb3VyY2VNYXBVUkwiLCJpIiwibiIsImxlbmd0aCIsIm1hcHBpbmciLCJzb3VyY2UiLCJhdCIsImNvbXB1dGVTb3VyY2VVUkwiLCJnZW5lcmF0ZWRMaW5lIiwiZ2VuZXJhdGVkQ29sdW1uIiwib3JpZ2luYWxMaW5lIiwib3JpZ2luYWxDb2x1bW4iLCJuYW1lIiwiYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yIiwiU291cmNlTWFwQ29uc3VtZXJfYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yIiwiYUFyZ3MiLCJsaW5lIiwiZ2V0QXJnIiwibmVlZGxlIiwiX2ZpbmRTb3VyY2VJbmRleCIsIl9maW5kTWFwcGluZyIsImNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zIiwiY29sdW1uIiwidW5kZWZpbmVkIiwicHVzaCIsImxhc3RDb2x1bW4iLCJleHBvcnRzIiwidmVyc2lvbiIsInNvdXJjZXNDb250ZW50IiwiZmlsZSIsIm5vcm1hbGl6ZSIsIm1hcCIsIlN0cmluZyIsImlzQWJzb2x1dGUiLCJyZWxhdGl2ZSIsImZyb21BcnJheSIsIl9hYnNvbHV0ZVNvdXJjZXMiLCJ0b0FycmF5IiwicyIsImNyZWF0ZSIsImNvbnN1bWVyIiwiYVNvdXJjZSIsInJlbGF0aXZlU291cmNlIiwiaGFzIiwiaW5kZXhPZiIsIlNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAiLCJzbWMiLCJfc291cmNlUm9vdCIsIl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50IiwiX2ZpbGUiLCJnZW5lcmF0ZWRNYXBwaW5ncyIsInNsaWNlIiwiZGVzdEdlbmVyYXRlZE1hcHBpbmdzIiwiZGVzdE9yaWdpbmFsTWFwcGluZ3MiLCJzcmNNYXBwaW5nIiwiZGVzdE1hcHBpbmciLCJNYXBwaW5nIiwiY29tcGFyZUdlbmVyYXRlZCIsImNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkTm9MaW5lIiwic29ydEdlbmVyYXRlZCIsImFycmF5Iiwic3RhcnQiLCJsIiwiYSIsImIiLCJqIiwicHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4iLCJwcmV2aW91c09yaWdpbmFsTGluZSIsInByZXZpb3VzT3JpZ2luYWxDb2x1bW4iLCJwcmV2aW91c1NvdXJjZSIsInByZXZpb3VzTmFtZSIsImNhY2hlZFNlZ21lbnRzIiwidGVtcCIsIm9yaWdpbmFsTWFwcGluZ3MiLCJzdHIiLCJzZWdtZW50IiwiZW5kIiwidmFsdWUiLCJzdWJhcnJheVN0YXJ0IiwiZGVjb2RlIiwicmVzdCIsImN1cnJlbnRTb3VyY2UiLCJjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9uc05vU291cmNlIiwiY29uY2F0IiwiU291cmNlTWFwQ29uc3VtZXJfZmluZE1hcHBpbmciLCJhTmVlZGxlIiwiYU1hcHBpbmdzIiwiYUxpbmVOYW1lIiwiYUNvbHVtbk5hbWUiLCJhQ29tcGFyYXRvciIsImFCaWFzIiwiVHlwZUVycm9yIiwic2VhcmNoIiwiY29tcHV0ZUNvbHVtblNwYW5zIiwiU291cmNlTWFwQ29uc3VtZXJfY29tcHV0ZUNvbHVtblNwYW5zIiwibmV4dE1hcHBpbmciLCJsYXN0R2VuZXJhdGVkQ29sdW1uIiwiSW5maW5pdHkiLCJvcmlnaW5hbFBvc2l0aW9uRm9yIiwiU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvciIsImNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkIiwiaGFzQ29udGVudHNPZkFsbFNvdXJjZXMiLCJCYXNpY1NvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzIiwic2l6ZSIsInNvbWUiLCJzYyIsInNvdXJjZUNvbnRlbnRGb3IiLCJTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yIiwibnVsbE9uTWlzc2luZyIsInVybCIsInVybFBhcnNlIiwiZmlsZVVyaUFic1BhdGgiLCJyZXBsYWNlIiwic2NoZW1lIiwicGF0aCIsImdlbmVyYXRlZFBvc2l0aW9uRm9yIiwiU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IiLCJsYXN0T2Zmc2V0IiwiX3NlY3Rpb25zIiwib2Zmc2V0Iiwib2Zmc2V0TGluZSIsIm9mZnNldENvbHVtbiIsImdlbmVyYXRlZE9mZnNldCIsImNvbnN0cnVjdG9yIiwiSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IiLCJzZWN0aW9uSW5kZXgiLCJzZWN0aW9uIiwiY21wIiwiYmlhcyIsIkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcyIsImV2ZXJ5IiwiSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IiLCJjb250ZW50IiwiSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yIiwiZ2VuZXJhdGVkUG9zaXRpb24iLCJyZXQiLCJJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyIsInNlY3Rpb25NYXBwaW5ncyIsImFkZCIsImFkanVzdGVkTWFwcGluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../source-map-js/lib/source-map-consumer.js\n");

/***/ }),

/***/ "(rsc)/../source-map-js/lib/source-map-consumer.js":
/*!***************************************************!*\
  !*** ../source-map-js/lib/source-map-consumer.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var util = __webpack_require__(/*! ./util */ \"(rsc)/../source-map-js/lib/util.js\");\nvar binarySearch = __webpack_require__(/*! ./binary-search */ \"(rsc)/../source-map-js/lib/binary-search.js\");\nvar ArraySet = (__webpack_require__(/*! ./array-set */ \"(rsc)/../source-map-js/lib/array-set.js\").ArraySet);\nvar base64VLQ = __webpack_require__(/*! ./base64-vlq */ \"(rsc)/../source-map-js/lib/base64-vlq.js\");\nvar quickSort = (__webpack_require__(/*! ./quick-sort */ \"(rsc)/../source-map-js/lib/quick-sort.js\").quickSort);\nfunction SourceMapConsumer(aSourceMap, aSourceMapURL) {\n    var sourceMap = aSourceMap;\n    if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n    }\n    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n}\nSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {\n    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n};\n/**\n * The version of the source mapping spec that we are consuming.\n */ SourceMapConsumer.prototype._version = 3;\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, \"_generatedMappings\", {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n        if (!this.__generatedMappings) {\n            this._parseMappings(this._mappings, this.sourceRoot);\n        }\n        return this.__generatedMappings;\n    }\n});\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, \"_originalMappings\", {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n        if (!this.__originalMappings) {\n            this._parseMappings(this._mappings, this.sourceRoot);\n        }\n        return this.__originalMappings;\n    }\n});\nSourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n};\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */ SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n};\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */ SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n    var mappings;\n    switch(order){\n        case SourceMapConsumer.GENERATED_ORDER:\n            mappings = this._generatedMappings;\n            break;\n        case SourceMapConsumer.ORIGINAL_ORDER:\n            mappings = this._originalMappings;\n            break;\n        default:\n            throw new Error(\"Unknown order of iteration.\");\n    }\n    var sourceRoot = this.sourceRoot;\n    var boundCallback = aCallback.bind(context);\n    var names = this._names;\n    var sources = this._sources;\n    var sourceMapURL = this._sourceMapURL;\n    for(var i = 0, n = mappings.length; i < n; i++){\n        var mapping = mappings[i];\n        var source = mapping.source === null ? null : sources.at(mapping.source);\n        source = util.computeSourceURL(sourceRoot, source, sourceMapURL);\n        boundCallback({\n            source: source,\n            generatedLine: mapping.generatedLine,\n            generatedColumn: mapping.generatedColumn,\n            originalLine: mapping.originalLine,\n            originalColumn: mapping.originalColumn,\n            name: mapping.name === null ? null : names.at(mapping.name)\n        });\n    }\n};\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number is 1-based.\n *   - column: Optional. the column number in the original source.\n *    The column number is 0-based.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *    line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *    The column number is 0-based.\n */ SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, \"line\");\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n        source: util.getArg(aArgs, \"source\"),\n        originalLine: line,\n        originalColumn: util.getArg(aArgs, \"column\", 0)\n    };\n    needle.source = this._findSourceIndex(needle.source);\n    if (needle.source < 0) {\n        return [];\n    }\n    var mappings = [];\n    var index = this._findMapping(needle, this._originalMappings, \"originalLine\", \"originalColumn\", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n        var mapping = this._originalMappings[index];\n        if (aArgs.column === undefined) {\n            var originalLine = mapping.originalLine;\n            // Iterate until either we run out of mappings, or we run into\n            // a mapping for a different line than the one we found. Since\n            // mappings are sorted, this is guaranteed to find all mappings for\n            // the line we found.\n            while(mapping && mapping.originalLine === originalLine){\n                mappings.push({\n                    line: util.getArg(mapping, \"generatedLine\", null),\n                    column: util.getArg(mapping, \"generatedColumn\", null),\n                    lastColumn: util.getArg(mapping, \"lastGeneratedColumn\", null)\n                });\n                mapping = this._originalMappings[++index];\n            }\n        } else {\n            var originalColumn = mapping.originalColumn;\n            // Iterate until either we run out of mappings, or we run into\n            // a mapping for a different line than the one we were searching for.\n            // Since mappings are sorted, this is guaranteed to find all mappings for\n            // the line we are searching for.\n            while(mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn){\n                mappings.push({\n                    line: util.getArg(mapping, \"generatedLine\", null),\n                    column: util.getArg(mapping, \"generatedColumn\", null),\n                    lastColumn: util.getArg(mapping, \"lastGeneratedColumn\", null)\n                });\n                mapping = this._originalMappings[++index];\n            }\n        }\n    }\n    return mappings;\n};\nexports.SourceMapConsumer = SourceMapConsumer;\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */ function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\n    var sourceMap = aSourceMap;\n    if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n    }\n    var version = util.getArg(sourceMap, \"version\");\n    var sources = util.getArg(sourceMap, \"sources\");\n    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n    // requires the array) to play nice here.\n    var names = util.getArg(sourceMap, \"names\", []);\n    var sourceRoot = util.getArg(sourceMap, \"sourceRoot\", null);\n    var sourcesContent = util.getArg(sourceMap, \"sourcesContent\", null);\n    var mappings = util.getArg(sourceMap, \"mappings\");\n    var file = util.getArg(sourceMap, \"file\", null);\n    // Once again, Sass deviates from the spec and supplies the version as a\n    // string rather than a number, so we use loose equality checking here.\n    if (version != this._version) {\n        throw new Error(\"Unsupported version: \" + version);\n    }\n    if (sourceRoot) {\n        sourceRoot = util.normalize(sourceRoot);\n    }\n    sources = sources.map(String)// Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)// Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function(source) {\n        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;\n    });\n    // Pass `true` below to allow duplicate names and sources. While source maps\n    // are intended to be compressed and deduplicated, the TypeScript compiler\n    // sometimes generates source maps with duplicates in them. See Github issue\n    // #72 and bugzil.la/889492.\n    this._names = ArraySet.fromArray(names.map(String), true);\n    this._sources = ArraySet.fromArray(sources, true);\n    this._absoluteSources = this._sources.toArray().map(function(s) {\n        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n    });\n    this.sourceRoot = sourceRoot;\n    this.sourcesContent = sourcesContent;\n    this._mappings = mappings;\n    this._sourceMapURL = aSourceMapURL;\n    this.file = file;\n}\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n/**\n * Utility function to find the index of a source.  Returns -1 if not\n * found.\n */ BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {\n    var relativeSource = aSource;\n    if (this.sourceRoot != null) {\n        relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n    if (this._sources.has(relativeSource)) {\n        return this._sources.indexOf(relativeSource);\n    }\n    // Maybe aSource is an absolute URL as returned by |sources|.  In\n    // this case we can't simply undo the transform.\n    var i;\n    for(i = 0; i < this._absoluteSources.length; ++i){\n        if (this._absoluteSources[i] == aSource) {\n            return i;\n        }\n    }\n    return -1;\n};\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @param String aSourceMapURL\n *        The URL at which the source map can be found (optional)\n * @returns BasicSourceMapConsumer\n */ BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);\n    smc.file = aSourceMap._file;\n    smc._sourceMapURL = aSourceMapURL;\n    smc._absoluteSources = smc._sources.toArray().map(function(s) {\n        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);\n    });\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n    for(var i = 0, length = generatedMappings.length; i < length; i++){\n        var srcMapping = generatedMappings[i];\n        var destMapping = new Mapping;\n        destMapping.generatedLine = srcMapping.generatedLine;\n        destMapping.generatedColumn = srcMapping.generatedColumn;\n        if (srcMapping.source) {\n            destMapping.source = sources.indexOf(srcMapping.source);\n            destMapping.originalLine = srcMapping.originalLine;\n            destMapping.originalColumn = srcMapping.originalColumn;\n            if (srcMapping.name) {\n                destMapping.name = names.indexOf(srcMapping.name);\n            }\n            destOriginalMappings.push(destMapping);\n        }\n        destGeneratedMappings.push(destMapping);\n    }\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n    return smc;\n};\n/**\n * The version of the source mapping spec that we are consuming.\n */ BasicSourceMapConsumer.prototype._version = 3;\n/**\n * The list of original sources.\n */ Object.defineProperty(BasicSourceMapConsumer.prototype, \"sources\", {\n    get: function() {\n        return this._absoluteSources.slice();\n    }\n});\n/**\n * Provide the JIT with a nice shape / hidden class.\n */ function Mapping() {\n    this.generatedLine = 0;\n    this.generatedColumn = 0;\n    this.source = null;\n    this.originalLine = null;\n    this.originalColumn = null;\n    this.name = null;\n}\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */ const compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;\nfunction sortGenerated(array, start) {\n    let l = array.length;\n    let n = array.length - start;\n    if (n <= 1) {\n        return;\n    } else if (n == 2) {\n        let a = array[start];\n        let b = array[start + 1];\n        if (compareGenerated(a, b) > 0) {\n            array[start] = b;\n            array[start + 1] = a;\n        }\n    } else if (n < 20) {\n        for(let i = start; i < l; i++){\n            for(let j = i; j > start; j--){\n                let a = array[j - 1];\n                let b = array[j];\n                if (compareGenerated(a, b) <= 0) {\n                    break;\n                }\n                array[j - 1] = b;\n                array[j] = a;\n            }\n        }\n    } else {\n        quickSort(array, compareGenerated, start);\n    }\n}\nBasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n    let subarrayStart = 0;\n    while(index < length){\n        if (aStr.charAt(index) === \";\") {\n            generatedLine++;\n            index++;\n            previousGeneratedColumn = 0;\n            sortGenerated(generatedMappings, subarrayStart);\n            subarrayStart = generatedMappings.length;\n        } else if (aStr.charAt(index) === \",\") {\n            index++;\n        } else {\n            mapping = new Mapping();\n            mapping.generatedLine = generatedLine;\n            for(end = index; end < length; end++){\n                if (this._charIsMappingSeparator(aStr, end)) {\n                    break;\n                }\n            }\n            str = aStr.slice(index, end);\n            segment = [];\n            while(index < end){\n                base64VLQ.decode(aStr, index, temp);\n                value = temp.value;\n                index = temp.rest;\n                segment.push(value);\n            }\n            if (segment.length === 2) {\n                throw new Error(\"Found a source, but no line and column\");\n            }\n            if (segment.length === 3) {\n                throw new Error(\"Found a source and line, but no column\");\n            }\n            // Generated column.\n            mapping.generatedColumn = previousGeneratedColumn + segment[0];\n            previousGeneratedColumn = mapping.generatedColumn;\n            if (segment.length > 1) {\n                // Original source.\n                mapping.source = previousSource + segment[1];\n                previousSource += segment[1];\n                // Original line.\n                mapping.originalLine = previousOriginalLine + segment[2];\n                previousOriginalLine = mapping.originalLine;\n                // Lines are stored 0-based\n                mapping.originalLine += 1;\n                // Original column.\n                mapping.originalColumn = previousOriginalColumn + segment[3];\n                previousOriginalColumn = mapping.originalColumn;\n                if (segment.length > 4) {\n                    // Original name.\n                    mapping.name = previousName + segment[4];\n                    previousName += segment[4];\n                }\n            }\n            generatedMappings.push(mapping);\n            if (typeof mapping.originalLine === \"number\") {\n                let currentSource = mapping.source;\n                while(originalMappings.length <= currentSource){\n                    originalMappings.push(null);\n                }\n                if (originalMappings[currentSource] === null) {\n                    originalMappings[currentSource] = [];\n                }\n                originalMappings[currentSource].push(mapping);\n            }\n        }\n    }\n    sortGenerated(generatedMappings, subarrayStart);\n    this.__generatedMappings = generatedMappings;\n    for(var i = 0; i < originalMappings.length; i++){\n        if (originalMappings[i] != null) {\n            quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);\n        }\n    }\n    this.__originalMappings = [].concat(...originalMappings);\n};\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */ BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n    if (aNeedle[aLineName] <= 0) {\n        throw new TypeError(\"Line must be greater than or equal to 1, got \" + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n        throw new TypeError(\"Column must be greater than or equal to 0, got \" + aNeedle[aColumnName]);\n    }\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n};\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */ BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {\n    for(var index = 0; index < this._generatedMappings.length; ++index){\n        var mapping = this._generatedMappings[index];\n        // Mappings do not contain a field for the last generated columnt. We\n        // can come up with an optimistic estimate, however, by assuming that\n        // mappings are contiguous (i.e. given two consecutive mappings, the\n        // first mapping ends where the second one starts).\n        if (index + 1 < this._generatedMappings.length) {\n            var nextMapping = this._generatedMappings[index + 1];\n            if (mapping.generatedLine === nextMapping.generatedLine) {\n                mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n                continue;\n            }\n        }\n        // The last mapping for each line spans the entire line.\n        mapping.lastGeneratedColumn = Infinity;\n    }\n};\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */ BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n        generatedLine: util.getArg(aArgs, \"line\"),\n        generatedColumn: util.getArg(aArgs, \"column\")\n    };\n    var index = this._findMapping(needle, this._generatedMappings, \"generatedLine\", \"generatedColumn\", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND));\n    if (index >= 0) {\n        var mapping = this._generatedMappings[index];\n        if (mapping.generatedLine === needle.generatedLine) {\n            var source = util.getArg(mapping, \"source\", null);\n            if (source !== null) {\n                source = this._sources.at(source);\n                source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n            }\n            var name = util.getArg(mapping, \"name\", null);\n            if (name !== null) {\n                name = this._names.at(name);\n            }\n            return {\n                source: source,\n                line: util.getArg(mapping, \"originalLine\", null),\n                column: util.getArg(mapping, \"originalColumn\", null),\n                name: name\n            };\n        }\n    }\n    return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n    };\n};\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */ BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n        return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {\n        return sc == null;\n    });\n};\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */ BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n        return null;\n    }\n    var index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n        return this.sourcesContent[index];\n    }\n    var relativeSource = aSource;\n    if (this.sourceRoot != null) {\n        relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n    var url;\n    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {\n        // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n        // many users. We can help them out when they expect file:// URIs to\n        // behave like it would if they were running a local HTTP server. See\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n        var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n        if (url.scheme == \"file\" && this._sources.has(fileUriAbsPath)) {\n            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n        }\n        if ((!url.path || url.path == \"/\") && this._sources.has(\"/\" + relativeSource)) {\n            return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n        }\n    }\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n        return null;\n    } else {\n        throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n    }\n};\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */ BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, \"source\");\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n        return {\n            line: null,\n            column: null,\n            lastColumn: null\n        };\n    }\n    var needle = {\n        source: source,\n        originalLine: util.getArg(aArgs, \"line\"),\n        originalColumn: util.getArg(aArgs, \"column\")\n    };\n    var index = this._findMapping(needle, this._originalMappings, \"originalLine\", \"originalColumn\", util.compareByOriginalPositions, util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND));\n    if (index >= 0) {\n        var mapping = this._originalMappings[index];\n        if (mapping.source === needle.source) {\n            return {\n                line: util.getArg(mapping, \"generatedLine\", null),\n                column: util.getArg(mapping, \"generatedColumn\", null),\n                lastColumn: util.getArg(mapping, \"lastGeneratedColumn\", null)\n            };\n        }\n    }\n    return {\n        line: null,\n        column: null,\n        lastColumn: null\n    };\n};\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */ function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\n    var sourceMap = aSourceMap;\n    if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n    }\n    var version = util.getArg(sourceMap, \"version\");\n    var sections = util.getArg(sourceMap, \"sections\");\n    if (version != this._version) {\n        throw new Error(\"Unsupported version: \" + version);\n    }\n    this._sources = new ArraySet();\n    this._names = new ArraySet();\n    var lastOffset = {\n        line: -1,\n        column: 0\n    };\n    this._sections = sections.map(function(s) {\n        if (s.url) {\n            // The url field will require support for asynchronicity.\n            // See https://github.com/mozilla/source-map/issues/16\n            throw new Error(\"Support for url field in sections not implemented.\");\n        }\n        var offset = util.getArg(s, \"offset\");\n        var offsetLine = util.getArg(offset, \"line\");\n        var offsetColumn = util.getArg(offset, \"column\");\n        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {\n            throw new Error(\"Section offsets must be ordered and non-overlapping.\");\n        }\n        lastOffset = offset;\n        return {\n            generatedOffset: {\n                // The offset fields are 0-based, but we use 1-based indices when\n                // encoding/decoding from VLQ.\n                generatedLine: offsetLine + 1,\n                generatedColumn: offsetColumn + 1\n            },\n            consumer: new SourceMapConsumer(util.getArg(s, \"map\"), aSourceMapURL)\n        };\n    });\n}\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n/**\n * The version of the source mapping spec that we are consuming.\n */ IndexedSourceMapConsumer.prototype._version = 3;\n/**\n * The list of original sources.\n */ Object.defineProperty(IndexedSourceMapConsumer.prototype, \"sources\", {\n    get: function() {\n        var sources = [];\n        for(var i = 0; i < this._sections.length; i++){\n            for(var j = 0; j < this._sections[i].consumer.sources.length; j++){\n                sources.push(this._sections[i].consumer.sources[j]);\n            }\n        }\n        return sources;\n    }\n});\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */ IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n        generatedLine: util.getArg(aArgs, \"line\"),\n        generatedColumn: util.getArg(aArgs, \"column\")\n    };\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections, function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n            return cmp;\n        }\n        return needle.generatedColumn - section.generatedOffset.generatedColumn;\n    });\n    var section = this._sections[sectionIndex];\n    if (!section) {\n        return {\n            source: null,\n            line: null,\n            column: null,\n            name: null\n        };\n    }\n    return section.consumer.originalPositionFor({\n        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),\n        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n        bias: aArgs.bias\n    });\n};\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */ IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function(s) {\n        return s.consumer.hasContentsOfAllSources();\n    });\n};\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */ IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for(var i = 0; i < this._sections.length; i++){\n        var section = this._sections[i];\n        var content = section.consumer.sourceContentFor(aSource, true);\n        if (content) {\n            return content;\n        }\n    }\n    if (nullOnMissing) {\n        return null;\n    } else {\n        throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n};\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based. \n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */ IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for(var i = 0; i < this._sections.length; i++){\n        var section = this._sections[i];\n        // Only consider this section if the requested source is in the list of\n        // sources of the consumer.\n        if (section.consumer._findSourceIndex(util.getArg(aArgs, \"source\")) === -1) {\n            continue;\n        }\n        var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n        if (generatedPosition) {\n            var ret = {\n                line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),\n                column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)\n            };\n            return ret;\n        }\n    }\n    return {\n        line: null,\n        column: null\n    };\n};\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */ IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for(var i = 0; i < this._sections.length; i++){\n        var section = this._sections[i];\n        var sectionMappings = section.consumer._generatedMappings;\n        for(var j = 0; j < sectionMappings.length; j++){\n            var mapping = sectionMappings[j];\n            var source = section.consumer._sources.at(mapping.source);\n            source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);\n            this._sources.add(source);\n            source = this._sources.indexOf(source);\n            var name = null;\n            if (mapping.name) {\n                name = section.consumer._names.at(mapping.name);\n                this._names.add(name);\n                name = this._names.indexOf(name);\n            }\n            // The mappings coming from the consumer for the section have\n            // generated positions relative to the start of the section, so we\n            // need to offset them to be relative to the start of the concatenated\n            // generated file.\n            var adjustedMapping = {\n                source: source,\n                generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),\n                generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n                originalLine: mapping.originalLine,\n                originalColumn: mapping.originalColumn,\n                name: name\n            };\n            this.__generatedMappings.push(adjustedMapping);\n            if (typeof adjustedMapping.originalLine === \"number\") {\n                this.__originalMappings.push(adjustedMapping);\n            }\n        }\n    }\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n};\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vc291cmNlLW1hcC1qcy9saWIvc291cmNlLW1hcC1jb25zdW1lci5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5Q0FBeUMsR0FDekM7Ozs7Q0FJQyxHQUVELElBQUlBLE9BQU9DLG1CQUFPQSxDQUFDO0FBQ25CLElBQUlDLGVBQWVELG1CQUFPQSxDQUFDO0FBQzNCLElBQUlFLFdBQVdGLDRGQUErQjtBQUM5QyxJQUFJRyxZQUFZSCxtQkFBT0EsQ0FBQztBQUN4QixJQUFJSSxZQUFZSiwrRkFBaUM7QUFFakQsU0FBU0ssa0JBQWtCQyxVQUFVLEVBQUVDLGFBQWE7SUFDbEQsSUFBSUMsWUFBWUY7SUFDaEIsSUFBSSxPQUFPQSxlQUFlLFVBQVU7UUFDbENFLFlBQVlULEtBQUtVLG1CQUFtQixDQUFDSDtJQUN2QztJQUVBLE9BQU9FLFVBQVVFLFFBQVEsSUFBSSxPQUN6QixJQUFJQyx5QkFBeUJILFdBQVdELGlCQUN4QyxJQUFJSyx1QkFBdUJKLFdBQVdEO0FBQzVDO0FBRUFGLGtCQUFrQlEsYUFBYSxHQUFHLFNBQVNQLFVBQVUsRUFBRUMsYUFBYTtJQUNsRSxPQUFPSyx1QkFBdUJDLGFBQWEsQ0FBQ1AsWUFBWUM7QUFDMUQ7QUFFQTs7Q0FFQyxHQUNERixrQkFBa0JTLFNBQVMsQ0FBQ0MsUUFBUSxHQUFHO0FBRXZDLDBFQUEwRTtBQUMxRSw4RUFBOEU7QUFDOUUscUVBQXFFO0FBQ3JFLDJFQUEyRTtBQUMzRSw4RUFBOEU7QUFDOUUsMkVBQTJFO0FBQzNFLDBEQUEwRDtBQUMxRCxFQUFFO0FBQ0YsNENBQTRDO0FBQzVDLEVBQUU7QUFDRixRQUFRO0FBQ1IsOERBQThEO0FBQzlELGtFQUFrRTtBQUNsRSx5RUFBeUU7QUFDekUsK0JBQStCO0FBQy9CLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsc0VBQXNFO0FBQ3RFLHFFQUFxRTtBQUNyRSw0RUFBNEU7QUFDNUUsb0JBQW9CO0FBQ3BCLFFBQVE7QUFDUixFQUFFO0FBQ0YseUVBQXlFO0FBQ3pFLFVBQVU7QUFD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LFFBQVFKLGVBQWUsQ0FBQ2xILGFBQWEsR0FBRztnQkFDM0NDLGlCQUFpQkwsUUFBUUssZUFBZSxHQUNyQ3FILENBQUFBLFFBQVFKLGVBQWUsQ0FBQ2xILGFBQWEsS0FBS0osUUFBUUksYUFBYSxHQUM5RHNILFFBQVFKLGVBQWUsQ0FBQ2pILGVBQWUsR0FBRyxJQUMxQztnQkFDSkMsY0FBY04sUUFBUU0sWUFBWTtnQkFDbENDLGdCQUFnQlAsUUFBUU8sY0FBYztnQkFDdENDLE1BQU1BO1lBQ1I7WUFFQSxJQUFJLENBQUNwRCxtQkFBbUIsQ0FBQ2dFLElBQUksQ0FBQ21IO1lBQzlCLElBQUksT0FBT0EsZ0JBQWdCakksWUFBWSxLQUFLLFVBQVU7Z0JBQ3BELElBQUksQ0FBQ3pDLGtCQUFrQixDQUFDdUQsSUFBSSxDQUFDbUg7WUFDL0I7UUFDRjtJQUNGO0lBRUEvTCxVQUFVLElBQUksQ0FBQ1ksbUJBQW1CLEVBQUVqQixLQUFLNkosbUNBQW1DO0lBQzVFeEosVUFBVSxJQUFJLENBQUNxQixrQkFBa0IsRUFBRTFCLEtBQUs4RSwwQkFBMEI7QUFDcEU7QUFFRkssZ0NBQWdDLEdBQUd2RSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWVtYWlsLy4uL3NvdXJjZS1tYXAtanMvbGliL3NvdXJjZS1tYXAtY29uc3VtZXIuanM/MDYzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZSgnLi9iaW5hcnktc2VhcmNoJyk7XG52YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHF1aWNrU29ydCA9IHJlcXVpcmUoJy4vcXVpY2stc29ydCcpLnF1aWNrU29ydDtcblxuZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IHV0aWwucGFyc2VTb3VyY2VNYXBJbnB1dChhU291cmNlTWFwKTtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2VNYXAuc2VjdGlvbnMgIT0gbnVsbFxuICAgID8gbmV3IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpXG4gICAgOiBuZXcgQmFzaWNTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpO1xufVxuXG5Tb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID0gZnVuY3Rpb24oYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICByZXR1cm4gQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpO1xufVxuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLy8gYF9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZCBgX19vcmlnaW5hbE1hcHBpbmdzYCBhcmUgYXJyYXlzIHRoYXQgaG9sZCB0aGVcbi8vIHBhcnNlZCBtYXBwaW5nIGNvb3JkaW5hdGVzIGZyb20gdGhlIHNvdXJjZSBtYXAncyBcIm1hcHBpbmdzXCIgYXR0cmlidXRlLiBUaGV5XG4vLyBhcmUgbGF6aWx5IGluc3RhbnRpYXRlZCwgYWNjZXNzZWQgdmlhIHRoZSBgX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgZ2V0dGVycyByZXNwZWN0aXZlbHksIGFuZCB3ZSBvbmx5IHBhcnNlIHRoZSBtYXBwaW5nc1xuLy8gYW5kIGNyZWF0ZSB0aGVzZSBhcnJheXMgb25jZSBxdWVyaWVkIGZvciBhIHNvdXJjZSBsb2NhdGlvbi4gV2UganVtcCB0aHJvdWdoXG4vLyB0aGVzZSBob29wcyBiZWNhdXNlIHRoZXJlIGNhbiBiZSBtYW55IHRob3VzYW5kcyBvZiBtYXBwaW5ncywgYW5kIHBhcnNpbmdcbi8vIHRoZW0gaXMgZXhwZW5zaXZlLCBzbyB3ZSBvbmx5IHdhbnQgdG8gZG8gaXQgaWYgd2UgbXVzdC5cbi8vXG4vLyBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXlzIGlzIG9mIHRoZSBmb3JtOlxuLy9cbi8vICAgICB7XG4vLyAgICAgICBnZW5lcmF0ZWRMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBzb3VyY2U6IFRoZSBwYXRoIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSB0aGF0IGdlbmVyYXRlZCB0aGlzXG4vLyAgICAgICAgICAgICAgIGNodW5rIG9mIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG9yaWdpbmFsQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgbmFtZTogVGhlIG5hbWUgb2YgdGhlIG9yaWdpbmFsIHN5bWJvbCB3aGljaCBnZW5lcmF0ZWQgdGhpcyBjaHVuayBvZlxuLy8gICAgICAgICAgICAgY29kZS5cbi8vICAgICB9XG4vL1xuLy8gQWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBgZ2VuZXJhdGVkTGluZWAgYW5kIGBnZW5lcmF0ZWRDb2x1bW5gIGNhbiBiZVxuLy8gYG51bGxgLlxuLy9cbi8vIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMuXG4vL1xuLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMuXG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbnVsbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfZ2VuZXJhdGVkTWFwcGluZ3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncztcbiAgfVxufSk7XG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX29yaWdpbmFsTWFwcGluZ3MgPSBudWxsO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19vcmlnaW5hbE1hcHBpbmdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBpbmRleCkge1xuICAgIHZhciBjID0gYVN0ci5jaGFyQXQoaW5kZXgpO1xuICAgIHJldHVybiBjID09PSBcIjtcIiB8fCBjID09PSBcIixcIjtcbiAgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IF9wYXJzZU1hcHBpbmdzXCIpO1xuICB9O1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVIgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVIgPSAyO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5Tb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICogZ2VuZXJhdGVkIGxpbmUvY29sdW1uIGluIHRoaXMgc291cmNlIG1hcC5cbiAqXG4gKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggZWFjaCBtYXBwaW5nLlxuICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICogICAgICAgIHRpbWUgdGhhdCBgYUNhbGxiYWNrYCBpcyBjYWxsZWQuXG4gKiBAcGFyYW0gYU9yZGVyXG4gKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSYC4gU3BlY2lmaWVzIHdoZXRoZXIgeW91IHdhbnQgdG9cbiAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZWFjaE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9lYWNoTWFwcGluZyhhQ2FsbGJhY2ssIGFDb250ZXh0LCBhT3JkZXIpIHtcbiAgICB2YXIgY29udGV4dCA9IGFDb250ZXh0IHx8IG51bGw7XG4gICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcblxuICAgIHZhciBtYXBwaW5ncztcbiAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgIG1hcHBpbmdzID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yZGVyIG9mIGl0ZXJhdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgdmFyIGJvdW5kQ2FsbGJhY2sgPSBhQ2FsbGJhY2suYmluZChjb250ZXh0KTtcbiAgICB2YXIgbmFtZXMgPSB0aGlzLl9uYW1lcztcbiAgICB2YXIgc291cmNlcyA9IHRoaXMuX3NvdXJjZXM7XG4gICAgdmFyIHNvdXJjZU1hcFVSTCA9IHRoaXMuX3NvdXJjZU1hcFVSTDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbWFwcGluZ3MubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xuICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlID09PSBudWxsID8gbnVsbCA6IHNvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgc291cmNlID0gdXRpbC5jb21wdXRlU291cmNlVVJMKHNvdXJjZVJvb3QsIHNvdXJjZSwgc291cmNlTWFwVVJMKTtcbiAgICAgIGJvdW5kQ2FsbGJhY2soe1xuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uLFxuICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgbmFtZTogbWFwcGluZy5uYW1lID09PSBudWxsID8gbnVsbCA6IG5hbWVzLmF0KG1hcHBpbmcubmFtZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwcm92aWRlZC4gSWYgbm8gY29sdW1uIGlzIHByb3ZpZGVkLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byBhIGVpdGhlciB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciBvciB0aGUgbmV4dFxuICogY2xvc2VzdCBsaW5lIHRoYXQgaGFzIGFueSBtYXBwaW5ncy4gT3RoZXJ3aXNlLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGluZSBhbmQgZWl0aGVyIHRoZSBjb2x1bW4gd2UgYXJlIHNlYXJjaGluZyBmb3JcbiAqIG9yIHRoZSBuZXh0IGNsb3Nlc3QgY29sdW1uIHRoYXQgaGFzIGFueSBvZmZzZXRzLlxuICpcbiAqIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogT3B0aW9uYWwuIHRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICpcbiAqIGFuZCBhbiBhcnJheSBvZiBvYmplY3RzIGlzIHJldHVybmVkLCBlYWNoIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IoYUFyZ3MpIHtcbiAgICB2YXIgbGluZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpO1xuXG4gICAgLy8gV2hlbiB0aGVyZSBpcyBubyBleGFjdCBtYXRjaCwgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nXG4gICAgLy8gcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgbWFwcGluZyBsZXNzIHRoYW4gdGhlIG5lZWRsZS4gQnlcbiAgICAvLyBzZXR0aW5nIG5lZWRsZS5vcmlnaW5hbENvbHVtbiB0byAwLCB3ZSB0aHVzIGZpbmQgdGhlIGxhc3QgbWFwcGluZyBmb3JcbiAgICAvLyB0aGUgZ2l2ZW4gbGluZSwgcHJvdmlkZWQgc3VjaCBhIG1hcHBpbmcgZXhpc3RzLlxuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBzb3VyY2U6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyksXG4gICAgICBvcmlnaW5hbExpbmU6IGxpbmUsXG4gICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nLCAwKVxuICAgIH07XG5cbiAgICBuZWVkbGUuc291cmNlID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KG5lZWRsZS5zb3VyY2UpO1xuICAgIGlmIChuZWVkbGUuc291cmNlIDwgMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBtYXBwaW5ncyA9IFtdO1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAoYUFyZ3MuY29sdW1uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2UgZm91bmQuIFNpbmNlXG4gICAgICAgIC8vIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgLy8gdGhlIGxpbmUgd2UgZm91bmQuXG4gICAgICAgIHdoaWxlIChtYXBwaW5nICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBvcmlnaW5hbExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2Ugd2VyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICAvLyBTaW5jZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgIC8vIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICB3aGlsZSAobWFwcGluZyAmJlxuICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IGxpbmUgJiZcbiAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPT0gb3JpZ2luYWxDb2x1bW4pIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcHBpbmdzO1xuICB9O1xuXG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaCB3ZSBjYW5cbiAqIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZmlsZSBwb3NpdGlvbnMgYnkgZ2l2aW5nIGl0IGEgZmlsZVxuICogcG9zaXRpb24gaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKlxuICogVGhlIGZpcnN0IHBhcmFtZXRlciBpcyB0aGUgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvclxuICogYWxyZWFkeSBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBzb3VyY2UgbWFwcyBoYXZlIHRoZVxuICogZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gc291cmNlczogQW4gYXJyYXkgb2YgVVJMcyB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICogICAtIG5hbWVzOiBBbiBhcnJheSBvZiBpZGVudGlmaWVycyB3aGljaCBjYW4gYmUgcmVmZXJyZW5jZWQgYnkgaW5kaXZpZHVhbCBtYXBwaW5ncy5cbiAqICAgLSBzb3VyY2VSb290OiBPcHRpb25hbC4gVGhlIFVSTCByb290IGZyb20gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIHJlbGF0aXZlLlxuICogICAtIHNvdXJjZXNDb250ZW50OiBPcHRpb25hbC4gQW4gYXJyYXkgb2YgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBtYXBwaW5nczogQSBzdHJpbmcgb2YgYmFzZTY0IFZMUXMgd2hpY2ggY29udGFpbiB0aGUgYWN0dWFsIG1hcHBpbmdzLlxuICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqXG4gKiBIZXJlIGlzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdOlxuICpcbiAqICAgICB7XG4gKiAgICAgICB2ZXJzaW9uIDogMyxcbiAqICAgICAgIGZpbGU6IFwib3V0LmpzXCIsXG4gKiAgICAgICBzb3VyY2VSb290IDogXCJcIixcbiAqICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICogICAgICAgbWFwcGluZ3M6IFwiQUEsQUI7O0FCQ0RFO1wiXG4gKiAgICAgfVxuICpcbiAqIFRoZSBzZWNvbmQgcGFyYW1ldGVyLCBpZiBnaXZlbiwgaXMgYSBzdHJpbmcgd2hvc2UgdmFsdWUgaXMgdGhlIFVSTFxuICogYXQgd2hpY2ggdGhlIHNvdXJjZSBtYXAgd2FzIGZvdW5kLiAgVGhpcyBVUkwgaXMgdXNlZCB0byBjb21wdXRlIHRoZVxuICogc291cmNlcyBhcnJheS5cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdD9wbGk9MSNcbiAqL1xuZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gdXRpbC5wYXJzZVNvdXJjZU1hcElucHV0KGFTb3VyY2VNYXApO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gIHZhciBzb3VyY2VzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlcycpO1xuICAvLyBTYXNzIDMuMyBsZWF2ZXMgb3V0IHRoZSAnbmFtZXMnIGFycmF5LCBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgKHdoaWNoXG4gIC8vIHJlcXVpcmVzIHRoZSBhcnJheSkgdG8gcGxheSBuaWNlIGhlcmUuXG4gIHZhciBuYW1lcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ25hbWVzJywgW10pO1xuICB2YXIgc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgdmFyIHNvdXJjZXNDb250ZW50ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlc0NvbnRlbnQnLCBudWxsKTtcbiAgdmFyIG1hcHBpbmdzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbWFwcGluZ3MnKTtcbiAgdmFyIGZpbGUgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdmaWxlJywgbnVsbCk7XG5cbiAgLy8gT25jZSBhZ2FpbiwgU2FzcyBkZXZpYXRlcyBmcm9tIHRoZSBzcGVjIGFuZCBzdXBwbGllcyB0aGUgdmVyc2lvbiBhcyBhXG4gIC8vIHN0cmluZyByYXRoZXIgdGhhbiBhIG51bWJlciwgc28gd2UgdXNlIGxvb3NlIGVxdWFsaXR5IGNoZWNraW5nIGhlcmUuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VSb290KSB7XG4gICAgc291cmNlUm9vdCA9IHV0aWwubm9ybWFsaXplKHNvdXJjZVJvb3QpO1xuICB9XG5cbiAgc291cmNlcyA9IHNvdXJjZXNcbiAgICAubWFwKFN0cmluZylcbiAgICAvLyBTb21lIHNvdXJjZSBtYXBzIHByb2R1Y2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIGxpa2UgXCIuL2Zvby5qc1wiIGluc3RlYWQgb2ZcbiAgICAvLyBcImZvby5qc1wiLiAgTm9ybWFsaXplIHRoZXNlIGZpcnN0IHNvIHRoYXQgZnV0dXJlIGNvbXBhcmlzb25zIHdpbGwgc3VjY2VlZC5cbiAgICAvLyBTZWUgYnVnemlsLmxhLzEwOTA3NjguXG4gICAgLm1hcCh1dGlsLm5vcm1hbGl6ZSlcbiAgICAvLyBBbHdheXMgZW5zdXJlIHRoYXQgYWJzb2x1dGUgc291cmNlcyBhcmUgaW50ZXJuYWxseSBzdG9yZWQgcmVsYXRpdmUgdG9cbiAgICAvLyB0aGUgc291cmNlIHJvb3QsIGlmIHRoZSBzb3VyY2Ugcm9vdCBpcyBhYnNvbHV0ZS4gTm90IGRvaW5nIHRoaXMgd291bGRcbiAgICAvLyBiZSBwYXJ0aWN1bGFybHkgcHJvYmxlbWF0aWMgd2hlbiB0aGUgc291cmNlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlXG4gICAgLy8gc291cmNlICh2YWxpZCwgYnV0IHdoeT8/KS4gU2VlIGdpdGh1YiBpc3N1ZSAjMTk5IGFuZCBidWd6aWwubGEvMTE4ODk4Mi5cbiAgICAubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBzb3VyY2VSb290ICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2VSb290KSAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlKVxuICAgICAgICA/IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlKVxuICAgICAgICA6IHNvdXJjZTtcbiAgICB9KTtcblxuICAvLyBQYXNzIGB0cnVlYCBiZWxvdyB0byBhbGxvdyBkdXBsaWNhdGUgbmFtZXMgYW5kIHNvdXJjZXMuIFdoaWxlIHNvdXJjZSBtYXBzXG4gIC8vIGFyZSBpbnRlbmRlZCB0byBiZSBjb21wcmVzc2VkIGFuZCBkZWR1cGxpY2F0ZWQsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4gIC8vIHNvbWV0aW1lcyBnZW5lcmF0ZXMgc291cmNlIG1hcHMgd2l0aCBkdXBsaWNhdGVzIGluIHRoZW0uIFNlZSBHaXRodWIgaXNzdWVcbiAgLy8gIzcyIGFuZCBidWd6aWwubGEvODg5NDkyLlxuICB0aGlzLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcy5tYXAoU3RyaW5nKSwgdHJ1ZSk7XG4gIHRoaXMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoc291cmNlcywgdHJ1ZSk7XG5cbiAgdGhpcy5fYWJzb2x1dGVTb3VyY2VzID0gdGhpcy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHV0aWwuY29tcHV0ZVNvdXJjZVVSTChzb3VyY2VSb290LCBzLCBhU291cmNlTWFwVVJMKTtcbiAgfSk7XG5cbiAgdGhpcy5zb3VyY2VSb290ID0gc291cmNlUm9vdDtcbiAgdGhpcy5zb3VyY2VzQ29udGVudCA9IHNvdXJjZXNDb250ZW50O1xuICB0aGlzLl9tYXBwaW5ncyA9IG1hcHBpbmdzO1xuICB0aGlzLl9zb3VyY2VNYXBVUkwgPSBhU291cmNlTWFwVVJMO1xuICB0aGlzLmZpbGUgPSBmaWxlO1xufVxuXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBmaW5kIHRoZSBpbmRleCBvZiBhIHNvdXJjZS4gIFJldHVybnMgLTEgaWYgbm90XG4gKiBmb3VuZC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRTb3VyY2VJbmRleCA9IGZ1bmN0aW9uKGFTb3VyY2UpIHtcbiAgdmFyIHJlbGF0aXZlU291cmNlID0gYVNvdXJjZTtcbiAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgcmVsYXRpdmVTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgcmVsYXRpdmVTb3VyY2UpO1xuICB9XG5cbiAgaWYgKHRoaXMuX3NvdXJjZXMuaGFzKHJlbGF0aXZlU291cmNlKSkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VzLmluZGV4T2YocmVsYXRpdmVTb3VyY2UpO1xuICB9XG5cbiAgLy8gTWF5YmUgYVNvdXJjZSBpcyBhbiBhYnNvbHV0ZSBVUkwgYXMgcmV0dXJuZWQgYnkgfHNvdXJjZXN8LiAgSW5cbiAgLy8gdGhpcyBjYXNlIHdlIGNhbid0IHNpbXBseSB1bmRvIHRoZSB0cmFuc2Zvcm0uXG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYWJzb2x1dGVTb3VyY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHRoaXMuX2Fic29sdXRlU291cmNlc1tpXSA9PSBhU291cmNlKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgZnJvbSBhIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAqXG4gKiBAcGFyYW0gU291cmNlTWFwR2VuZXJhdG9yIGFTb3VyY2VNYXBcbiAqICAgICAgICBUaGUgc291cmNlIG1hcCB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG4gKiBAcGFyYW0gU3RyaW5nIGFTb3VyY2VNYXBVUkxcbiAqICAgICAgICBUaGUgVVJMIGF0IHdoaWNoIHRoZSBzb3VyY2UgbWFwIGNhbiBiZSBmb3VuZCAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICAgIHZhciBzbWMgPSBPYmplY3QuY3JlYXRlKEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcblxuICAgIHZhciBuYW1lcyA9IHNtYy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fbmFtZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICB2YXIgc291cmNlcyA9IHNtYy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9zb3VyY2VzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgc21jLnNvdXJjZVJvb3QgPSBhU291cmNlTWFwLl9zb3VyY2VSb290O1xuICAgIHNtYy5zb3VyY2VzQ29udGVudCA9IGFTb3VyY2VNYXAuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoc21jLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtYy5zb3VyY2VSb290KTtcbiAgICBzbWMuZmlsZSA9IGFTb3VyY2VNYXAuX2ZpbGU7XG4gICAgc21jLl9zb3VyY2VNYXBVUkwgPSBhU291cmNlTWFwVVJMO1xuICAgIHNtYy5fYWJzb2x1dGVTb3VyY2VzID0gc21jLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc21jLnNvdXJjZVJvb3QsIHMsIGFTb3VyY2VNYXBVUkwpO1xuICAgIH0pO1xuXG4gICAgLy8gQmVjYXVzZSB3ZSBhcmUgbW9kaWZ5aW5nIHRoZSBlbnRyaWVzIChieSBjb252ZXJ0aW5nIHN0cmluZyBzb3VyY2VzIGFuZFxuICAgIC8vIG5hbWVzIHRvIGluZGljZXMgaW50byB0aGUgc291cmNlcyBhbmQgbmFtZXMgQXJyYXlTZXRzKSwgd2UgaGF2ZSB0byBtYWtlXG4gICAgLy8gYSBjb3B5IG9mIHRoZSBlbnRyeSBvciBlbHNlIGJhZCB0aGluZ3MgaGFwcGVuLiBTaGFyZWQgbXV0YWJsZSBzdGF0ZVxuICAgIC8vIHN0cmlrZXMgYWdhaW4hIFNlZSBnaXRodWIgaXNzdWUgIzE5MS5cblxuICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnRvQXJyYXkoKS5zbGljZSgpO1xuICAgIHZhciBkZXN0R2VuZXJhdGVkTWFwcGluZ3MgPSBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBkZXN0T3JpZ2luYWxNYXBwaW5ncyA9IHNtYy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNyY01hcHBpbmcgPSBnZW5lcmF0ZWRNYXBwaW5nc1tpXTtcbiAgICAgIHZhciBkZXN0TWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkTGluZTtcbiAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAoc3JjTWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgZGVzdE1hcHBpbmcuc291cmNlID0gc291cmNlcy5pbmRleE9mKHNyY01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxMaW5lID0gc3JjTWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gc3JjTWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAoc3JjTWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgZGVzdE1hcHBpbmcubmFtZSA9IG5hbWVzLmluZGV4T2Yoc3JjTWFwcGluZy5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc3RPcmlnaW5hbE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgICAgfVxuXG4gICAgICBkZXN0R2VuZXJhdGVkTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHNtYy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgcmV0dXJuIHNtYztcbiAgfTtcblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWJzb2x1dGVTb3VyY2VzLnNsaWNlKCk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGUgdGhlIEpJVCB3aXRoIGEgbmljZSBzaGFwZSAvIGhpZGRlbiBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZygpIHtcbiAgdGhpcy5nZW5lcmF0ZWRMaW5lID0gMDtcbiAgdGhpcy5nZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdGhpcy5vcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHRoaXMubmFtZSA9IG51bGw7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5cbmNvbnN0IGNvbXBhcmVHZW5lcmF0ZWQgPSB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkTm9MaW5lO1xuZnVuY3Rpb24gc29ydEdlbmVyYXRlZChhcnJheSwgc3RhcnQpIHtcbiAgbGV0IGwgPSBhcnJheS5sZW5ndGg7XG4gIGxldCBuID0gYXJyYXkubGVuZ3RoIC0gc3RhcnQ7XG4gIGlmIChuIDw9IDEpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAobiA9PSAyKSB7XG4gICAgbGV0IGEgPSBhcnJheVtzdGFydF07XG4gICAgbGV0IGIgPSBhcnJheVtzdGFydCArIDFdO1xuICAgIGlmIChjb21wYXJlR2VuZXJhdGVkKGEsIGIpID4gMCkge1xuICAgICAgYXJyYXlbc3RhcnRdID0gYjtcbiAgICAgIGFycmF5W3N0YXJ0ICsgMV0gPSBhO1xuICAgIH1cbiAgfSBlbHNlIGlmIChuIDwgMjApIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSBpOyBqID4gc3RhcnQ7IGotLSkge1xuICAgICAgICBsZXQgYSA9IGFycmF5W2ogLSAxXTtcbiAgICAgICAgbGV0IGIgPSBhcnJheVtqXTtcbiAgICAgICAgaWYgKGNvbXBhcmVHZW5lcmF0ZWQoYSwgYikgPD0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2ogLSAxXSA9IGI7XG4gICAgICAgIGFycmF5W2pdID0gYTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcXVpY2tTb3J0KGFycmF5LCBjb21wYXJlR2VuZXJhdGVkLCBzdGFydCk7XG4gIH1cbn1cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgIHZhciBnZW5lcmF0ZWRMaW5lID0gMTtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGFTdHIubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGNhY2hlZFNlZ21lbnRzID0ge307XG4gICAgdmFyIHRlbXAgPSB7fTtcbiAgICB2YXIgb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBtYXBwaW5nLCBzdHIsIHNlZ21lbnQsIGVuZCwgdmFsdWU7XG5cbiAgICBsZXQgc3ViYXJyYXlTdGFydCA9IDA7XG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnOycpIHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZSsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG5cbiAgICAgICAgc29ydEdlbmVyYXRlZChnZW5lcmF0ZWRNYXBwaW5ncywgc3ViYXJyYXlTdGFydCk7XG4gICAgICAgIHN1YmFycmF5U3RhcnQgPSBnZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICcsJykge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1hcHBpbmcgPSBuZXcgTWFwcGluZygpO1xuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBnZW5lcmF0ZWRMaW5lO1xuXG4gICAgICAgIGZvciAoZW5kID0gaW5kZXg7IGVuZCA8IGxlbmd0aDsgZW5kKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5fY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBlbmQpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gYVN0ci5zbGljZShpbmRleCwgZW5kKTtcblxuICAgICAgICBzZWdtZW50ID0gW107XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGVuZCkge1xuICAgICAgICAgIGJhc2U2NFZMUS5kZWNvZGUoYVN0ciwgaW5kZXgsIHRlbXApO1xuICAgICAgICAgIHZhbHVlID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICBpbmRleCA9IHRlbXAucmVzdDtcbiAgICAgICAgICBzZWdtZW50LnB1c2godmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSwgYnV0IG5vIGxpbmUgYW5kIGNvbHVtbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSBhbmQgbGluZSwgYnV0IG5vIGNvbHVtbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGVkIGNvbHVtbi5cbiAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiArIHNlZ21lbnRbMF07XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gMSkge1xuICAgICAgICAgIC8vIE9yaWdpbmFsIHNvdXJjZS5cbiAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHByZXZpb3VzU291cmNlICsgc2VnbWVudFsxXTtcbiAgICAgICAgICBwcmV2aW91c1NvdXJjZSArPSBzZWdtZW50WzFdO1xuXG4gICAgICAgICAgLy8gT3JpZ2luYWwgbGluZS5cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IHByZXZpb3VzT3JpZ2luYWxMaW5lICsgc2VnbWVudFsyXTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICAgIC8vIExpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZFxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lICs9IDE7XG5cbiAgICAgICAgICAvLyBPcmlnaW5hbCBjb2x1bW4uXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gKyBzZWdtZW50WzNdO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgLy8gT3JpZ2luYWwgbmFtZS5cbiAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IHByZXZpb3VzTmFtZSArIHNlZ21lbnRbNF07XG4gICAgICAgICAgICBwcmV2aW91c05hbWUgKz0gc2VnbWVudFs0XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGxldCBjdXJyZW50U291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgICAgd2hpbGUgKG9yaWdpbmFsTWFwcGluZ3MubGVuZ3RoIDw9IGN1cnJlbnRTb3VyY2UpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTWFwcGluZ3MucHVzaChudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9yaWdpbmFsTWFwcGluZ3NbY3VycmVudFNvdXJjZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTWFwcGluZ3NbY3VycmVudFNvdXJjZV0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3JpZ2luYWxNYXBwaW5nc1tjdXJyZW50U291cmNlXS5wdXNoKG1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc29ydEdlbmVyYXRlZChnZW5lcmF0ZWRNYXBwaW5ncywgc3ViYXJyYXlTdGFydCk7XG4gICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gZ2VuZXJhdGVkTWFwcGluZ3M7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yaWdpbmFsTWFwcGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvcmlnaW5hbE1hcHBpbmdzW2ldICE9IG51bGwpIHtcbiAgICAgICAgcXVpY2tTb3J0KG9yaWdpbmFsTWFwcGluZ3NbaV0sIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnNOb1NvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gW10uY29uY2F0KC4uLm9yaWdpbmFsTWFwcGluZ3MpO1xuICB9O1xuXG4vKipcbiAqIEZpbmQgdGhlIG1hcHBpbmcgdGhhdCBiZXN0IG1hdGNoZXMgdGhlIGh5cG90aGV0aWNhbCBcIm5lZWRsZVwiIG1hcHBpbmcgdGhhdFxuICogd2UgYXJlIHNlYXJjaGluZyBmb3IgaW4gdGhlIGdpdmVuIFwiaGF5c3RhY2tcIiBvZiBtYXBwaW5ncy5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZmluZE1hcHBpbmcoYU5lZWRsZSwgYU1hcHBpbmdzLCBhTGluZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb2x1bW5OYW1lLCBhQ29tcGFyYXRvciwgYUJpYXMpIHtcbiAgICAvLyBUbyByZXR1cm4gdGhlIHBvc2l0aW9uIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCB3ZSBtdXN0IGZpcnN0IGZpbmQgdGhlXG4gICAgLy8gbWFwcGluZyBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCB0aGVuIHJldHVybiB0aGUgb3Bwb3NpdGUgcG9zaXRpb24gaXRcbiAgICAvLyBwb2ludHMgdG8uIEJlY2F1c2UgdGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHdlIGNhbiB1c2UgYmluYXJ5IHNlYXJjaCB0b1xuICAgIC8vIGZpbmQgdGhlIGJlc3QgbWFwcGluZy5cblxuICAgIGlmIChhTmVlZGxlW2FMaW5lTmFtZV0gPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTGluZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLCBnb3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUxpbmVOYW1lXSk7XG4gICAgfVxuICAgIGlmIChhTmVlZGxlW2FDb2x1bW5OYW1lXSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbHVtbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwLCBnb3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUNvbHVtbk5hbWVdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmluYXJ5U2VhcmNoLnNlYXJjaChhTmVlZGxlLCBhTWFwcGluZ3MsIGFDb21wYXJhdG9yLCBhQmlhcyk7XG4gIH07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbGFzdCBjb2x1bW4gZm9yIGVhY2ggZ2VuZXJhdGVkIG1hcHBpbmcuIFRoZSBsYXN0IGNvbHVtbiBpc1xuICogaW5jbHVzaXZlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb21wdXRlQ29sdW1uU3BhbnMgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9jb21wdXRlQ29sdW1uU3BhbnMoKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIC8vIE1hcHBpbmdzIGRvIG5vdCBjb250YWluIGEgZmllbGQgZm9yIHRoZSBsYXN0IGdlbmVyYXRlZCBjb2x1bW50LiBXZVxuICAgICAgLy8gY2FuIGNvbWUgdXAgd2l0aCBhbiBvcHRpbWlzdGljIGVzdGltYXRlLCBob3dldmVyLCBieSBhc3N1bWluZyB0aGF0XG4gICAgICAvLyBtYXBwaW5ncyBhcmUgY29udGlndW91cyAoaS5lLiBnaXZlbiB0d28gY29uc2VjdXRpdmUgbWFwcGluZ3MsIHRoZVxuICAgICAgLy8gZmlyc3QgbWFwcGluZyBlbmRzIHdoZXJlIHRoZSBzZWNvbmQgb25lIHN0YXJ0cykuXG4gICAgICBpZiAoaW5kZXggKyAxIDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoKSB7XG4gICAgICAgIHZhciBuZXh0TWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4ICsgMV07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIG1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbiA9IG5leHRNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtIDE7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGxhc3QgbWFwcGluZyBmb3IgZWFjaCBsaW5lIHNwYW5zIHRoZSBlbnRpcmUgbGluZS5cbiAgICAgIG1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbiA9IEluZmluaXR5O1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4gIFRoZSBjb2x1bW5cbiAqICAgICBudW1iZXIgaXMgMC1iYXNlZC5cbiAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5vcmlnaW5hbFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhcbiAgICAgIG5lZWRsZSxcbiAgICAgIHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLFxuICAgICAgXCJnZW5lcmF0ZWRMaW5lXCIsXG4gICAgICBcImdlbmVyYXRlZENvbHVtblwiLFxuICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCxcbiAgICAgIHV0aWwuZ2V0QXJnKGFBcmdzLCAnYmlhcycsIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EKVxuICAgICk7XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5lZWRsZS5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnc291cmNlJywgbnVsbCk7XG4gICAgICAgIGlmIChzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmF0KHNvdXJjZSk7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5jb21wdXRlU291cmNlVVJMKHRoaXMuc291cmNlUm9vdCwgc291cmNlLCB0aGlzLl9zb3VyY2VNYXBVUkwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ25hbWUnLCBudWxsKTtcbiAgICAgICAgaWYgKG5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuYXQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGwsXG4gICAgICBuYW1lOiBudWxsXG4gICAgfTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcyA9XG4gIGZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50Lmxlbmd0aCA+PSB0aGlzLl9zb3VyY2VzLnNpemUoKSAmJlxuICAgICAgIXRoaXMuc291cmNlc0NvbnRlbnQuc29tZShmdW5jdGlvbiAoc2MpIHsgcmV0dXJuIHNjID09IG51bGw7IH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICogYXZhaWxhYmxlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kU291cmNlSW5kZXgoYVNvdXJjZSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W2luZGV4XTtcbiAgICB9XG5cbiAgICB2YXIgcmVsYXRpdmVTb3VyY2UgPSBhU291cmNlO1xuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgcmVsYXRpdmVTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgcmVsYXRpdmVTb3VyY2UpO1xuICAgIH1cblxuICAgIHZhciB1cmw7XG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsXG4gICAgICAgICYmICh1cmwgPSB1dGlsLnVybFBhcnNlKHRoaXMuc291cmNlUm9vdCkpKSB7XG4gICAgICAvLyBYWFg6IGZpbGU6Ly8gVVJJcyBhbmQgYWJzb2x1dGUgcGF0aHMgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yIGZvclxuICAgICAgLy8gbWFueSB1c2Vycy4gV2UgY2FuIGhlbHAgdGhlbSBvdXQgd2hlbiB0aGV5IGV4cGVjdCBmaWxlOi8vIFVSSXMgdG9cbiAgICAgIC8vIGJlaGF2ZSBsaWtlIGl0IHdvdWxkIGlmIHRoZXkgd2VyZSBydW5uaW5nIGEgbG9jYWwgSFRUUCBzZXJ2ZXIuIFNlZVxuICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg1NTk3LlxuICAgICAgdmFyIGZpbGVVcmlBYnNQYXRoID0gcmVsYXRpdmVTb3VyY2UucmVwbGFjZSgvXmZpbGU6XFwvXFwvLywgXCJcIik7XG4gICAgICBpZiAodXJsLnNjaGVtZSA9PSBcImZpbGVcIlxuICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKGZpbGVVcmlBYnNQYXRoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoZmlsZVVyaUFic1BhdGgpXVxuICAgICAgfVxuXG4gICAgICBpZiAoKCF1cmwucGF0aCB8fCB1cmwucGF0aCA9PSBcIi9cIilcbiAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhcIi9cIiArIHJlbGF0aXZlU291cmNlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoXCIvXCIgKyByZWxhdGl2ZVNvdXJjZSldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSBmcm9tXG4gICAgLy8gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yLiBJbiB0aGF0IGNhc2UsIHdlXG4gICAgLy8gZG9uJ3Qgd2FudCB0byB0aHJvdyBpZiB3ZSBjYW4ndCBmaW5kIHRoZSBzb3VyY2UgLSB3ZSBqdXN0IHdhbnQgdG9cbiAgICAvLyByZXR1cm4gbnVsbCwgc28gd2UgcHJvdmlkZSBhIGZsYWcgdG8gZXhpdCBncmFjZWZ1bGx5LlxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIHJlbGF0aXZlU291cmNlICsgJ1wiIGlzIG5vdCBpbiB0aGUgU291cmNlTWFwLicpO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXJcbiAqICAgICBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBjb2x1bW5cbiAqICAgICBudW1iZXIgaXMgMC1iYXNlZC5cbiAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpO1xuICAgIHNvdXJjZSA9IHRoaXMuX2ZpbmRTb3VyY2VJbmRleChzb3VyY2UpO1xuICAgIGlmIChzb3VyY2UgPCAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIGxhc3RDb2x1bW46IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgb3JpZ2luYWxMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgbmVlZGxlLFxuICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLFxuICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgPT09IG5lZWRsZS5zb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgIGxhc3RDb2x1bW46IG51bGxcbiAgICB9O1xuICB9O1xuXG5leHBvcnRzLkJhc2ljU291cmNlTWFwQ29uc3VtZXIgPSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIEFuIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2hcbiAqIHdlIGNhbiBxdWVyeSBmb3IgaW5mb3JtYXRpb24uIEl0IGRpZmZlcnMgZnJvbSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGluXG4gKiB0aGF0IGl0IHRha2VzIFwiaW5kZXhlZFwiIHNvdXJjZSBtYXBzIChpLmUuIG9uZXMgd2l0aCBhIFwic2VjdGlvbnNcIiBmaWVsZCkgYXNcbiAqIGlucHV0LlxuICpcbiAqIFRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgYSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yIGFscmVhZHlcbiAqIHBhcnNlZCB0byBhbiBvYmplY3QpLiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMgZm9yIGluZGV4ZWQgc291cmNlIG1hcHMsIHRoZXlcbiAqIGhhdmUgdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICpcbiAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqICAgLSBzZWN0aW9uczogQSBsaXN0IG9mIHNlY3Rpb24gZGVmaW5pdGlvbnMuXG4gKlxuICogRWFjaCB2YWx1ZSB1bmRlciB0aGUgXCJzZWN0aW9uc1wiIGZpZWxkIGhhcyB0d28gZmllbGRzOlxuICogICAtIG9mZnNldDogVGhlIG9mZnNldCBpbnRvIHRoZSBvcmlnaW5hbCBzcGVjaWZpZWQgYXQgd2hpY2ggdGhpcyBzZWN0aW9uXG4gKiAgICAgICBiZWdpbnMgdG8gYXBwbHksIGRlZmluZWQgYXMgYW4gb2JqZWN0IHdpdGggYSBcImxpbmVcIiBhbmQgXCJjb2x1bW5cIlxuICogICAgICAgZmllbGQuXG4gKiAgIC0gbWFwOiBBIHNvdXJjZSBtYXAgZGVmaW5pdGlvbi4gVGhpcyBzb3VyY2UgbWFwIGNvdWxkIGFsc28gYmUgaW5kZXhlZCxcbiAqICAgICAgIGJ1dCBkb2Vzbid0IGhhdmUgdG8gYmUuXG4gKlxuICogSW5zdGVhZCBvZiB0aGUgXCJtYXBcIiBmaWVsZCwgaXQncyBhbHNvIHBvc3NpYmxlIHRvIGhhdmUgYSBcInVybFwiIGZpZWxkXG4gKiBzcGVjaWZ5aW5nIGEgVVJMIHRvIHJldHJpZXZlIGEgc291cmNlIG1hcCBmcm9tLCBidXQgdGhhdCdzIGN1cnJlbnRseVxuICogdW5zdXBwb3J0ZWQuXG4gKlxuICogSGVyZSdzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdLCBidXRcbiAqIG1vZGlmaWVkIHRvIG9taXQgYSBzZWN0aW9uIHdoaWNoIHVzZXMgdGhlIFwidXJsXCIgZmllbGQuXG4gKlxuICogIHtcbiAqICAgIHZlcnNpb24gOiAzLFxuICogICAgZmlsZTogXCJhcHAuanNcIixcbiAqICAgIHNlY3Rpb25zOiBbe1xuICogICAgICBvZmZzZXQ6IHtsaW5lOjEwMCwgY29sdW1uOjEwfSxcbiAqICAgICAgbWFwOiB7XG4gKiAgICAgICAgdmVyc2lvbiA6IDMsXG4gKiAgICAgICAgZmlsZTogXCJzZWN0aW9uLmpzXCIsXG4gKiAgICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICogICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICogICAgICAgIG1hcHBpbmdzOiBcIkFBQUEsRTs7QUJDREU7XCJcbiAqICAgICAgfVxuICogICAgfV0sXG4gKiAgfVxuICpcbiAqIFRoZSBzZWNvbmQgcGFyYW1ldGVyLCBpZiBnaXZlbiwgaXMgYSBzdHJpbmcgd2hvc2UgdmFsdWUgaXMgdGhlIFVSTFxuICogYXQgd2hpY2ggdGhlIHNvdXJjZSBtYXAgd2FzIGZvdW5kLiAgVGhpcyBVUkwgaXMgdXNlZCB0byBjb21wdXRlIHRoZVxuICogc291cmNlcyBhcnJheS5cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdCNoZWFkaW5nPWguNTM1ZXMzeGVwcmd0XG4gKi9cbmZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gdXRpbC5wYXJzZVNvdXJjZU1hcElucHV0KGFTb3VyY2VNYXApO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gIHZhciBzZWN0aW9ucyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NlY3Rpb25zJyk7XG5cbiAgaWYgKHZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICB9XG5cbiAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gIHZhciBsYXN0T2Zmc2V0ID0ge1xuICAgIGxpbmU6IC0xLFxuICAgIGNvbHVtbjogMFxuICB9O1xuICB0aGlzLl9zZWN0aW9ucyA9IHNlY3Rpb25zLm1hcChmdW5jdGlvbiAocykge1xuICAgIGlmIChzLnVybCkge1xuICAgICAgLy8gVGhlIHVybCBmaWVsZCB3aWxsIHJlcXVpcmUgc3VwcG9ydCBmb3IgYXN5bmNocm9uaWNpdHkuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMTZcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcG9ydCBmb3IgdXJsIGZpZWxkIGluIHNlY3Rpb25zIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG4gICAgdmFyIG9mZnNldCA9IHV0aWwuZ2V0QXJnKHMsICdvZmZzZXQnKTtcbiAgICB2YXIgb2Zmc2V0TGluZSA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2xpbmUnKTtcbiAgICB2YXIgb2Zmc2V0Q29sdW1uID0gdXRpbC5nZXRBcmcob2Zmc2V0LCAnY29sdW1uJyk7XG5cbiAgICBpZiAob2Zmc2V0TGluZSA8IGxhc3RPZmZzZXQubGluZSB8fFxuICAgICAgICAob2Zmc2V0TGluZSA9PT0gbGFzdE9mZnNldC5saW5lICYmIG9mZnNldENvbHVtbiA8IGxhc3RPZmZzZXQuY29sdW1uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWN0aW9uIG9mZnNldHMgbXVzdCBiZSBvcmRlcmVkIGFuZCBub24tb3ZlcmxhcHBpbmcuJyk7XG4gICAgfVxuICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2VuZXJhdGVkT2Zmc2V0OiB7XG4gICAgICAgIC8vIFRoZSBvZmZzZXQgZmllbGRzIGFyZSAwLWJhc2VkLCBidXQgd2UgdXNlIDEtYmFzZWQgaW5kaWNlcyB3aGVuXG4gICAgICAgIC8vIGVuY29kaW5nL2RlY29kaW5nIGZyb20gVkxRLlxuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBvZmZzZXRMaW5lICsgMSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBvZmZzZXRDb2x1bW4gKyAxXG4gICAgICB9LFxuICAgICAgY29uc3VtZXI6IG5ldyBTb3VyY2VNYXBDb25zdW1lcih1dGlsLmdldEFyZyhzLCAnbWFwJyksIGFTb3VyY2VNYXBVUkwpXG4gICAgfVxuICB9KTtcbn1cblxuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIFRoZSBsaXN0IG9mIG9yaWdpbmFsIHNvdXJjZXMuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc291cmNlcy5wdXNoKHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXNbal0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc291cmNlcztcbiAgfVxufSk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXJcbiAqICAgICBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgY29sdW1uXG4gKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5vcmlnaW5hbFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgLy8gRmluZCB0aGUgc2VjdGlvbiBjb250YWluaW5nIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24gd2UncmUgdHJ5aW5nIHRvIG1hcFxuICAgIC8vIHRvIGFuIG9yaWdpbmFsIHBvc2l0aW9uLlxuICAgIHZhciBzZWN0aW9uSW5kZXggPSBiaW5hcnlTZWFyY2guc2VhcmNoKG5lZWRsZSwgdGhpcy5fc2VjdGlvbnMsXG4gICAgICBmdW5jdGlvbihuZWVkbGUsIHNlY3Rpb24pIHtcbiAgICAgICAgdmFyIGNtcCA9IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC0gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZTtcbiAgICAgICAgaWYgKGNtcCkge1xuICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgIHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbik7XG4gICAgICB9KTtcbiAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW3NlY3Rpb25JbmRleF07XG5cbiAgICBpZiAoIXNlY3Rpb24pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBuYW1lOiBudWxsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBzZWN0aW9uLmNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgbGluZTogbmVlZGxlLmdlbmVyYXRlZExpbmUgLVxuICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgY29sdW1uOiBuZWVkbGUuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IG5lZWRsZS5nZW5lcmF0ZWRMaW5lXG4gICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgIDogMCksXG4gICAgICBiaWFzOiBhQXJncy5iaWFzXG4gICAgfSk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgd2UgaGF2ZSB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGV2ZXJ5IHNvdXJjZSBpbiB0aGUgc291cmNlXG4gKiBtYXAsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcyA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VjdGlvbnMuZXZlcnkoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiBzLmNvbnN1bWVyLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCk7XG4gICAgfSk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gKiBhdmFpbGFibGUuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuXG4gICAgICB2YXIgY29udGVudCA9IHNlY3Rpb24uY29uc3VtZXIuc291cmNlQ29udGVudEZvcihhU291cmNlLCB0cnVlKTtcbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobnVsbE9uTWlzc2luZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU291cmNlICsgJ1wiIGlzIG5vdCBpbiB0aGUgU291cmNlTWFwLicpO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXJcbiAqICAgICBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBjb2x1bW5cbiAqICAgICBudW1iZXIgaXMgMC1iYXNlZC5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLiBcbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuXG4gICAgICAvLyBPbmx5IGNvbnNpZGVyIHRoaXMgc2VjdGlvbiBpZiB0aGUgcmVxdWVzdGVkIHNvdXJjZSBpcyBpbiB0aGUgbGlzdCBvZlxuICAgICAgLy8gc291cmNlcyBvZiB0aGUgY29uc3VtZXIuXG4gICAgICBpZiAoc2VjdGlvbi5jb25zdW1lci5fZmluZFNvdXJjZUluZGV4KHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJykpID09PSAtMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBnZW5lcmF0ZWRQb3NpdGlvbiA9IHNlY3Rpb24uY29uc3VtZXIuZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpO1xuICAgICAgaWYgKGdlbmVyYXRlZFBvc2l0aW9uKSB7XG4gICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgbGluZTogZ2VuZXJhdGVkUG9zaXRpb24ubGluZSArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkUG9zaXRpb24uY29sdW1uICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lXG4gICAgICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICAgICAgOiAwKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsXG4gICAgfTtcbiAgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcbiAgICAgIHZhciBzZWN0aW9uTWFwcGluZ3MgPSBzZWN0aW9uLmNvbnN1bWVyLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VjdGlvbk1hcHBpbmdzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0gc2VjdGlvbk1hcHBpbmdzW2pdO1xuXG4gICAgICAgIHZhciBzb3VyY2UgPSBzZWN0aW9uLmNvbnN1bWVyLl9zb3VyY2VzLmF0KG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgc291cmNlID0gdXRpbC5jb21wdXRlU291cmNlVVJMKHNlY3Rpb24uY29uc3VtZXIuc291cmNlUm9vdCwgc291cmNlLCB0aGlzLl9zb3VyY2VNYXBVUkwpO1xuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcblxuICAgICAgICB2YXIgbmFtZSA9IG51bGw7XG4gICAgICAgIGlmIChtYXBwaW5nLm5hbWUpIHtcbiAgICAgICAgICBuYW1lID0gc2VjdGlvbi5jb25zdW1lci5fbmFtZXMuYXQobWFwcGluZy5uYW1lKTtcbiAgICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgbWFwcGluZ3MgY29taW5nIGZyb20gdGhlIGNvbnN1bWVyIGZvciB0aGUgc2VjdGlvbiBoYXZlXG4gICAgICAgIC8vIGdlbmVyYXRlZCBwb3NpdGlvbnMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBzZWN0aW9uLCBzbyB3ZVxuICAgICAgICAvLyBuZWVkIHRvIG9mZnNldCB0aGVtIHRvIGJlIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgY29uY2F0ZW5hdGVkXG4gICAgICAgIC8vIGdlbmVyYXRlZCBmaWxlLlxuICAgICAgICB2YXIgYWRqdXN0ZWRNYXBwaW5nID0ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IG1hcHBpbmcuZ2VuZXJhdGVkTGluZVxuICAgICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICAgICA6IDApLFxuICAgICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYWRqdXN0ZWRNYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWlja1NvcnQodGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtcbiAgICBxdWlja1NvcnQodGhpcy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICB9O1xuXG5leHBvcnRzLkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciA9IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcjtcbiJdLCJuYW1lcyI6WyJ1dGlsIiwicmVxdWlyZSIsImJpbmFyeVNlYXJjaCIsIkFycmF5U2V0IiwiYmFzZTY0VkxRIiwicXVpY2tTb3J0IiwiU291cmNlTWFwQ29uc3VtZXIiLCJhU291cmNlTWFwIiwiYVNvdXJjZU1hcFVSTCIsInNvdXJjZU1hcCIsInBhcnNlU291cmNlTWFwSW5wdXQiLCJzZWN0aW9ucyIsIkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciIsIkJhc2ljU291cmNlTWFwQ29uc3VtZXIiLCJmcm9tU291cmNlTWFwIiwicHJvdG90eXBlIiwiX3ZlcnNpb24iLCJfX2dlbmVyYXRlZE1hcHBpbmdzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX3BhcnNlTWFwcGluZ3MiLCJfbWFwcGluZ3MiLCJzb3VyY2VSb290IiwiX19vcmlnaW5hbE1hcHBpbmdzIiwiX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IiLCJTb3VyY2VNYXBDb25zdW1lcl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yIiwiYVN0ciIsImluZGV4IiwiYyIsImNoYXJBdCIsIlNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MiLCJhU291cmNlUm9vdCIsIkVycm9yIiwiR0VORVJBVEVEX09SREVSIiwiT1JJR0lOQUxfT1JERVIiLCJHUkVBVEVTVF9MT1dFUl9CT1VORCIsIkxFQVNUX1VQUEVSX0JPVU5EIiwiZWFjaE1hcHBpbmciLCJTb3VyY2VNYXBDb25zdW1lcl9lYWNoTWFwcGluZyIsImFDYWxsYmFjayIsImFDb250ZXh0IiwiYU9yZGVyIiwiY29udGV4dCIsIm9yZGVyIiwibWFwcGluZ3MiLCJfZ2VuZXJhdGVkTWFwcGluZ3MiLCJfb3JpZ2luYWxNYXBwaW5ncyIsImJvdW5kQ2FsbGJhY2siLCJiaW5kIiwibmFtZXMiLCJfbmFtZXMiLCJzb3VyY2VzIiwiX3NvdXJjZXMiLCJzb3VyY2VNYXBVUkwiLCJfc291cmNlTWFwVVJMIiwiaSIsIm4iLCJsZW5ndGgiLCJtYXBwaW5nIiwic291cmNlIiwiYXQiLCJjb21wdXRlU291cmNlVVJMIiwiZ2VuZXJhdGVkTGluZSIsImdlbmVyYXRlZENvbHVtbiIsIm9yaWdpbmFsTGluZSIsIm9yaWdpbmFsQ29sdW1uIiwibmFtZSIsImFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciIsIlNvdXJjZU1hcENvbnN1bWVyX2FsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciIsImFBcmdzIiwibGluZSIsImdldEFyZyIsIm5lZWRsZSIsIl9maW5kU291cmNlSW5kZXgiLCJfZmluZE1hcHBpbmciLCJjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyIsImNvbHVtbiIsInVuZGVmaW5lZCIsInB1c2giLCJsYXN0Q29sdW1uIiwiZXhwb3J0cyIsInZlcnNpb24iLCJzb3VyY2VzQ29udGVudCIsImZpbGUiLCJub3JtYWxpemUiLCJtYXAiLCJTdHJpbmciLCJpc0Fic29sdXRlIiwicmVsYXRpdmUiLCJmcm9tQXJyYXkiLCJfYWJzb2x1dGVTb3VyY2VzIiwidG9BcnJheSIsInMiLCJjcmVhdGUiLCJjb25zdW1lciIsImFTb3VyY2UiLCJyZWxhdGl2ZVNvdXJjZSIsImhhcyIsImluZGV4T2YiLCJTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwIiwic21jIiwiX3NvdXJjZVJvb3QiLCJfZ2VuZXJhdGVTb3VyY2VzQ29udGVudCIsIl9maWxlIiwiZ2VuZXJhdGVkTWFwcGluZ3MiLCJzbGljZSIsImRlc3RHZW5lcmF0ZWRNYXBwaW5ncyIsImRlc3RPcmlnaW5hbE1hcHBpbmdzIiwic3JjTWFwcGluZyIsImRlc3RNYXBwaW5nIiwiTWFwcGluZyIsImNvbXBhcmVHZW5lcmF0ZWQiLCJjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZE5vTGluZSIsInNvcnRHZW5lcmF0ZWQiLCJhcnJheSIsInN0YXJ0IiwibCIsImEiLCJiIiwiaiIsInByZXZpb3VzR2VuZXJhdGVkQ29sdW1uIiwicHJldmlvdXNPcmlnaW5hbExpbmUiLCJwcmV2aW91c09yaWdpbmFsQ29sdW1uIiwicHJldmlvdXNTb3VyY2UiLCJwcmV2aW91c05hbWUiLCJjYWNoZWRTZWdtZW50cyIsInRlbXAiLCJvcmlnaW5hbE1hcHBpbmdzIiwic3RyIiwic2VnbWVudCIsImVuZCIsInZhbHVlIiwic3ViYXJyYXlTdGFydCIsImRlY29kZSIsInJlc3QiLCJjdXJyZW50U291cmNlIiwiY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnNOb1NvdXJjZSIsImNvbmNhdCIsIlNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nIiwiYU5lZWRsZSIsImFNYXBwaW5ncyIsImFMaW5lTmFtZSIsImFDb2x1bW5OYW1lIiwiYUNvbXBhcmF0b3IiLCJhQmlhcyIsIlR5cGVFcnJvciIsInNlYXJjaCIsImNvbXB1dGVDb2x1bW5TcGFucyIsIlNvdXJjZU1hcENvbnN1bWVyX2NvbXB1dGVDb2x1bW5TcGFucyIsIm5leHRNYXBwaW5nIiwibGFzdEdlbmVyYXRlZENvbHVtbiIsIkluZmluaXR5Iiwib3JpZ2luYWxQb3NpdGlvbkZvciIsIlNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IiLCJjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCIsImhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzIiwiQmFzaWNTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcyIsInNpemUiLCJzb21lIiwic2MiLCJzb3VyY2VDb250ZW50Rm9yIiwiU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvciIsIm51bGxPbk1pc3NpbmciLCJ1cmwiLCJ1cmxQYXJzZSIsImZpbGVVcmlBYnNQYXRoIiwicmVwbGFjZSIsInNjaGVtZSIsInBhdGgiLCJnZW5lcmF0ZWRQb3NpdGlvbkZvciIsIlNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yIiwibGFzdE9mZnNldCIsIl9zZWN0aW9ucyIsIm9mZnNldCIsIm9mZnNldExpbmUiLCJvZmZzZXRDb2x1bW4iLCJnZW5lcmF0ZWRPZmZzZXQiLCJjb25zdHJ1Y3RvciIsIkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yIiwic2VjdGlvbkluZGV4Iiwic2VjdGlvbiIsImNtcCIsImJpYXMiLCJJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMiLCJldmVyeSIsIkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yIiwiY29udGVudCIsIkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvciIsImdlbmVyYXRlZFBvc2l0aW9uIiwicmV0IiwiSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MiLCJzZWN0aW9uTWFwcGluZ3MiLCJhZGQiLCJhZGp1c3RlZE1hcHBpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../source-map-js/lib/source-map-consumer.js\n");

/***/ }),

/***/ "(action-browser)/../source-map-js/lib/source-map-generator.js":
/*!****************************************************!*\
  !*** ../source-map-js/lib/source-map-generator.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var base64VLQ = __webpack_require__(/*! ./base64-vlq */ \"(action-browser)/../source-map-js/lib/base64-vlq.js\");\nvar util = __webpack_require__(/*! ./util */ \"(action-browser)/../source-map-js/lib/util.js\");\nvar ArraySet = (__webpack_require__(/*! ./array-set */ \"(action-browser)/../source-map-js/lib/array-set.js\").ArraySet);\nvar MappingList = (__webpack_require__(/*! ./mapping-list */ \"(action-browser)/../source-map-js/lib/mapping-list.js\").MappingList);\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */ function SourceMapGenerator(aArgs) {\n    if (!aArgs) {\n        aArgs = {};\n    }\n    this._file = util.getArg(aArgs, \"file\", null);\n    this._sourceRoot = util.getArg(aArgs, \"sourceRoot\", null);\n    this._skipValidation = util.getArg(aArgs, \"skipValidation\", false);\n    this._sources = new ArraySet();\n    this._names = new ArraySet();\n    this._mappings = new MappingList();\n    this._sourcesContents = null;\n}\nSourceMapGenerator.prototype._version = 3;\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */ SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n        file: aSourceMapConsumer.file,\n        sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function(mapping) {\n        var newMapping = {\n            generated: {\n                line: mapping.generatedLine,\n                column: mapping.generatedColumn\n            }\n        };\n        if (mapping.source != null) {\n            newMapping.source = mapping.source;\n            if (sourceRoot != null) {\n                newMapping.source = util.relative(sourceRoot, newMapping.source);\n            }\n            newMapping.original = {\n                line: mapping.originalLine,\n                column: mapping.originalColumn\n            };\n            if (mapping.name != null) {\n                newMapping.name = mapping.name;\n            }\n        }\n        generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function(sourceFile) {\n        var sourceRelative = sourceFile;\n        if (sourceRoot !== null) {\n            sourceRelative = util.relative(sourceRoot, sourceFile);\n        }\n        if (!generator._sources.has(sourceRelative)) {\n            generator._sources.add(sourceRelative);\n        }\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n            generator.setSourceContent(sourceFile, content);\n        }\n    });\n    return generator;\n};\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */ SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, \"generated\");\n    var original = util.getArg(aArgs, \"original\", null);\n    var source = util.getArg(aArgs, \"source\", null);\n    var name = util.getArg(aArgs, \"name\", null);\n    if (!this._skipValidation) {\n        this._validateMapping(generated, original, source, name);\n    }\n    if (source != null) {\n        source = String(source);\n        if (!this._sources.has(source)) {\n            this._sources.add(source);\n        }\n    }\n    if (name != null) {\n        name = String(name);\n        if (!this._names.has(name)) {\n            this._names.add(name);\n        }\n    }\n    this._mappings.add({\n        generatedLine: generated.line,\n        generatedColumn: generated.column,\n        originalLine: original != null && original.line,\n        originalColumn: original != null && original.column,\n        source: source,\n        name: name\n    });\n};\n/**\n * Set the source content for a source file.\n */ SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n        source = util.relative(this._sourceRoot, source);\n    }\n    if (aSourceContent != null) {\n        // Add the source content to the _sourcesContents map.\n        // Create a new _sourcesContents map if the property is null.\n        if (!this._sourcesContents) {\n            this._sourcesContents = Object.create(null);\n        }\n        this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n        // Remove the source file from the _sourcesContents map.\n        // If the _sourcesContents map is empty, set the property to null.\n        delete this._sourcesContents[util.toSetString(source)];\n        if (Object.keys(this._sourcesContents).length === 0) {\n            this._sourcesContents = null;\n        }\n    }\n};\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */ SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n        if (aSourceMapConsumer.file == null) {\n            throw new Error(\"SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, \" + 'or the source map\\'s \"file\" property. Both were omitted.');\n        }\n        sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n        sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function(mapping) {\n        if (mapping.source === sourceFile && mapping.originalLine != null) {\n            // Check if it can be mapped by the source map, then update the mapping.\n            var original = aSourceMapConsumer.originalPositionFor({\n                line: mapping.originalLine,\n                column: mapping.originalColumn\n            });\n            if (original.source != null) {\n                // Copy mapping\n                mapping.source = original.source;\n                if (aSourceMapPath != null) {\n                    mapping.source = util.join(aSourceMapPath, mapping.source);\n                }\n                if (sourceRoot != null) {\n                    mapping.source = util.relative(sourceRoot, mapping.source);\n                }\n                mapping.originalLine = original.line;\n                mapping.originalColumn = original.column;\n                if (original.name != null) {\n                    mapping.name = original.name;\n                }\n            }\n        }\n        var source = mapping.source;\n        if (source != null && !newSources.has(source)) {\n            newSources.add(source);\n        }\n        var name = mapping.name;\n        if (name != null && !newNames.has(name)) {\n            newNames.add(name);\n        }\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function(sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n            if (aSourceMapPath != null) {\n                sourceFile = util.join(aSourceMapPath, sourceFile);\n            }\n            if (sourceRoot != null) {\n                sourceFile = util.relative(sourceRoot, sourceFile);\n            }\n            this.setSourceContent(sourceFile, content);\n        }\n    }, this);\n};\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */ SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== \"number\" && typeof aOriginal.column !== \"number\") {\n        throw new Error(\"original.line and original.column are not numbers -- you probably meant to omit \" + \"the original mapping entirely and only map the generated position. If so, pass \" + \"null for the original mapping instead of an object with empty or null values.\");\n    }\n    if (aGenerated && \"line\" in aGenerated && \"column\" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {\n        // Case 1.\n        return;\n    } else if (aGenerated && \"line\" in aGenerated && \"column\" in aGenerated && aOriginal && \"line\" in aOriginal && \"column\" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {\n        // Cases 2 and 3.\n        return;\n    } else {\n        throw new Error(\"Invalid mapping: \" + JSON.stringify({\n            generated: aGenerated,\n            source: aSource,\n            original: aOriginal,\n            name: aName\n        }));\n    }\n};\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */ SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = \"\";\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n    var mappings = this._mappings.toArray();\n    for(var i = 0, len = mappings.length; i < len; i++){\n        mapping = mappings[i];\n        next = \"\";\n        if (mapping.generatedLine !== previousGeneratedLine) {\n            previousGeneratedColumn = 0;\n            while(mapping.generatedLine !== previousGeneratedLine){\n                next += \";\";\n                previousGeneratedLine++;\n            }\n        } else {\n            if (i > 0) {\n                if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n                    continue;\n                }\n                next += \",\";\n            }\n        }\n        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);\n        previousGeneratedColumn = mapping.generatedColumn;\n        if (mapping.source != null) {\n            sourceIdx = this._sources.indexOf(mapping.source);\n            next += base64VLQ.encode(sourceIdx - previousSource);\n            previousSource = sourceIdx;\n            // lines are stored 0-based in SourceMap spec version 3\n            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);\n            previousOriginalLine = mapping.originalLine - 1;\n            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);\n            previousOriginalColumn = mapping.originalColumn;\n            if (mapping.name != null) {\n                nameIdx = this._names.indexOf(mapping.name);\n                next += base64VLQ.encode(nameIdx - previousName);\n                previousName = nameIdx;\n            }\n        }\n        result += next;\n    }\n    return result;\n};\nSourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function(source) {\n        if (!this._sourcesContents) {\n            return null;\n        }\n        if (aSourceRoot != null) {\n            source = util.relative(aSourceRoot, source);\n        }\n        var key = util.toSetString(source);\n        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;\n    }, this);\n};\n/**\n * Externalize the source map.\n */ SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {\n    var map = {\n        version: this._version,\n        sources: this._sources.toArray(),\n        names: this._names.toArray(),\n        mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n        map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n        map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n    return map;\n};\n/**\n * Render the source map being generated to a string.\n */ SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n};\nexports.SourceMapGenerator = SourceMapGenerator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9zb3VyY2UtbWFwLWpzL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5Q0FBeUMsR0FDekM7Ozs7Q0FJQyxHQUVELElBQUlBLFlBQVlDLG1CQUFPQSxDQUFDO0FBQ3hCLElBQUlDLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ25CLElBQUlFLFdBQVdGLHVHQUErQjtBQUM5QyxJQUFJRyxjQUFjSCxnSEFBcUM7QUFFdkQ7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNJLG1CQUFtQkMsS0FBSztJQUMvQixJQUFJLENBQUNBLE9BQU87UUFDVkEsUUFBUSxDQUFDO0lBQ1g7SUFDQSxJQUFJLENBQUNDLEtBQUssR0FBR0wsS0FBS00sTUFBTSxDQUFDRixPQUFPLFFBQVE7SUFDeEMsSUFBSSxDQUFDRyxXQUFXLEdBQUdQLEtBQUtNLE1BQU0sQ0FBQ0YsT0FBTyxjQUFjO0lBQ3BELElBQUksQ0FBQ0ksZUFBZSxHQUFHUixLQUFLTSxNQUFNLENBQUNGLE9BQU8sa0JBQWtCO0lBQzVELElBQUksQ0FBQ0ssUUFBUSxHQUFHLElBQUlSO0lBQ3BCLElBQUksQ0FBQ1MsTUFBTSxHQUFHLElBQUlUO0lBQ2xCLElBQUksQ0FBQ1UsU0FBUyxHQUFHLElBQUlUO0lBQ3JCLElBQUksQ0FBQ1UsZ0JBQWdCLEdBQUc7QUFDMUI7QUFFQVQsbUJBQW1CVSxTQUFTLENBQUNDLFFBQVEsR0FBRztBQUV4Qzs7OztDQUlDLEdBQ0RYLG1CQUFtQlksYUFBYSxHQUM5QixTQUFTQyxpQ0FBaUNDLGtCQUFrQjtJQUMxRCxJQUFJQyxhQUFhRCxtQkFBbUJDLFVBQVU7SUFDOUMsSUFBSUMsWUFBWSxJQUFJaEIsbUJBQW1CO1FBQ3JDaUIsTUFBTUgsbUJBQW1CRyxJQUFJO1FBQzdCRixZQUFZQTtJQUNkO0lBQ0FELG1CQUFtQkksV0FBVyxDQUFDLFNBQVVDLE9BQU87UUFDOUMsSUFBSUMsYUFBYTtZQUNmQyxXQUFXO2dCQUNUQyxNQUFNSCxRQUFRSSxh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SUFBSSxDQUFDcEYsZ0JBQWdCLENBQUNvRixJQUFJLEdBQzFCO0lBQ04sR0FBRyxJQUFJO0FBQ1Q7QUFFRjs7Q0FFQyxHQUNEN0YsbUJBQW1CVSxTQUFTLENBQUNzRixNQUFNLEdBQ2pDLFNBQVNDO0lBQ1AsSUFBSUwsTUFBTTtRQUNSTSxTQUFTLElBQUksQ0FBQ3ZGLFFBQVE7UUFDdEJzQixTQUFTLElBQUksQ0FBQzNCLFFBQVEsQ0FBQzRFLE9BQU87UUFDOUJpQixPQUFPLElBQUksQ0FBQzVGLE1BQU0sQ0FBQzJFLE9BQU87UUFDMUJELFVBQVUsSUFBSSxDQUFDWixrQkFBa0I7SUFDbkM7SUFDQSxJQUFJLElBQUksQ0FBQ25FLEtBQUssSUFBSSxNQUFNO1FBQ3RCMEYsSUFBSTNFLElBQUksR0FBRyxJQUFJLENBQUNmLEtBQUs7SUFDdkI7SUFDQSxJQUFJLElBQUksQ0FBQ0UsV0FBVyxJQUFJLE1BQU07UUFDNUJ3RixJQUFJN0UsVUFBVSxHQUFHLElBQUksQ0FBQ1gsV0FBVztJQUNuQztJQUNBLElBQUksSUFBSSxDQUFDSyxnQkFBZ0IsRUFBRTtRQUN6Qm1GLElBQUlRLGNBQWMsR0FBRyxJQUFJLENBQUNaLHVCQUF1QixDQUFDSSxJQUFJM0QsT0FBTyxFQUFFMkQsSUFBSTdFLFVBQVU7SUFDL0U7SUFFQSxPQUFPNkU7QUFDVDtBQUVGOztDQUVDLEdBQ0Q1RixtQkFBbUJVLFNBQVMsQ0FBQzJGLFFBQVEsR0FDbkMsU0FBU0M7SUFDUCxPQUFPbkMsS0FBS0MsU0FBUyxDQUFDLElBQUksQ0FBQzRCLE1BQU07QUFDbkM7QUFFRk8sMEJBQTBCLEdBQUd2RyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWVtYWlsLy4uL3NvdXJjZS1tYXAtanMvbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yLmpzPzQ1NDEiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbnZhciBNYXBwaW5nTGlzdCA9IHJlcXVpcmUoJy4vbWFwcGluZy1saXN0JykuTWFwcGluZ0xpc3Q7XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhlIFNvdXJjZU1hcEdlbmVyYXRvciByZXByZXNlbnRzIGEgc291cmNlIG1hcCB3aGljaCBpc1xuICogYmVpbmcgYnVpbHQgaW5jcmVtZW50YWxseS4gWW91IG1heSBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGZpbGU6IFRoZSBmaWxlbmFtZSBvZiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBzb3VyY2VSb290OiBBIHJvb3QgZm9yIGFsbCByZWxhdGl2ZSBVUkxzIGluIHRoaXMgc291cmNlIG1hcC5cbiAqL1xuZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKSB7XG4gIGlmICghYUFyZ3MpIHtcbiAgICBhQXJncyA9IHt9O1xuICB9XG4gIHRoaXMuX2ZpbGUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2ZpbGUnLCBudWxsKTtcbiAgdGhpcy5fc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICB0aGlzLl9za2lwVmFsaWRhdGlvbiA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc2tpcFZhbGlkYXRpb24nLCBmYWxzZSk7XG4gIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbWFwcGluZ3MgPSBuZXcgTWFwcGluZ0xpc3QoKTtcbiAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbn1cblxuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IgYmFzZWQgb24gYSBTb3VyY2VNYXBDb25zdW1lclxuICpcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLmZyb21Tb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIpIHtcbiAgICB2YXIgc291cmNlUm9vdCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VSb290O1xuICAgIHZhciBnZW5lcmF0b3IgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKHtcbiAgICAgIGZpbGU6IGFTb3VyY2VNYXBDb25zdW1lci5maWxlLFxuICAgICAgc291cmNlUm9vdDogc291cmNlUm9vdFxuICAgIH0pO1xuICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgdmFyIG5ld01hcHBpbmcgPSB7XG4gICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbmV3TWFwcGluZy5zb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3TWFwcGluZy5vcmlnaW5hbCA9IHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLm5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZ2VuZXJhdG9yLmFkZE1hcHBpbmcobmV3TWFwcGluZyk7XG4gICAgfSk7XG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIHNvdXJjZVJlbGF0aXZlID0gc291cmNlRmlsZTtcbiAgICAgIGlmIChzb3VyY2VSb290ICE9PSBudWxsKSB7XG4gICAgICAgIHNvdXJjZVJlbGF0aXZlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFnZW5lcmF0b3IuX3NvdXJjZXMuaGFzKHNvdXJjZVJlbGF0aXZlKSkge1xuICAgICAgICBnZW5lcmF0b3IuX3NvdXJjZXMuYWRkKHNvdXJjZVJlbGF0aXZlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdG9yLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfTtcblxuLyoqXG4gKiBBZGQgYSBzaW5nbGUgbWFwcGluZyBmcm9tIG9yaWdpbmFsIHNvdXJjZSBsaW5lIGFuZCBjb2x1bW4gdG8gdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIGZvciB0aGlzIHNvdXJjZSBtYXAgYmVpbmcgY3JlYXRlZC4gVGhlIG1hcHBpbmdcbiAqIG9iamVjdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGdlbmVyYXRlZDogQW4gb2JqZWN0IHdpdGggdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICogICAtIG9yaWdpbmFsOiBBbiBvYmplY3Qgd2l0aCB0aGUgb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSAocmVsYXRpdmUgdG8gdGhlIHNvdXJjZVJvb3QpLlxuICogICAtIG5hbWU6IEFuIG9wdGlvbmFsIG9yaWdpbmFsIHRva2VuIG5hbWUgZm9yIHRoaXMgbWFwcGluZy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hZGRNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FkZE1hcHBpbmcoYUFyZ3MpIHtcbiAgICB2YXIgZ2VuZXJhdGVkID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdnZW5lcmF0ZWQnKTtcbiAgICB2YXIgb3JpZ2luYWwgPSB1dGlsLmdldEFyZyhhQXJncywgJ29yaWdpbmFsJywgbnVsbCk7XG4gICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJywgbnVsbCk7XG4gICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhhQXJncywgJ25hbWUnLCBudWxsKTtcblxuICAgIGlmICghdGhpcy5fc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlTWFwcGluZyhnZW5lcmF0ZWQsIG9yaWdpbmFsLCBzb3VyY2UsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgc291cmNlID0gU3RyaW5nKHNvdXJjZSk7XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgICAgaWYgKCF0aGlzLl9uYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX21hcHBpbmdzLmFkZCh7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogZ2VuZXJhdGVkLmNvbHVtbixcbiAgICAgIG9yaWdpbmFsTGluZTogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5saW5lLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwuY29sdW1uLFxuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBuYW1lOiBuYW1lXG4gICAgfSk7XG4gIH07XG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgdmFyIHNvdXJjZSA9IGFTb3VyY2VGaWxlO1xuICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5fc291cmNlUm9vdCwgc291cmNlKTtcbiAgICB9XG5cbiAgICBpZiAoYVNvdXJjZUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgY29udGVudCB0byB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgX3NvdXJjZXNDb250ZW50cyBtYXAgaWYgdGhlIHByb3BlcnR5IGlzIG51bGwuXG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV0gPSBhU291cmNlQ29udGVudDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBzb3VyY2UgZmlsZSBmcm9tIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgIC8vIElmIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcCBpcyBlbXB0eSwgc2V0IHRoZSBwcm9wZXJ0eSB0byBudWxsLlxuICAgICAgZGVsZXRlIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX3NvdXJjZXNDb250ZW50cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIG1hcHBpbmdzIG9mIGEgc3ViLXNvdXJjZS1tYXAgZm9yIGEgc3BlY2lmaWMgc291cmNlIGZpbGUgdG8gdGhlXG4gKiBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZC4gRWFjaCBtYXBwaW5nIHRvIHRoZSBzdXBwbGllZCBzb3VyY2UgZmlsZSBpc1xuICogcmV3cml0dGVuIHVzaW5nIHRoZSBzdXBwbGllZCBzb3VyY2UgbWFwLiBOb3RlOiBUaGUgcmVzb2x1dGlvbiBmb3IgdGhlXG4gKiByZXN1bHRpbmcgbWFwcGluZ3MgaXMgdGhlIG1pbmltaXVtIG9mIHRoaXMgbWFwIGFuZCB0aGUgc3VwcGxpZWQgbWFwLlxuICpcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZC5cbiAqIEBwYXJhbSBhU291cmNlRmlsZSBPcHRpb25hbC4gVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZS5cbiAqICAgICAgICBJZiBvbWl0dGVkLCBTb3VyY2VNYXBDb25zdW1lcidzIGZpbGUgcHJvcGVydHkgd2lsbCBiZSB1c2VkLlxuICogQHBhcmFtIGFTb3VyY2VNYXBQYXRoIE9wdGlvbmFsLiBUaGUgZGlybmFtZSBvZiB0aGUgcGF0aCB0byB0aGUgc291cmNlIG1hcFxuICogICAgICAgIHRvIGJlIGFwcGxpZWQuIElmIHJlbGF0aXZlLCBpdCBpcyByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwQ29uc3VtZXIuXG4gKiAgICAgICAgVGhpcyBwYXJhbWV0ZXIgaXMgbmVlZGVkIHdoZW4gdGhlIHR3byBzb3VyY2UgbWFwcyBhcmVuJ3QgaW4gdGhlIHNhbWVcbiAqICAgICAgICBkaXJlY3RvcnksIGFuZCB0aGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkIGNvbnRhaW5zIHJlbGF0aXZlIHNvdXJjZVxuICogICAgICAgIHBhdGhzLiBJZiBzbywgdGhvc2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIG5lZWQgdG8gYmUgcmV3cml0dGVuXG4gKiAgICAgICAgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hcHBseVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIsIGFTb3VyY2VGaWxlLCBhU291cmNlTWFwUGF0aCkge1xuICAgIHZhciBzb3VyY2VGaWxlID0gYVNvdXJjZUZpbGU7XG4gICAgLy8gSWYgYVNvdXJjZUZpbGUgaXMgb21pdHRlZCwgd2Ugd2lsbCB1c2UgdGhlIGZpbGUgcHJvcGVydHkgb2YgdGhlIFNvdXJjZU1hcFxuICAgIGlmIChhU291cmNlRmlsZSA9PSBudWxsKSB7XG4gICAgICBpZiAoYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1NvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgcmVxdWlyZXMgZWl0aGVyIGFuIGV4cGxpY2l0IHNvdXJjZSBmaWxlLCAnICtcbiAgICAgICAgICAnb3IgdGhlIHNvdXJjZSBtYXBcXCdzIFwiZmlsZVwiIHByb3BlcnR5LiBCb3RoIHdlcmUgb21pdHRlZC4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzb3VyY2VGaWxlID0gYVNvdXJjZU1hcENvbnN1bWVyLmZpbGU7XG4gICAgfVxuICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICAvLyBNYWtlIFwic291cmNlRmlsZVwiIHJlbGF0aXZlIGlmIGFuIGFic29sdXRlIFVybCBpcyBwYXNzZWQuXG4gICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgfVxuICAgIC8vIEFwcGx5aW5nIHRoZSBTb3VyY2VNYXAgY2FuIGFkZCBhbmQgcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIHNvdXJjZXMgYW5kXG4gICAgLy8gdGhlIG5hbWVzIGFycmF5LlxuICAgIHZhciBuZXdTb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgdmFyIG5ld05hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgICAvLyBGaW5kIG1hcHBpbmdzIGZvciB0aGUgXCJzb3VyY2VGaWxlXCJcbiAgICB0aGlzLl9tYXBwaW5ncy51bnNvcnRlZEZvckVhY2goZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gc291cmNlRmlsZSAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGl0IGNhbiBiZSBtYXBwZWQgYnkgdGhlIHNvdXJjZSBtYXAsIHRoZW4gdXBkYXRlIHRoZSBtYXBwaW5nLlxuICAgICAgICB2YXIgb3JpZ2luYWwgPSBhU291cmNlTWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3JpZ2luYWwuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDb3B5IG1hcHBpbmdcbiAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgICAgICBpZiAob3JpZ2luYWwubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgIW5ld1NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgbmV3U291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICBpZiAobmFtZSAhPSBudWxsICYmICFuZXdOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgbmV3TmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuXG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fc291cmNlcyA9IG5ld1NvdXJjZXM7XG4gICAgdGhpcy5fbmFtZXMgPSBuZXdOYW1lcztcblxuICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnRzIG9mIGFwcGxpZWQgbWFwLlxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuLyoqXG4gKiBBIG1hcHBpbmcgY2FuIGhhdmUgb25lIG9mIHRoZSB0aHJlZSBsZXZlbHMgb2YgZGF0YTpcbiAqXG4gKiAgIDEuIEp1c3QgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAqICAgMi4gVGhlIEdlbmVyYXRlZCBwb3NpdGlvbiwgb3JpZ2luYWwgcG9zaXRpb24sIGFuZCBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIDMuIEdlbmVyYXRlZCBhbmQgb3JpZ2luYWwgcG9zaXRpb24sIG9yaWdpbmFsIHNvdXJjZSwgYXMgd2VsbCBhcyBhIG5hbWVcbiAqICAgICAgdG9rZW4uXG4gKlxuICogVG8gbWFpbnRhaW4gY29uc2lzdGVuY3ksIHdlIHZhbGlkYXRlIHRoYXQgYW55IG5ldyBtYXBwaW5nIGJlaW5nIGFkZGVkIGZhbGxzXG4gKiBpbiB0byBvbmUgb2YgdGhlc2UgY2F0ZWdvcmllcy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3ZhbGlkYXRlTWFwcGluZyhhR2VuZXJhdGVkLCBhT3JpZ2luYWwsIGFTb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYU5hbWUpIHtcbiAgICAvLyBXaGVuIGFPcmlnaW5hbCBpcyB0cnV0aHkgYnV0IGhhcyBlbXB0eSB2YWx1ZXMgZm9yIC5saW5lIGFuZCAuY29sdW1uLFxuICAgIC8vIGl0IGlzIG1vc3QgbGlrZWx5IGEgcHJvZ3JhbW1lciBlcnJvci4gSW4gdGhpcyBjYXNlIHdlIHRocm93IGEgdmVyeVxuICAgIC8vIHNwZWNpZmljIGVycm9yIG1lc3NhZ2UgdG8gdHJ5IHRvIGd1aWRlIHRoZW0gdGhlIHJpZ2h0IHdheS5cbiAgICAvLyBGb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvcG9seW1lci1idW5kbGVyL3B1bGwvNTE5XG4gICAgaWYgKGFPcmlnaW5hbCAmJiB0eXBlb2YgYU9yaWdpbmFsLmxpbmUgIT09ICdudW1iZXInICYmIHR5cGVvZiBhT3JpZ2luYWwuY29sdW1uICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnb3JpZ2luYWwubGluZSBhbmQgb3JpZ2luYWwuY29sdW1uIGFyZSBub3QgbnVtYmVycyAtLSB5b3UgcHJvYmFibHkgbWVhbnQgdG8gb21pdCAnICtcbiAgICAgICAgICAgICd0aGUgb3JpZ2luYWwgbWFwcGluZyBlbnRpcmVseSBhbmQgb25seSBtYXAgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbi4gSWYgc28sIHBhc3MgJyArXG4gICAgICAgICAgICAnbnVsbCBmb3IgdGhlIG9yaWdpbmFsIG1hcHBpbmcgaW5zdGVhZCBvZiBhbiBvYmplY3Qgd2l0aCBlbXB0eSBvciBudWxsIHZhbHVlcy4nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgJiYgIWFPcmlnaW5hbCAmJiAhYVNvdXJjZSAmJiAhYU5hbWUpIHtcbiAgICAgIC8vIENhc2UgMS5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICAgICAgJiYgYU9yaWdpbmFsICYmICdsaW5lJyBpbiBhT3JpZ2luYWwgJiYgJ2NvbHVtbicgaW4gYU9yaWdpbmFsXG4gICAgICAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgJiYgYU9yaWdpbmFsLmxpbmUgPiAwICYmIGFPcmlnaW5hbC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICYmIGFTb3VyY2UpIHtcbiAgICAgIC8vIENhc2VzIDIgYW5kIDMuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hcHBpbmc6ICcgKyBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGdlbmVyYXRlZDogYUdlbmVyYXRlZCxcbiAgICAgICAgc291cmNlOiBhU291cmNlLFxuICAgICAgICBvcmlnaW5hbDogYU9yaWdpbmFsLFxuICAgICAgICBuYW1lOiBhTmFtZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIHRvIHRoZSBzdHJlYW0gb2YgYmFzZSA2NCBWTFFzXG4gKiBzcGVjaWZpZWQgYnkgdGhlIHNvdXJjZSBtYXAgZm9ybWF0LlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9zZXJpYWxpemVNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXJpYWxpemVNYXBwaW5ncygpIHtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZExpbmUgPSAxO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBuZXh0O1xuICAgIHZhciBtYXBwaW5nO1xuICAgIHZhciBuYW1lSWR4O1xuICAgIHZhciBzb3VyY2VJZHg7XG5cbiAgICB2YXIgbWFwcGluZ3MgPSB0aGlzLl9tYXBwaW5ncy50b0FycmF5KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBtYXBwaW5nID0gbWFwcGluZ3NbaV07XG4gICAgICBuZXh0ID0gJydcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgd2hpbGUgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbmV4dCArPSAnOyc7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBpZiAoIXV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZywgbWFwcGluZ3NbaSAtIDFdKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHQgKz0gJywnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbik7XG4gICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2VJZHggPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUoc291cmNlSWR4IC0gcHJldmlvdXNTb3VyY2UpO1xuICAgICAgICBwcmV2aW91c1NvdXJjZSA9IHNvdXJjZUlkeDtcblxuICAgICAgICAvLyBsaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWQgaW4gU291cmNlTWFwIHNwZWMgdmVyc2lvbiAzXG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsTGluZSk7XG4gICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmUgLSAxO1xuXG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbENvbHVtbik7XG4gICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgIG5hbWVJZHggPSB0aGlzLl9uYW1lcy5pbmRleE9mKG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG5hbWVJZHggLSBwcmV2aW91c05hbWUpO1xuICAgICAgICAgIHByZXZpb3VzTmFtZSA9IG5hbWVJZHg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9IG5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KGFTb3VyY2VzLCBhU291cmNlUm9vdCkge1xuICAgIHJldHVybiBhU291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoYVNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKGFTb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHV0aWwudG9TZXRTdHJpbmcoc291cmNlKTtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fc291cmNlc0NvbnRlbnRzLCBrZXkpXG4gICAgICAgID8gdGhpcy5fc291cmNlc0NvbnRlbnRzW2tleV1cbiAgICAgICAgOiBudWxsO1xuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4vKipcbiAqIEV4dGVybmFsaXplIHRoZSBzb3VyY2UgbWFwLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvSlNPTiA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b0pTT04oKSB7XG4gICAgdmFyIG1hcCA9IHtcbiAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXG4gICAgICBzb3VyY2VzOiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgIG5hbWVzOiB0aGlzLl9uYW1lcy50b0FycmF5KCksXG4gICAgICBtYXBwaW5nczogdGhpcy5fc2VyaWFsaXplTWFwcGluZ3MoKVxuICAgIH07XG4gICAgaWYgKHRoaXMuX2ZpbGUgIT0gbnVsbCkge1xuICAgICAgbWFwLmZpbGUgPSB0aGlzLl9maWxlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBtYXAuc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IHRoaXMuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQobWFwLnNvdXJjZXMsIG1hcC5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xuICB9O1xuXG4vKipcbiAqIFJlbmRlciB0aGUgc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQgdG8gYSBzdHJpbmcuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCkpO1xuICB9O1xuXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IFNvdXJjZU1hcEdlbmVyYXRvcjtcbiJdLCJuYW1lcyI6WyJiYXNlNjRWTFEiLCJyZXF1aXJlIiwidXRpbCIsIkFycmF5U2V0IiwiTWFwcGluZ0xpc3QiLCJTb3VyY2VNYXBHZW5lcmF0b3IiLCJhQXJncyIsIl9maWxlIiwiZ2V0QXJnIiwiX3NvdXJjZVJvb3QiLCJfc2tpcFZhbGlkYXRpb24iLCJfc291cmNlcyIsIl9uYW1lcyIsIl9tYXBwaW5ncyIsIl9zb3VyY2VzQ29udGVudHMiLCJwcm90b3R5cGUiLCJfdmVyc2lvbiIsImZyb21Tb3VyY2VNYXAiLCJTb3VyY2VNYXBHZW5lcmF0b3JfZnJvbVNvdXJjZU1hcCIsImFTb3VyY2VNYXBDb25zdW1lciIsInNvdXJjZVJvb3QiLCJnZW5lcmF0b3IiLCJmaWxlIiwiZWFjaE1hcHBpbmciLCJtYXBwaW5nIiwibmV3TWFwcGluZyIsImdlbmVyYXRlZCIsImxpbmUiLCJnZW5lcmF0ZWRMaW5lIiwiY29sdW1uIiwiZ2VuZXJhdGVkQ29sdW1uIiwic291cmNlIiwicmVsYXRpdmUiLCJvcmlnaW5hbCIsIm9yaWdpbmFsTGluZSIsIm9yaWdpbmFsQ29sdW1uIiwibmFtZSIsImFkZE1hcHBpbmciLCJzb3VyY2VzIiwiZm9yRWFjaCIsInNvdXJjZUZpbGUiLCJzb3VyY2VSZWxhdGl2ZSIsImhhcyIsImFkZCIsImNvbnRlbnQiLCJzb3VyY2VDb250ZW50Rm9yIiwic2V0U291cmNlQ29udGVudCIsIlNvdXJjZU1hcEdlbmVyYXRvcl9hZGRNYXBwaW5nIiwiX3ZhbGlkYXRlTWFwcGluZyIsIlN0cmluZyIsIlNvdXJjZU1hcEdlbmVyYXRvcl9zZXRTb3VyY2VDb250ZW50IiwiYVNvdXJjZUZpbGUiLCJhU291cmNlQ29udGVudCIsIk9iamVjdCIsImNyZWF0ZSIsInRvU2V0U3RyaW5nIiwia2V5cyIsImxlbmd0aCIsImFwcGx5U291cmNlTWFwIiwiU291cmNlTWFwR2VuZXJhdG9yX2FwcGx5U291cmNlTWFwIiwiYVNvdXJjZU1hcFBhdGgiLCJFcnJvciIsIm5ld1NvdXJjZXMiLCJuZXdOYW1lcyIsInVuc29ydGVkRm9yRWFjaCIsIm9yaWdpbmFsUG9zaXRpb25Gb3IiLCJqb2luIiwiU291cmNlTWFwR2VuZXJhdG9yX3ZhbGlkYXRlTWFwcGluZyIsImFHZW5lcmF0ZWQiLCJhT3JpZ2luYWwiLCJhU291cmNlIiwiYU5hbWUiLCJKU09OIiwic3RyaW5naWZ5IiwiX3NlcmlhbGl6ZU1hcHBpbmdzIiwiU291cmNlTWFwR2VuZXJhdG9yX3NlcmlhbGl6ZU1hcHBpbmdzIiwicHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4iLCJwcmV2aW91c0dlbmVyYXRlZExpbmUiLCJwcmV2aW91c09yaWdpbmFsQ29sdW1uIiwicHJldmlvdXNPcmlnaW5hbExpbmUiLCJwcmV2aW91c05hbWUiLCJwcmV2aW91c1NvdXJjZSIsInJlc3VsdCIsIm5leHQiLCJuYW1lSWR4Iiwic291cmNlSWR4IiwibWFwcGluZ3MiLCJ0b0FycmF5IiwiaSIsImxlbiIsImNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkIiwiZW5jb2RlIiwiaW5kZXhPZiIsIl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50IiwiU291cmNlTWFwR2VuZXJhdG9yX2dlbmVyYXRlU291cmNlc0NvbnRlbnQiLCJhU291cmNlcyIsImFTb3VyY2VSb290IiwibWFwIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidG9KU09OIiwiU291cmNlTWFwR2VuZXJhdG9yX3RvSlNPTiIsInZlcnNpb24iLCJuYW1lcyIsInNvdXJjZXNDb250ZW50IiwidG9TdHJpbmciLCJTb3VyY2VNYXBHZW5lcmF0b3JfdG9TdHJpbmciLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/../source-map-js/lib/source-map-generator.js\n");

/***/ }),

/***/ "(rsc)/../source-map-js/lib/source-map-generator.js":
/*!****************************************************!*\
  !*** ../source-map-js/lib/source-map-generator.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var base64VLQ = __webpack_require__(/*! ./base64-vlq */ \"(rsc)/../source-map-js/lib/base64-vlq.js\");\nvar util = __webpack_require__(/*! ./util */ \"(rsc)/../source-map-js/lib/util.js\");\nvar ArraySet = (__webpack_require__(/*! ./array-set */ \"(rsc)/../source-map-js/lib/array-set.js\").ArraySet);\nvar MappingList = (__webpack_require__(/*! ./mapping-list */ \"(rsc)/../source-map-js/lib/mapping-list.js\").MappingList);\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */ function SourceMapGenerator(aArgs) {\n    if (!aArgs) {\n        aArgs = {};\n    }\n    this._file = util.getArg(aArgs, \"file\", null);\n    this._sourceRoot = util.getArg(aArgs, \"sourceRoot\", null);\n    this._skipValidation = util.getArg(aArgs, \"skipValidation\", false);\n    this._sources = new ArraySet();\n    this._names = new ArraySet();\n    this._mappings = new MappingList();\n    this._sourcesContents = null;\n}\nSourceMapGenerator.prototype._version = 3;\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */ SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n        file: aSourceMapConsumer.file,\n        sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function(mapping) {\n        var newMapping = {\n            generated: {\n                line: mapping.generatedLine,\n                column: mapping.generatedColumn\n            }\n        };\n        if (mapping.source != null) {\n            newMapping.source = mapping.source;\n            if (sourceRoot != null) {\n                newMapping.source = util.relative(sourceRoot, newMapping.source);\n            }\n            newMapping.original = {\n                line: mapping.originalLine,\n                column: mapping.originalColumn\n            };\n            if (mapping.name != null) {\n                newMapping.name = mapping.name;\n            }\n        }\n        generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function(sourceFile) {\n        var sourceRelative = sourceFile;\n        if (sourceRoot !== null) {\n            sourceRelative = util.relative(sourceRoot, sourceFile);\n        }\n        if (!generator._sources.has(sourceRelative)) {\n            generator._sources.add(sourceRelative);\n        }\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n            generator.setSourceContent(sourceFile, content);\n        }\n    });\n    return generator;\n};\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */ SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, \"generated\");\n    var original = util.getArg(aArgs, \"original\", null);\n    var source = util.getArg(aArgs, \"source\", null);\n    var name = util.getArg(aArgs, \"name\", null);\n    if (!this._skipValidation) {\n        this._validateMapping(generated, original, source, name);\n    }\n    if (source != null) {\n        source = String(source);\n        if (!this._sources.has(source)) {\n            this._sources.add(source);\n        }\n    }\n    if (name != null) {\n        name = String(name);\n        if (!this._names.has(name)) {\n            this._names.add(name);\n        }\n    }\n    this._mappings.add({\n        generatedLine: generated.line,\n        generatedColumn: generated.column,\n        originalLine: original != null && original.line,\n        originalColumn: original != null && original.column,\n        source: source,\n        name: name\n    });\n};\n/**\n * Set the source content for a source file.\n */ SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n        source = util.relative(this._sourceRoot, source);\n    }\n    if (aSourceContent != null) {\n        // Add the source content to the _sourcesContents map.\n        // Create a new _sourcesContents map if the property is null.\n        if (!this._sourcesContents) {\n            this._sourcesContents = Object.create(null);\n        }\n        this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n        // Remove the source file from the _sourcesContents map.\n        // If the _sourcesContents map is empty, set the property to null.\n        delete this._sourcesContents[util.toSetString(source)];\n        if (Object.keys(this._sourcesContents).length === 0) {\n            this._sourcesContents = null;\n        }\n    }\n};\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */ SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n        if (aSourceMapConsumer.file == null) {\n            throw new Error(\"SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, \" + 'or the source map\\'s \"file\" property. Both were omitted.');\n        }\n        sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n        sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function(mapping) {\n        if (mapping.source === sourceFile && mapping.originalLine != null) {\n            // Check if it can be mapped by the source map, then update the mapping.\n            var original = aSourceMapConsumer.originalPositionFor({\n                line: mapping.originalLine,\n                column: mapping.originalColumn\n            });\n            if (original.source != null) {\n                // Copy mapping\n                mapping.source = original.source;\n                if (aSourceMapPath != null) {\n                    mapping.source = util.join(aSourceMapPath, mapping.source);\n                }\n                if (sourceRoot != null) {\n                    mapping.source = util.relative(sourceRoot, mapping.source);\n                }\n                mapping.originalLine = original.line;\n                mapping.originalColumn = original.column;\n                if (original.name != null) {\n                    mapping.name = original.name;\n                }\n            }\n        }\n        var source = mapping.source;\n        if (source != null && !newSources.has(source)) {\n            newSources.add(source);\n        }\n        var name = mapping.name;\n        if (name != null && !newNames.has(name)) {\n            newNames.add(name);\n        }\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function(sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n            if (aSourceMapPath != null) {\n                sourceFile = util.join(aSourceMapPath, sourceFile);\n            }\n            if (sourceRoot != null) {\n                sourceFile = util.relative(sourceRoot, sourceFile);\n            }\n            this.setSourceContent(sourceFile, content);\n        }\n    }, this);\n};\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */ SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== \"number\" && typeof aOriginal.column !== \"number\") {\n        throw new Error(\"original.line and original.column are not numbers -- you probably meant to omit \" + \"the original mapping entirely and only map the generated position. If so, pass \" + \"null for the original mapping instead of an object with empty or null values.\");\n    }\n    if (aGenerated && \"line\" in aGenerated && \"column\" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {\n        // Case 1.\n        return;\n    } else if (aGenerated && \"line\" in aGenerated && \"column\" in aGenerated && aOriginal && \"line\" in aOriginal && \"column\" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {\n        // Cases 2 and 3.\n        return;\n    } else {\n        throw new Error(\"Invalid mapping: \" + JSON.stringify({\n            generated: aGenerated,\n            source: aSource,\n            original: aOriginal,\n            name: aName\n        }));\n    }\n};\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */ SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = \"\";\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n    var mappings = this._mappings.toArray();\n    for(var i = 0, len = mappings.length; i < len; i++){\n        mapping = mappings[i];\n        next = \"\";\n        if (mapping.generatedLine !== previousGeneratedLine) {\n            previousGeneratedColumn = 0;\n            while(mapping.generatedLine !== previousGeneratedLine){\n                next += \";\";\n                previousGeneratedLine++;\n            }\n        } else {\n            if (i > 0) {\n                if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n                    continue;\n                }\n                next += \",\";\n            }\n        }\n        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);\n        previousGeneratedColumn = mapping.generatedColumn;\n        if (mapping.source != null) {\n            sourceIdx = this._sources.indexOf(mapping.source);\n            next += base64VLQ.encode(sourceIdx - previousSource);\n            previousSource = sourceIdx;\n            // lines are stored 0-based in SourceMap spec version 3\n            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);\n            previousOriginalLine = mapping.originalLine - 1;\n            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);\n            previousOriginalColumn = mapping.originalColumn;\n            if (mapping.name != null) {\n                nameIdx = this._names.indexOf(mapping.name);\n                next += base64VLQ.encode(nameIdx - previousName);\n                previousName = nameIdx;\n            }\n        }\n        result += next;\n    }\n    return result;\n};\nSourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function(source) {\n        if (!this._sourcesContents) {\n            return null;\n        }\n        if (aSourceRoot != null) {\n            source = util.relative(aSourceRoot, source);\n        }\n        var key = util.toSetString(source);\n        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;\n    }, this);\n};\n/**\n * Externalize the source map.\n */ SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {\n    var map = {\n        version: this._version,\n        sources: this._sources.toArray(),\n        names: this._names.toArray(),\n        mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n        map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n        map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n    return map;\n};\n/**\n * Render the source map being generated to a string.\n */ SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n};\nexports.SourceMapGenerator = SourceMapGenerator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vc291cmNlLW1hcC1qcy9saWIvc291cmNlLW1hcC1nZW5lcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUEseUNBQXlDLEdBQ3pDOzs7O0NBSUMsR0FFRCxJQUFJQSxZQUFZQyxtQkFBT0EsQ0FBQztBQUN4QixJQUFJQyxPQUFPRCxtQkFBT0EsQ0FBQztBQUNuQixJQUFJRSxXQUFXRiw0RkFBK0I7QUFDOUMsSUFBSUcsY0FBY0gscUdBQXFDO0FBRXZEOzs7Ozs7O0NBT0MsR0FDRCxTQUFTSSxtQkFBbUJDLEtBQUs7SUFDL0IsSUFBSSxDQUFDQSxPQUFPO1FBQ1ZBLFFBQVEsQ0FBQztJQUNYO0lBQ0EsSUFBSSxDQUFDQyxLQUFLLEdBQUdMLEtBQUtNLE1BQU0sQ0FBQ0YsT0FBTyxRQUFRO0lBQ3hDLElBQUksQ0FBQ0csV0FBVyxHQUFHUCxLQUFLTSxNQUFNLENBQUNGLE9BQU8sY0FBYztJQUNwRCxJQUFJLENBQUNJLGVBQWUsR0FBR1IsS0FBS00sTUFBTSxDQUFDRixPQUFPLGtCQUFrQjtJQUM1RCxJQUFJLENBQUNLLFFBQVEsR0FBRyxJQUFJUjtJQUNwQixJQUFJLENBQUNTLE1BQU0sR0FBRyxJQUFJVDtJQUNsQixJQUFJLENBQUNVLFNBQVMsR0FBRyxJQUFJVDtJQUNyQixJQUFJLENBQUNVLGdCQUFnQixHQUFHO0FBQzFCO0FBRUFULG1CQUFtQlUsU0FBUyxDQUFDQyxRQUFRLEdBQUc7QUFFeEM7Ozs7Q0FJQyxHQUNEWCxtQkFBbUJZLGFBQWEsR0FDOUIsU0FBU0MsaUNBQWlDQyxrQkFBa0I7SUFDMUQsSUFBSUMsYUFBYUQsbUJBQW1CQyxVQUFVO0lBQzlDLElBQUlDLFlBQVksSUFBSWhCLG1CQUFtQjtRQUNyQ2lCLE1BQU1ILG1CQUFtQkcsSUFBSTtRQUM3QkYsWUFBWUE7SUFDZDtJQUNBRCxtQkFBbUJJLFdBQVcsQ0FBQyxTQUFVQyxPQUFPO1FBQzlDLElBQUlDLGFBQWE7WUFDZkMsV0FBVztnQkFDVEMsTUFBTUgsUUFBUUksYUFBYTtnQkFDM0JD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LGdCQUFnQixDQUFDb0YsSUFBSSxHQUMxQjtJQUNOLEdBQUcsSUFBSTtBQUNUO0FBRUY7O0NBRUMsR0FDRDdGLG1CQUFtQlUsU0FBUyxDQUFDc0YsTUFBTSxHQUNqQyxTQUFTQztJQUNQLElBQUlMLE1BQU07UUFDUk0sU0FBUyxJQUFJLENBQUN2RixRQUFRO1FBQ3RCc0IsU0FBUyxJQUFJLENBQUMzQixRQUFRLENBQUM0RSxPQUFPO1FBQzlCaUIsT0FBTyxJQUFJLENBQUM1RixNQUFNLENBQUMyRSxPQUFPO1FBQzFCRCxVQUFVLElBQUksQ0FBQ1osa0JBQWtCO0lBQ25DO0lBQ0EsSUFBSSxJQUFJLENBQUNuRSxLQUFLLElBQUksTUFBTTtRQUN0QjBGLElBQUkzRSxJQUFJLEdBQUcsSUFBSSxDQUFDZixLQUFLO0lBQ3ZCO0lBQ0EsSUFBSSxJQUFJLENBQUNFLFdBQVcsSUFBSSxNQUFNO1FBQzVCd0YsSUFBSTdFLFVBQVUsR0FBRyxJQUFJLENBQUNYLFdBQVc7SUFDbkM7SUFDQSxJQUFJLElBQUksQ0FBQ0ssZ0JBQWdCLEVBQUU7UUFDekJtRixJQUFJUSxjQUFjLEdBQUcsSUFBSSxDQUFDWix1QkFBdUIsQ0FBQ0ksSUFBSTNELE9BQU8sRUFBRTJELElBQUk3RSxVQUFVO0lBQy9FO0lBRUEsT0FBTzZFO0FBQ1Q7QUFFRjs7Q0FFQyxHQUNENUYsbUJBQW1CVSxTQUFTLENBQUMyRixRQUFRLEdBQ25DLFNBQVNDO0lBQ1AsT0FBT25DLEtBQUtDLFNBQVMsQ0FBQyxJQUFJLENBQUM0QixNQUFNO0FBQ25DO0FBRUZPLDBCQUEwQixHQUFHdkciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1lbWFpbC8uLi9zb3VyY2UtbWFwLWpzL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcz80NTQxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG52YXIgTWFwcGluZ0xpc3QgPSByZXF1aXJlKCcuL21hcHBpbmctbGlzdCcpLk1hcHBpbmdMaXN0O1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IgcmVwcmVzZW50cyBhIHNvdXJjZSBtYXAgd2hpY2ggaXNcbiAqIGJlaW5nIGJ1aWx0IGluY3JlbWVudGFsbHkuIFlvdSBtYXkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gKiBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBmaWxlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gc291cmNlUm9vdDogQSByb290IGZvciBhbGwgcmVsYXRpdmUgVVJMcyBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gKi9cbmZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncykge1xuICBpZiAoIWFBcmdzKSB7XG4gICAgYUFyZ3MgPSB7fTtcbiAgfVxuICB0aGlzLl9maWxlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdmaWxlJywgbnVsbCk7XG4gIHRoaXMuX3NvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgdGhpcy5fc2tpcFZhbGlkYXRpb24gPSB1dGlsLmdldEFyZyhhQXJncywgJ3NraXBWYWxpZGF0aW9uJywgZmFsc2UpO1xuICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX21hcHBpbmdzID0gbmV3IE1hcHBpbmdMaXN0KCk7XG4gIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG59XG5cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgU291cmNlTWFwR2VuZXJhdG9yIGJhc2VkIG9uIGEgU291cmNlTWFwQ29uc3VtZXJcbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyKSB7XG4gICAgdmFyIHNvdXJjZVJvb3QgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlUm9vdDtcbiAgICB2YXIgZ2VuZXJhdG9yID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICBmaWxlOiBhU291cmNlTWFwQ29uc3VtZXIuZmlsZSxcbiAgICAgIHNvdXJjZVJvb3Q6IHNvdXJjZVJvb3RcbiAgICB9KTtcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIHZhciBuZXdNYXBwaW5nID0ge1xuICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG5ld01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld01hcHBpbmcub3JpZ2luYWwgPSB7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5uYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGdlbmVyYXRvci5hZGRNYXBwaW5nKG5ld01hcHBpbmcpO1xuICAgIH0pO1xuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBzb3VyY2VSZWxhdGl2ZSA9IHNvdXJjZUZpbGU7XG4gICAgICBpZiAoc291cmNlUm9vdCAhPT0gbnVsbCkge1xuICAgICAgICBzb3VyY2VSZWxhdGl2ZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZ2VuZXJhdG9yLl9zb3VyY2VzLmhhcyhzb3VyY2VSZWxhdGl2ZSkpIHtcbiAgICAgICAgZ2VuZXJhdG9yLl9zb3VyY2VzLmFkZChzb3VyY2VSZWxhdGl2ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRvci5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH07XG5cbi8qKlxuICogQWRkIGEgc2luZ2xlIG1hcHBpbmcgZnJvbSBvcmlnaW5hbCBzb3VyY2UgbGluZSBhbmQgY29sdW1uIHRvIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhpcyBzb3VyY2UgbWFwIGJlaW5nIGNyZWF0ZWQuIFRoZSBtYXBwaW5nXG4gKiBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBnZW5lcmF0ZWQ6IEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAqICAgLSBvcmlnaW5hbDogQW4gb2JqZWN0IHdpdGggdGhlIG9yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUgKHJlbGF0aXZlIHRvIHRoZSBzb3VyY2VSb290KS5cbiAqICAgLSBuYW1lOiBBbiBvcHRpb25hbCBvcmlnaW5hbCB0b2tlbiBuYW1lIGZvciB0aGlzIG1hcHBpbmcuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hZGRNYXBwaW5nKGFBcmdzKSB7XG4gICAgdmFyIGdlbmVyYXRlZCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZ2VuZXJhdGVkJyk7XG4gICAgdmFyIG9yaWdpbmFsID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdvcmlnaW5hbCcsIG51bGwpO1xuICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScsIG51bGwpO1xuICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICduYW1lJywgbnVsbCk7XG5cbiAgICBpZiAoIXRoaXMuX3NraXBWYWxpZGF0aW9uKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZU1hcHBpbmcoZ2VuZXJhdGVkLCBvcmlnaW5hbCwgc291cmNlLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IFN0cmluZyhzb3VyY2UpO1xuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICAgIGlmICghdGhpcy5fbmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9tYXBwaW5ncy5hZGQoe1xuICAgICAgZ2VuZXJhdGVkTGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IGdlbmVyYXRlZC5jb2x1bW4sXG4gICAgICBvcmlnaW5hbExpbmU6IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwubGluZSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmNvbHVtbixcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgbmFtZTogbmFtZVxuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIHZhciBzb3VyY2UgPSBhU291cmNlRmlsZTtcbiAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuX3NvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgfVxuXG4gICAgaWYgKGFTb3VyY2VDb250ZW50ICE9IG51bGwpIHtcbiAgICAgIC8vIEFkZCB0aGUgc291cmNlIGNvbnRlbnQgdG8gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IF9zb3VyY2VzQ29udGVudHMgbWFwIGlmIHRoZSBwcm9wZXJ0eSBpcyBudWxsLlxuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgc291cmNlIGZpbGUgZnJvbSB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAvLyBJZiB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAgaXMgZW1wdHksIHNldCB0aGUgcHJvcGVydHkgdG8gbnVsbC5cbiAgICAgIGRlbGV0ZSB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9zb3VyY2VzQ29udGVudHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBtYXBwaW5ncyBvZiBhIHN1Yi1zb3VyY2UtbWFwIGZvciBhIHNwZWNpZmljIHNvdXJjZSBmaWxlIHRvIHRoZVxuICogc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQuIEVhY2ggbWFwcGluZyB0byB0aGUgc3VwcGxpZWQgc291cmNlIGZpbGUgaXNcbiAqIHJld3JpdHRlbiB1c2luZyB0aGUgc3VwcGxpZWQgc291cmNlIG1hcC4gTm90ZTogVGhlIHJlc29sdXRpb24gZm9yIHRoZVxuICogcmVzdWx0aW5nIG1hcHBpbmdzIGlzIHRoZSBtaW5pbWl1bSBvZiB0aGlzIG1hcCBhbmQgdGhlIHN1cHBsaWVkIG1hcC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQuXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgT3B0aW9uYWwuIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGUuXG4gKiAgICAgICAgSWYgb21pdHRlZCwgU291cmNlTWFwQ29uc3VtZXIncyBmaWxlIHByb3BlcnR5IHdpbGwgYmUgdXNlZC5cbiAqIEBwYXJhbSBhU291cmNlTWFwUGF0aCBPcHRpb25hbC4gVGhlIGRpcm5hbWUgb2YgdGhlIHBhdGggdG8gdGhlIHNvdXJjZSBtYXBcbiAqICAgICAgICB0byBiZSBhcHBsaWVkLiBJZiByZWxhdGl2ZSwgaXQgaXMgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcENvbnN1bWVyLlxuICogICAgICAgIFRoaXMgcGFyYW1ldGVyIGlzIG5lZWRlZCB3aGVuIHRoZSB0d28gc291cmNlIG1hcHMgYXJlbid0IGluIHRoZSBzYW1lXG4gKiAgICAgICAgZGlyZWN0b3J5LCBhbmQgdGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZCBjb250YWlucyByZWxhdGl2ZSBzb3VyY2VcbiAqICAgICAgICBwYXRocy4gSWYgc28sIHRob3NlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBuZWVkIHRvIGJlIHJld3JpdHRlblxuICogICAgICAgIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYXBwbHlTb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyLCBhU291cmNlRmlsZSwgYVNvdXJjZU1hcFBhdGgpIHtcbiAgICB2YXIgc291cmNlRmlsZSA9IGFTb3VyY2VGaWxlO1xuICAgIC8vIElmIGFTb3VyY2VGaWxlIGlzIG9taXR0ZWQsIHdlIHdpbGwgdXNlIHRoZSBmaWxlIHByb3BlcnR5IG9mIHRoZSBTb3VyY2VNYXBcbiAgICBpZiAoYVNvdXJjZUZpbGUgPT0gbnVsbCkge1xuICAgICAgaWYgKGFTb3VyY2VNYXBDb25zdW1lci5maWxlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwIHJlcXVpcmVzIGVpdGhlciBhbiBleHBsaWNpdCBzb3VyY2UgZmlsZSwgJyArXG4gICAgICAgICAgJ29yIHRoZSBzb3VyY2UgbWFwXFwncyBcImZpbGVcIiBwcm9wZXJ0eS4gQm90aCB3ZXJlIG9taXR0ZWQuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc291cmNlRmlsZSA9IGFTb3VyY2VNYXBDb25zdW1lci5maWxlO1xuICAgIH1cbiAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgLy8gTWFrZSBcInNvdXJjZUZpbGVcIiByZWxhdGl2ZSBpZiBhbiBhYnNvbHV0ZSBVcmwgaXMgcGFzc2VkLlxuICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgIH1cbiAgICAvLyBBcHBseWluZyB0aGUgU291cmNlTWFwIGNhbiBhZGQgYW5kIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBzb3VyY2VzIGFuZFxuICAgIC8vIHRoZSBuYW1lcyBhcnJheS5cbiAgICB2YXIgbmV3U291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHZhciBuZXdOYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gICAgLy8gRmluZCBtYXBwaW5ncyBmb3IgdGhlIFwic291cmNlRmlsZVwiXG4gICAgdGhpcy5fbWFwcGluZ3MudW5zb3J0ZWRGb3JFYWNoKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgPT09IHNvdXJjZUZpbGUgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgIT0gbnVsbCkge1xuICAgICAgICAvLyBDaGVjayBpZiBpdCBjYW4gYmUgbWFwcGVkIGJ5IHRoZSBzb3VyY2UgbWFwLCB0aGVuIHVwZGF0ZSB0aGUgbWFwcGluZy5cbiAgICAgICAgdmFyIG9yaWdpbmFsID0gYVNvdXJjZU1hcENvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29weSBtYXBwaW5nXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgICAgaWYgKG9yaWdpbmFsLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmICFuZXdTb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIG5ld1NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiAhbmV3TmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIG5ld05hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cblxuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXdTb3VyY2VzO1xuICAgIHRoaXMuX25hbWVzID0gbmV3TmFtZXM7XG5cbiAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50cyBvZiBhcHBsaWVkIG1hcC5cbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbi8qKlxuICogQSBtYXBwaW5nIGNhbiBoYXZlIG9uZSBvZiB0aGUgdGhyZWUgbGV2ZWxzIG9mIGRhdGE6XG4gKlxuICogICAxLiBKdXN0IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKiAgIDIuIFRoZSBHZW5lcmF0ZWQgcG9zaXRpb24sIG9yaWdpbmFsIHBvc2l0aW9uLCBhbmQgb3JpZ2luYWwgc291cmNlLlxuICogICAzLiBHZW5lcmF0ZWQgYW5kIG9yaWdpbmFsIHBvc2l0aW9uLCBvcmlnaW5hbCBzb3VyY2UsIGFzIHdlbGwgYXMgYSBuYW1lXG4gKiAgICAgIHRva2VuLlxuICpcbiAqIFRvIG1haW50YWluIGNvbnNpc3RlbmN5LCB3ZSB2YWxpZGF0ZSB0aGF0IGFueSBuZXcgbWFwcGluZyBiZWluZyBhZGRlZCBmYWxsc1xuICogaW4gdG8gb25lIG9mIHRoZXNlIGNhdGVnb3JpZXMuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmcoYUdlbmVyYXRlZCwgYU9yaWdpbmFsLCBhU291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFOYW1lKSB7XG4gICAgLy8gV2hlbiBhT3JpZ2luYWwgaXMgdHJ1dGh5IGJ1dCBoYXMgZW1wdHkgdmFsdWVzIGZvciAubGluZSBhbmQgLmNvbHVtbixcbiAgICAvLyBpdCBpcyBtb3N0IGxpa2VseSBhIHByb2dyYW1tZXIgZXJyb3IuIEluIHRoaXMgY2FzZSB3ZSB0aHJvdyBhIHZlcnlcbiAgICAvLyBzcGVjaWZpYyBlcnJvciBtZXNzYWdlIHRvIHRyeSB0byBndWlkZSB0aGVtIHRoZSByaWdodCB3YXkuXG4gICAgLy8gRm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL3BvbHltZXItYnVuZGxlci9wdWxsLzUxOVxuICAgIGlmIChhT3JpZ2luYWwgJiYgdHlwZW9mIGFPcmlnaW5hbC5saW5lICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgYU9yaWdpbmFsLmNvbHVtbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ29yaWdpbmFsLmxpbmUgYW5kIG9yaWdpbmFsLmNvbHVtbiBhcmUgbm90IG51bWJlcnMgLS0geW91IHByb2JhYmx5IG1lYW50IHRvIG9taXQgJyArXG4gICAgICAgICAgICAndGhlIG9yaWdpbmFsIG1hcHBpbmcgZW50aXJlbHkgYW5kIG9ubHkgbWFwIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uIElmIHNvLCBwYXNzICcgK1xuICAgICAgICAgICAgJ251bGwgZm9yIHRoZSBvcmlnaW5hbCBtYXBwaW5nIGluc3RlYWQgb2YgYW4gb2JqZWN0IHdpdGggZW1wdHkgb3IgbnVsbCB2YWx1ZXMuJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICYmICFhT3JpZ2luYWwgJiYgIWFTb3VyY2UgJiYgIWFOYW1lKSB7XG4gICAgICAvLyBDYXNlIDEuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICAgICYmIGFPcmlnaW5hbCAmJiAnbGluZScgaW4gYU9yaWdpbmFsICYmICdjb2x1bW4nIGluIGFPcmlnaW5hbFxuICAgICAgICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICYmIGFPcmlnaW5hbC5saW5lID4gMCAmJiBhT3JpZ2luYWwuY29sdW1uID49IDBcbiAgICAgICAgICAgICAmJiBhU291cmNlKSB7XG4gICAgICAvLyBDYXNlcyAyIGFuZCAzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXBwaW5nOiAnICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBnZW5lcmF0ZWQ6IGFHZW5lcmF0ZWQsXG4gICAgICAgIHNvdXJjZTogYVNvdXJjZSxcbiAgICAgICAgb3JpZ2luYWw6IGFPcmlnaW5hbCxcbiAgICAgICAgbmFtZTogYU5hbWVcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiB0byB0aGUgc3RyZWFtIG9mIGJhc2UgNjQgVkxRc1xuICogc3BlY2lmaWVkIGJ5IHRoZSBzb3VyY2UgbWFwIGZvcm1hdC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fc2VyaWFsaXplTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2VyaWFsaXplTWFwcGluZ3MoKSB7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRMaW5lID0gMTtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgbmV4dDtcbiAgICB2YXIgbWFwcGluZztcbiAgICB2YXIgbmFtZUlkeDtcbiAgICB2YXIgc291cmNlSWR4O1xuXG4gICAgdmFyIG1hcHBpbmdzID0gdGhpcy5fbWFwcGluZ3MudG9BcnJheSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xuICAgICAgbmV4dCA9ICcnXG5cbiAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgIHdoaWxlIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIG5leHQgKz0gJzsnO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkTGluZSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgaWYgKCF1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmcsIG1hcHBpbmdzW2kgLSAxXSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0ICs9ICcsJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlSWR4ID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKHNvdXJjZUlkeCAtIHByZXZpb3VzU291cmNlKTtcbiAgICAgICAgcHJldmlvdXNTb3VyY2UgPSBzb3VyY2VJZHg7XG5cbiAgICAgICAgLy8gbGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkIGluIFNvdXJjZU1hcCBzcGVjIHZlcnNpb24gM1xuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbExpbmUgLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbExpbmUpO1xuICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMTtcblxuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4pO1xuICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICBuYW1lSWR4ID0gdGhpcy5fbmFtZXMuaW5kZXhPZihtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShuYW1lSWR4IC0gcHJldmlvdXNOYW1lKTtcbiAgICAgICAgICBwcmV2aW91c05hbWUgPSBuYW1lSWR4O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCArPSBuZXh0O1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZ2VuZXJhdGVTb3VyY2VzQ29udGVudChhU291cmNlcywgYVNvdXJjZVJvb3QpIHtcbiAgICByZXR1cm4gYVNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGFTb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZShhU291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSk7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NvdXJjZXNDb250ZW50cywga2V5KVxuICAgICAgICA/IHRoaXMuX3NvdXJjZXNDb250ZW50c1trZXldXG4gICAgICAgIDogbnVsbDtcbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuLyoqXG4gKiBFeHRlcm5hbGl6ZSB0aGUgc291cmNlIG1hcC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b0pTT04gPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9KU09OKCkge1xuICAgIHZhciBtYXAgPSB7XG4gICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgc291cmNlczogdGhpcy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICBuYW1lczogdGhpcy5fbmFtZXMudG9BcnJheSgpLFxuICAgICAgbWFwcGluZ3M6IHRoaXMuX3NlcmlhbGl6ZU1hcHBpbmdzKClcbiAgICB9O1xuICAgIGlmICh0aGlzLl9maWxlICE9IG51bGwpIHtcbiAgICAgIG1hcC5maWxlID0gdGhpcy5fZmlsZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgbWFwLnNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICBtYXAuc291cmNlc0NvbnRlbnQgPSB0aGlzLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KG1hcC5zb3VyY2VzLCBtYXAuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbiAgfTtcblxuLyoqXG4gKiBSZW5kZXIgdGhlIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkIHRvIGEgc3RyaW5nLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvU3RyaW5nKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKTtcbiAgfTtcblxuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSBTb3VyY2VNYXBHZW5lcmF0b3I7XG4iXSwibmFtZXMiOlsiYmFzZTY0VkxRIiwicmVxdWlyZSIsInV0aWwiLCJBcnJheVNldCIsIk1hcHBpbmdMaXN0IiwiU291cmNlTWFwR2VuZXJhdG9yIiwiYUFyZ3MiLCJfZmlsZSIsImdldEFyZyIsIl9zb3VyY2VSb290IiwiX3NraXBWYWxpZGF0aW9uIiwiX3NvdXJjZXMiLCJfbmFtZXMiLCJfbWFwcGluZ3MiLCJfc291cmNlc0NvbnRlbnRzIiwicHJvdG90eXBlIiwiX3ZlcnNpb24iLCJmcm9tU291cmNlTWFwIiwiU291cmNlTWFwR2VuZXJhdG9yX2Zyb21Tb3VyY2VNYXAiLCJhU291cmNlTWFwQ29uc3VtZXIiLCJzb3VyY2VSb290IiwiZ2VuZXJhdG9yIiwiZmlsZSIsImVhY2hNYXBwaW5nIiwibWFwcGluZyIsIm5ld01hcHBpbmciLCJnZW5lcmF0ZWQiLCJsaW5lIiwiZ2VuZXJhdGVkTGluZSIsImNvbHVtbiIsImdlbmVyYXRlZENvbHVtbiIsInNvdXJjZSIsInJlbGF0aXZlIiwib3JpZ2luYWwiLCJvcmlnaW5hbExpbmUiLCJvcmlnaW5hbENvbHVtbiIsIm5hbWUiLCJhZGRNYXBwaW5nIiwic291cmNlcyIsImZvckVhY2giLCJzb3VyY2VGaWxlIiwic291cmNlUmVsYXRpdmUiLCJoYXMiLCJhZGQiLCJjb250ZW50Iiwic291cmNlQ29udGVudEZvciIsInNldFNvdXJjZUNvbnRlbnQiLCJTb3VyY2VNYXBHZW5lcmF0b3JfYWRkTWFwcGluZyIsIl92YWxpZGF0ZU1hcHBpbmciLCJTdHJpbmciLCJTb3VyY2VNYXBHZW5lcmF0b3Jfc2V0U291cmNlQ29udGVudCIsImFTb3VyY2VGaWxlIiwiYVNvdXJjZUNvbnRlbnQiLCJPYmplY3QiLCJjcmVhdGUiLCJ0b1NldFN0cmluZyIsImtleXMiLCJsZW5ndGgiLCJhcHBseVNvdXJjZU1hcCIsIlNvdXJjZU1hcEdlbmVyYXRvcl9hcHBseVNvdXJjZU1hcCIsImFTb3VyY2VNYXBQYXRoIiwiRXJyb3IiLCJuZXdTb3VyY2VzIiwibmV3TmFtZXMiLCJ1bnNvcnRlZEZvckVhY2giLCJvcmlnaW5hbFBvc2l0aW9uRm9yIiwiam9pbiIsIlNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmciLCJhR2VuZXJhdGVkIiwiYU9yaWdpbmFsIiwiYVNvdXJjZSIsImFOYW1lIiwiSlNPTiIsInN0cmluZ2lmeSIsIl9zZXJpYWxpemVNYXBwaW5ncyIsIlNvdXJjZU1hcEdlbmVyYXRvcl9zZXJpYWxpemVNYXBwaW5ncyIsInByZXZpb3VzR2VuZXJhdGVkQ29sdW1uIiwicHJldmlvdXNHZW5lcmF0ZWRMaW5lIiwicHJldmlvdXNPcmlnaW5hbENvbHVtbiIsInByZXZpb3VzT3JpZ2luYWxMaW5lIiwicHJldmlvdXNOYW1lIiwicHJldmlvdXNTb3VyY2UiLCJyZXN1bHQiLCJuZXh0IiwibmFtZUlkeCIsInNvdXJjZUlkeCIsIm1hcHBpbmdzIiwidG9BcnJheSIsImkiLCJsZW4iLCJjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCIsImVuY29kZSIsImluZGV4T2YiLCJfZ2VuZXJhdGVTb3VyY2VzQ29udGVudCIsIlNvdXJjZU1hcEdlbmVyYXRvcl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50IiwiYVNvdXJjZXMiLCJhU291cmNlUm9vdCIsIm1hcCIsImtleSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInRvSlNPTiIsIlNvdXJjZU1hcEdlbmVyYXRvcl90b0pTT04iLCJ2ZXJzaW9uIiwibmFtZXMiLCJzb3VyY2VzQ29udGVudCIsInRvU3RyaW5nIiwiU291cmNlTWFwR2VuZXJhdG9yX3RvU3RyaW5nIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../source-map-js/lib/source-map-generator.js\n");

/***/ }),

/***/ "(action-browser)/../source-map-js/lib/source-node.js":
/*!*******************************************!*\
  !*** ../source-map-js/lib/source-node.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var SourceMapGenerator = (__webpack_require__(/*! ./source-map-generator */ \"(action-browser)/../source-map-js/lib/source-map-generator.js\").SourceMapGenerator);\nvar util = __webpack_require__(/*! ./util */ \"(action-browser)/../source-map-js/lib/util.js\");\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */ function SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n    this.children = [];\n    this.sourceContents = {};\n    this.line = aLine == null ? null : aLine;\n    this.column = aColumn == null ? null : aColumn;\n    this.source = aSource == null ? null : aSource;\n    this.name = aName == null ? null : aName;\n    this[isSourceNode] = true;\n    if (aChunks != null) this.add(aChunks);\n}\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */ SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var remainingLinesIndex = 0;\n    var shiftNextLine = function() {\n        var lineContents = getNextLine();\n        // The last line of a file might not have a newline.\n        var newLine = getNextLine() || \"\";\n        return lineContents + newLine;\n        function getNextLine() {\n            return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;\n        }\n    };\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n    aSourceMapConsumer.eachMapping(function(mapping) {\n        if (lastMapping !== null) {\n            // We add the code from \"lastMapping\" to \"mapping\":\n            // First check if there is a new line in between.\n            if (lastGeneratedLine < mapping.generatedLine) {\n                // Associate first line with \"lastMapping\"\n                addMappingWithCode(lastMapping, shiftNextLine());\n                lastGeneratedLine++;\n                lastGeneratedColumn = 0;\n            // The remaining code is added without mapping\n            } else {\n                // There is no new line in between.\n                // Associate the code between \"lastGeneratedColumn\" and\n                // \"mapping.generatedColumn\" with \"lastMapping\"\n                var nextLine = remainingLines[remainingLinesIndex] || \"\";\n                var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);\n                remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);\n                lastGeneratedColumn = mapping.generatedColumn;\n                addMappingWithCode(lastMapping, code);\n                // No more remaining code, continue\n                lastMapping = mapping;\n                return;\n            }\n        }\n        // We add the generated code until the first mapping\n        // to the SourceNode without any mapping.\n        // Each line is added as separate string.\n        while(lastGeneratedLine < mapping.generatedLine){\n            node.add(shiftNextLine());\n            lastGeneratedLine++;\n        }\n        if (lastGeneratedColumn < mapping.generatedColumn) {\n            var nextLine = remainingLines[remainingLinesIndex] || \"\";\n            node.add(nextLine.substr(0, mapping.generatedColumn));\n            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n            lastGeneratedColumn = mapping.generatedColumn;\n        }\n        lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n        if (lastMapping) {\n            // Associate the remaining code in the current line with \"lastMapping\"\n            addMappingWithCode(lastMapping, shiftNextLine());\n        }\n        // and add the remaining lines without any mapping\n        node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function(sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n            if (aRelativePath != null) {\n                sourceFile = util.join(aRelativePath, sourceFile);\n            }\n            node.setSourceContent(sourceFile, content);\n        }\n    });\n    return node;\n    function addMappingWithCode(mapping, code) {\n        if (mapping === null || mapping.source === undefined) {\n            node.add(code);\n        } else {\n            var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;\n            node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));\n        }\n    }\n};\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */ SourceNode.prototype.add = function SourceNode_add(aChunk) {\n    if (Array.isArray(aChunk)) {\n        aChunk.forEach(function(chunk) {\n            this.add(chunk);\n        }, this);\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n        if (aChunk) {\n            this.children.push(aChunk);\n        }\n    } else {\n        throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n    }\n    return this;\n};\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */ SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n    if (Array.isArray(aChunk)) {\n        for(var i = aChunk.length - 1; i >= 0; i--){\n            this.prepend(aChunk[i]);\n        }\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n        this.children.unshift(aChunk);\n    } else {\n        throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n    }\n    return this;\n};\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */ SourceNode.prototype.walk = function SourceNode_walk(aFn) {\n    var chunk;\n    for(var i = 0, len = this.children.length; i < len; i++){\n        chunk = this.children[i];\n        if (chunk[isSourceNode]) {\n            chunk.walk(aFn);\n        } else {\n            if (chunk !== \"\") {\n                aFn(chunk, {\n                    source: this.source,\n                    line: this.line,\n                    column: this.column,\n                    name: this.name\n                });\n            }\n        }\n    }\n};\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */ SourceNode.prototype.join = function SourceNode_join(aSep) {\n    var newChildren;\n    var i;\n    var len = this.children.length;\n    if (len > 0) {\n        newChildren = [];\n        for(i = 0; i < len - 1; i++){\n            newChildren.push(this.children[i]);\n            newChildren.push(aSep);\n        }\n        newChildren.push(this.children[i]);\n        this.children = newChildren;\n    }\n    return this;\n};\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */ SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n    var lastChild = this.children[this.children.length - 1];\n    if (lastChild[isSourceNode]) {\n        lastChild.replaceRight(aPattern, aReplacement);\n    } else if (typeof lastChild === \"string\") {\n        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n    } else {\n        this.children.push(\"\".replace(aPattern, aReplacement));\n    }\n    return this;\n};\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */ SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n};\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */ SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {\n    for(var i = 0, len = this.children.length; i < len; i++){\n        if (this.children[i][isSourceNode]) {\n            this.children[i].walkSourceContents(aFn);\n        }\n    }\n    var sources = Object.keys(this.sourceContents);\n    for(var i = 0, len = sources.length; i < len; i++){\n        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n};\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */ SourceNode.prototype.toString = function SourceNode_toString() {\n    var str = \"\";\n    this.walk(function(chunk) {\n        str += chunk;\n    });\n    return str;\n};\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */ SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n    var generated = {\n        code: \"\",\n        line: 1,\n        column: 0\n    };\n    var map = new SourceMapGenerator(aArgs);\n    var sourceMappingActive = false;\n    var lastOriginalSource = null;\n    var lastOriginalLine = null;\n    var lastOriginalColumn = null;\n    var lastOriginalName = null;\n    this.walk(function(chunk, original) {\n        generated.code += chunk;\n        if (original.source !== null && original.line !== null && original.column !== null) {\n            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {\n                map.addMapping({\n                    source: original.source,\n                    original: {\n                        line: original.line,\n                        column: original.column\n                    },\n                    generated: {\n                        line: generated.line,\n                        column: generated.column\n                    },\n                    name: original.name\n                });\n            }\n            lastOriginalSource = original.source;\n            lastOriginalLine = original.line;\n            lastOriginalColumn = original.column;\n            lastOriginalName = original.name;\n            sourceMappingActive = true;\n        } else if (sourceMappingActive) {\n            map.addMapping({\n                generated: {\n                    line: generated.line,\n                    column: generated.column\n                }\n            });\n            lastOriginalSource = null;\n            sourceMappingActive = false;\n        }\n        for(var idx = 0, length = chunk.length; idx < length; idx++){\n            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n                generated.line++;\n                generated.column = 0;\n                // Mappings end at eol\n                if (idx + 1 === length) {\n                    lastOriginalSource = null;\n                    sourceMappingActive = false;\n                } else if (sourceMappingActive) {\n                    map.addMapping({\n                        source: original.source,\n                        original: {\n                            line: original.line,\n                            column: original.column\n                        },\n                        generated: {\n                            line: generated.line,\n                            column: generated.column\n                        },\n                        name: original.name\n                    });\n                }\n            } else {\n                generated.column++;\n            }\n        }\n    });\n    this.walkSourceContents(function(sourceFile, sourceContent) {\n        map.setSourceContent(sourceFile, sourceContent);\n    });\n    return {\n        code: generated.code,\n        map: map\n    };\n};\nexports.SourceNode = SourceNode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9zb3VyY2UtbWFwLWpzL2xpYi9zb3VyY2Utbm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5Q0FBeUMsR0FDekM7Ozs7Q0FJQyxHQUVELElBQUlBLHFCQUFxQkMsdUlBQW9EO0FBQzdFLElBQUlDLE9BQU9ELG1CQUFPQSxDQUFDO0FBRW5CLDZFQUE2RTtBQUM3RSx1REFBdUQ7QUFDdkQsSUFBSUUsZ0JBQWdCO0FBRXBCLHNEQUFzRDtBQUN0RCxJQUFJQyxlQUFlO0FBRW5CLHlFQUF5RTtBQUN6RSxpRUFBaUU7QUFDakUsWUFBWTtBQUNaLElBQUlDLGVBQWU7QUFFbkI7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxTQUFTQyxXQUFXQyxLQUFLLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLEtBQUs7SUFDekQsSUFBSSxDQUFDQyxRQUFRLEdBQUcsRUFBRTtJQUNsQixJQUFJLENBQUNDLGNBQWMsR0FBRyxDQUFDO0lBQ3ZCLElBQUksQ0FBQ0MsSUFBSSxHQUFHUCxTQUFTLE9BQU8sT0FBT0E7SUFDbkMsSUFBSSxDQUFDUSxNQUFNLEdBQUdQLFdBQVcsT0FBTyxPQUFPQTtJQUN2QyxJQUFJLENBQUNRLE1BQU0sR0FBR1AsV0FBVyxPQUFPLE9BQU9BO0lBQ3ZDLElBQUksQ0FBQ1EsSUFBSSxHQUFHTixTQUFTLE9BQU8sT0FBT0E7SUFDbkMsSUFBSSxDQUFDTixhQUFhLEdBQUc7SUFDckIsSUFBSUssV0FBVyxNQUFNLElBQUksQ0FBQ1EsR0FBRyxDQUFDUjtBQUNoQztBQUVBOzs7Ozs7O0NBT0MsR0FDREosV0FBV2EsdUJBQXVCLEdBQ2hDLFNBQVNDLG1DQUFtQ0MsY0FBYyxFQUFFQyxrQkFBa0IsRUFBRUMsYUFBYTtJQUMzRix5REFBeUQ7SUFDekQsb0JBQW9CO0lBQ3BCLElBQUlDLE9BQU8sSUFBSWxCO0lBRWYscUVBQXFFO0lBQ3JFLG9FQUFvRTtJQUNwRSw4Q0FBOEM7SUFDOUMsK0RBQStEO0lBQy9ELElBQUltQixp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LElBQUk7NEJBQ3BCQyxRQUFRZ0YsVUFBVWhGLE1BQU07d0JBQzFCO3dCQUNBRSxNQUFNcUYsU0FBU3JGLElBQUk7b0JBQ3JCO2dCQUNGO1lBQ0YsT0FBTztnQkFDTDhFLFVBQVVoRixNQUFNO1lBQ2xCO1FBQ0Y7SUFDRjtJQUNBLElBQUksQ0FBQ3FFLGtCQUFrQixDQUFDLFNBQVVuQyxVQUFVLEVBQUV5RCxhQUFhO1FBQ3pEVixJQUFJNUMsZ0JBQWdCLENBQUNILFlBQVl5RDtJQUNuQztJQUVBLE9BQU87UUFBRWhFLE1BQU1xRCxVQUFVckQsSUFBSTtRQUFFc0QsS0FBS0E7SUFBSTtBQUMxQztBQUVBVyxrQkFBa0IsR0FBR3JHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtZW1haWwvLi4vc291cmNlLW1hcC1qcy9saWIvc291cmNlLW5vZGUuanM/MDQ3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBTb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLy8gTWF0Y2hlcyBhIFdpbmRvd3Mtc3R5bGUgYFxcclxcbmAgbmV3bGluZSBvciBhIGBcXG5gIG5ld2xpbmUgdXNlZCBieSBhbGwgb3RoZXJcbi8vIG9wZXJhdGluZyBzeXN0ZW1zIHRoZXNlIGRheXMgKGNhcHR1cmluZyB0aGUgcmVzdWx0KS5cbnZhciBSRUdFWF9ORVdMSU5FID0gLyhcXHI/XFxuKS87XG5cbi8vIE5ld2xpbmUgY2hhcmFjdGVyIGNvZGUgZm9yIGNoYXJDb2RlQXQoKSBjb21wYXJpc29uc1xudmFyIE5FV0xJTkVfQ09ERSA9IDEwO1xuXG4vLyBQcml2YXRlIHN5bWJvbCBmb3IgaWRlbnRpZnlpbmcgYFNvdXJjZU5vZGVgcyB3aGVuIG11bHRpcGxlIHZlcnNpb25zIG9mXG4vLyB0aGUgc291cmNlLW1hcCBsaWJyYXJ5IGFyZSBsb2FkZWQuIFRoaXMgTVVTVCBOT1QgQ0hBTkdFIGFjcm9zc1xuLy8gdmVyc2lvbnMhXG52YXIgaXNTb3VyY2VOb2RlID0gXCIkJCRpc1NvdXJjZU5vZGUkJCRcIjtcblxuLyoqXG4gKiBTb3VyY2VOb2RlcyBwcm92aWRlIGEgd2F5IHRvIGFic3RyYWN0IG92ZXIgaW50ZXJwb2xhdGluZy9jb25jYXRlbmF0aW5nXG4gKiBzbmlwcGV0cyBvZiBnZW5lcmF0ZWQgSmF2YVNjcmlwdCBzb3VyY2UgY29kZSB3aGlsZSBtYWludGFpbmluZyB0aGUgbGluZSBhbmRcbiAqIGNvbHVtbiBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwYXJhbSBhTGluZSBUaGUgb3JpZ2luYWwgbGluZSBudW1iZXIuXG4gKiBAcGFyYW0gYUNvbHVtbiBUaGUgb3JpZ2luYWwgY29sdW1uIG51bWJlci5cbiAqIEBwYXJhbSBhU291cmNlIFRoZSBvcmlnaW5hbCBzb3VyY2UncyBmaWxlbmFtZS5cbiAqIEBwYXJhbSBhQ2h1bmtzIE9wdGlvbmFsLiBBbiBhcnJheSBvZiBzdHJpbmdzIHdoaWNoIGFyZSBzbmlwcGV0cyBvZlxuICogICAgICAgIGdlbmVyYXRlZCBKUywgb3Igb3RoZXIgU291cmNlTm9kZXMuXG4gKiBAcGFyYW0gYU5hbWUgVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIuXG4gKi9cbmZ1bmN0aW9uIFNvdXJjZU5vZGUoYUxpbmUsIGFDb2x1bW4sIGFTb3VyY2UsIGFDaHVua3MsIGFOYW1lKSB7XG4gIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgdGhpcy5zb3VyY2VDb250ZW50cyA9IHt9O1xuICB0aGlzLmxpbmUgPSBhTGluZSA9PSBudWxsID8gbnVsbCA6IGFMaW5lO1xuICB0aGlzLmNvbHVtbiA9IGFDb2x1bW4gPT0gbnVsbCA/IG51bGwgOiBhQ29sdW1uO1xuICB0aGlzLnNvdXJjZSA9IGFTb3VyY2UgPT0gbnVsbCA/IG51bGwgOiBhU291cmNlO1xuICB0aGlzLm5hbWUgPSBhTmFtZSA9PSBudWxsID8gbnVsbCA6IGFOYW1lO1xuICB0aGlzW2lzU291cmNlTm9kZV0gPSB0cnVlO1xuICBpZiAoYUNodW5rcyAhPSBudWxsKSB0aGlzLmFkZChhQ2h1bmtzKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgU291cmNlTm9kZSBmcm9tIGdlbmVyYXRlZCBjb2RlIGFuZCBhIFNvdXJjZU1hcENvbnN1bWVyLlxuICpcbiAqIEBwYXJhbSBhR2VuZXJhdGVkQ29kZSBUaGUgZ2VuZXJhdGVkIGNvZGVcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcCBmb3IgdGhlIGdlbmVyYXRlZCBjb2RlXG4gKiBAcGFyYW0gYVJlbGF0aXZlUGF0aCBPcHRpb25hbC4gVGhlIHBhdGggdGhhdCByZWxhdGl2ZSBzb3VyY2VzIGluIHRoZVxuICogICAgICAgIFNvdXJjZU1hcENvbnN1bWVyIHNob3VsZCBiZSByZWxhdGl2ZSB0by5cbiAqL1xuU291cmNlTm9kZS5mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAoYUdlbmVyYXRlZENvZGUsIGFTb3VyY2VNYXBDb25zdW1lciwgYVJlbGF0aXZlUGF0aCkge1xuICAgIC8vIFRoZSBTb3VyY2VOb2RlIHdlIHdhbnQgdG8gZmlsbCB3aXRoIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgIC8vIGFuZCB0aGUgU291cmNlTWFwXG4gICAgdmFyIG5vZGUgPSBuZXcgU291cmNlTm9kZSgpO1xuXG4gICAgLy8gQWxsIGV2ZW4gaW5kaWNlcyBvZiB0aGlzIGFycmF5IGFyZSBvbmUgbGluZSBvZiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gICAgLy8gd2hpbGUgYWxsIG9kZCBpbmRpY2VzIGFyZSB0aGUgbmV3bGluZXMgYmV0d2VlbiB0d28gYWRqYWNlbnQgbGluZXNcbiAgICAvLyAoc2luY2UgYFJFR0VYX05FV0xJTkVgIGNhcHR1cmVzIGl0cyBtYXRjaCkuXG4gICAgLy8gUHJvY2Vzc2VkIGZyYWdtZW50cyBhcmUgYWNjZXNzZWQgYnkgY2FsbGluZyBgc2hpZnROZXh0TGluZWAuXG4gICAgdmFyIHJlbWFpbmluZ0xpbmVzID0gYUdlbmVyYXRlZENvZGUuc3BsaXQoUkVHRVhfTkVXTElORSk7XG4gICAgdmFyIHJlbWFpbmluZ0xpbmVzSW5kZXggPSAwO1xuICAgIHZhciBzaGlmdE5leHRMaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGluZUNvbnRlbnRzID0gZ2V0TmV4dExpbmUoKTtcbiAgICAgIC8vIFRoZSBsYXN0IGxpbmUgb2YgYSBmaWxlIG1pZ2h0IG5vdCBoYXZlIGEgbmV3bGluZS5cbiAgICAgIHZhciBuZXdMaW5lID0gZ2V0TmV4dExpbmUoKSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIGxpbmVDb250ZW50cyArIG5ld0xpbmU7XG5cbiAgICAgIGZ1bmN0aW9uIGdldE5leHRMaW5lKCkge1xuICAgICAgICByZXR1cm4gcmVtYWluaW5nTGluZXNJbmRleCA8IHJlbWFpbmluZ0xpbmVzLmxlbmd0aCA/XG4gICAgICAgICAgICByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4KytdIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBXZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBwb3NpdGlvbiBvZiBcInJlbWFpbmluZ0xpbmVzXCJcbiAgICB2YXIgbGFzdEdlbmVyYXRlZExpbmUgPSAxLCBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcblxuICAgIC8vIFRoZSBnZW5lcmF0ZSBTb3VyY2VOb2RlcyB3ZSBuZWVkIGEgY29kZSByYW5nZS5cbiAgICAvLyBUbyBleHRyYWN0IGl0IGN1cnJlbnQgYW5kIGxhc3QgbWFwcGluZyBpcyB1c2VkLlxuICAgIC8vIEhlcmUgd2Ugc3RvcmUgdGhlIGxhc3QgbWFwcGluZy5cbiAgICB2YXIgbGFzdE1hcHBpbmcgPSBudWxsO1xuXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICBpZiAobGFzdE1hcHBpbmcgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2UgYWRkIHRoZSBjb2RlIGZyb20gXCJsYXN0TWFwcGluZ1wiIHRvIFwibWFwcGluZ1wiOlxuICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGVyZSBpcyBhIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgIGlmIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIC8vIEFzc29jaWF0ZSBmaXJzdCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgICAgLy8gVGhlIHJlbWFpbmluZyBjb2RlIGlzIGFkZGVkIHdpdGhvdXQgbWFwcGluZ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSBjb2RlIGJldHdlZW4gXCJsYXN0R2VuZXJhdGVkQ29sdW1uXCIgYW5kXG4gICAgICAgICAgLy8gXCJtYXBwaW5nLmdlbmVyYXRlZENvbHVtblwiIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF0gfHwgJyc7XG4gICAgICAgICAgdmFyIGNvZGUgPSBuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgIHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBjb2RlKTtcbiAgICAgICAgICAvLyBObyBtb3JlIHJlbWFpbmluZyBjb2RlLCBjb250aW51ZVxuICAgICAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFdlIGFkZCB0aGUgZ2VuZXJhdGVkIGNvZGUgdW50aWwgdGhlIGZpcnN0IG1hcHBpbmdcbiAgICAgIC8vIHRvIHRoZSBTb3VyY2VOb2RlIHdpdGhvdXQgYW55IG1hcHBpbmcuXG4gICAgICAvLyBFYWNoIGxpbmUgaXMgYWRkZWQgYXMgc2VwYXJhdGUgc3RyaW5nLlxuICAgICAgd2hpbGUgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIG5vZGUuYWRkKHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICB9XG4gICAgICBpZiAobGFzdEdlbmVyYXRlZENvbHVtbiA8IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSB7XG4gICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdIHx8ICcnO1xuICAgICAgICBub2RlLmFkZChuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pKTtcbiAgICAgICAgcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICB9XG4gICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgfSwgdGhpcyk7XG4gICAgLy8gV2UgaGF2ZSBwcm9jZXNzZWQgYWxsIG1hcHBpbmdzLlxuICAgIGlmIChyZW1haW5pbmdMaW5lc0luZGV4IDwgcmVtYWluaW5nTGluZXMubGVuZ3RoKSB7XG4gICAgICBpZiAobGFzdE1hcHBpbmcpIHtcbiAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSByZW1haW5pbmcgY29kZSBpbiB0aGUgY3VycmVudCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgIH1cbiAgICAgIC8vIGFuZCBhZGQgdGhlIHJlbWFpbmluZyBsaW5lcyB3aXRob3V0IGFueSBtYXBwaW5nXG4gICAgICBub2RlLmFkZChyZW1haW5pbmdMaW5lcy5zcGxpY2UocmVtYWluaW5nTGluZXNJbmRleCkuam9pbihcIlwiKSk7XG4gICAgfVxuXG4gICAgLy8gQ29weSBzb3VyY2VzQ29udGVudCBpbnRvIFNvdXJjZU5vZGVcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVJlbGF0aXZlUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbm9kZTtcblxuICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdXaXRoQ29kZShtYXBwaW5nLCBjb2RlKSB7XG4gICAgICBpZiAobWFwcGluZyA9PT0gbnVsbCB8fCBtYXBwaW5nLnNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGUuYWRkKGNvZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFSZWxhdGl2ZVBhdGhcbiAgICAgICAgICA/IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICA6IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBub2RlLmFkZChuZXcgU291cmNlTm9kZShtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoaXMgc291cmNlIG5vZGUuXG4gKlxuICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gU291cmNlTm9kZV9hZGQoYUNodW5rKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICBhQ2h1bmsuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHRoaXMuYWRkKGNodW5rKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGFDaHVuaykge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGFDaHVuayk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBzb3VyY2Ugbm9kZS5cbiAqXG4gKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gU291cmNlTm9kZV9wcmVwZW5kKGFDaHVuaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgZm9yICh2YXIgaSA9IGFDaHVuay5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMucHJlcGVuZChhQ2h1bmtbaV0pO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgdGhpcy5jaGlsZHJlbi51bnNoaWZ0KGFDaHVuayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgSlMgc25pcHBldHMgaW4gdGhpcyBub2RlIGFuZCBpdHMgY2hpbGRyZW4uIFRoZVxuICogd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgb25jZSBmb3IgZWFjaCBzbmlwcGV0IG9mIEpTIGFuZCBpcyBwYXNzZWQgdGhhdFxuICogc25pcHBldCBhbmQgdGhlIGl0cyBvcmlnaW5hbCBhc3NvY2lhdGVkIHNvdXJjZSdzIGxpbmUvY29sdW1uIGxvY2F0aW9uLlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2FsayhhRm4pIHtcbiAgdmFyIGNodW5rO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNodW5rID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICBpZiAoY2h1bmtbaXNTb3VyY2VOb2RlXSkge1xuICAgICAgY2h1bmsud2FsayhhRm4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChjaHVuayAhPT0gJycpIHtcbiAgICAgICAgYUZuKGNodW5rLCB7IHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBMaWtlIGBTdHJpbmcucHJvdG90eXBlLmpvaW5gIGV4Y2VwdCBmb3IgU291cmNlTm9kZXMuIEluc2VydHMgYGFTdHJgIGJldHdlZW5cbiAqIGVhY2ggb2YgYHRoaXMuY2hpbGRyZW5gLlxuICpcbiAqIEBwYXJhbSBhU2VwIFRoZSBzZXBhcmF0b3IuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2pvaW4oYVNlcCkge1xuICB2YXIgbmV3Q2hpbGRyZW47XG4gIHZhciBpO1xuICB2YXIgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuLTE7IGkrKykge1xuICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgIG5ld0NoaWxkcmVuLnB1c2goYVNlcCk7XG4gICAgfVxuICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSBvbiB0aGUgdmVyeSByaWdodC1tb3N0IHNvdXJjZSBzbmlwcGV0LiBVc2VmdWxcbiAqIGZvciB0cmltbWluZyB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZCBvZiBhIHNvdXJjZSBub2RlLCBldGMuXG4gKlxuICogQHBhcmFtIGFQYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gKiBAcGFyYW0gYVJlcGxhY2VtZW50IFRoZSB0aGluZyB0byByZXBsYWNlIHRoZSBwYXR0ZXJuIHdpdGguXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnJlcGxhY2VSaWdodCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpIHtcbiAgdmFyIGxhc3RDaGlsZCA9IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgaWYgKGxhc3RDaGlsZFtpc1NvdXJjZU5vZGVdKSB7XG4gICAgbGFzdENoaWxkLnJlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgbGFzdENoaWxkID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IGxhc3RDaGlsZC5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuY2hpbGRyZW4ucHVzaCgnJy5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3JcbiAqIGluIHRoZSBzb3VyY2VzQ29udGVudCBmaWVsZC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZVxuICogQHBhcmFtIGFTb3VyY2VDb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSBzb3VyY2UgZmlsZVxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIHRoaXMuc291cmNlQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhhU291cmNlRmlsZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gIH07XG5cbi8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIFNvdXJjZU5vZGVzLiBUaGUgd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGVhY2hcbiAqIHNvdXJjZSBmaWxlIGNvbnRlbnQgYW5kIGlzIHBhc3NlZCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZSBjb250ZW50LlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2Fsa1NvdXJjZUNvbnRlbnRzID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV93YWxrU291cmNlQ29udGVudHMoYUZuKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldW2lzU291cmNlTm9kZV0pIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS53YWxrU291cmNlQ29udGVudHMoYUZuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc291cmNlcyA9IE9iamVjdC5rZXlzKHRoaXMuc291cmNlQ29udGVudHMpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhRm4odXRpbC5mcm9tU2V0U3RyaW5nKHNvdXJjZXNbaV0pLCB0aGlzLnNvdXJjZUNvbnRlbnRzW3NvdXJjZXNbaV1dKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZS4gV2Fsa3Mgb3ZlciB0aGUgdHJlZVxuICogYW5kIGNvbmNhdGVuYXRlcyBhbGwgdGhlIHZhcmlvdXMgc25pcHBldHMgdG9nZXRoZXIgdG8gb25lIHN0cmluZy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nKCkge1xuICB2YXIgc3RyID0gXCJcIjtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHN0ciArPSBjaHVuaztcbiAgfSk7XG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlIGFsb25nIHdpdGggYSBzb3VyY2VcbiAqIG1hcC5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmdXaXRoU291cmNlTWFwID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZ1dpdGhTb3VyY2VNYXAoYUFyZ3MpIHtcbiAgdmFyIGdlbmVyYXRlZCA9IHtcbiAgICBjb2RlOiBcIlwiLFxuICAgIGxpbmU6IDEsXG4gICAgY29sdW1uOiAwXG4gIH07XG4gIHZhciBtYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKTtcbiAgdmFyIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgdmFyIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxOYW1lID0gbnVsbDtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaywgb3JpZ2luYWwpIHtcbiAgICBnZW5lcmF0ZWQuY29kZSArPSBjaHVuaztcbiAgICBpZiAob3JpZ2luYWwuc291cmNlICE9PSBudWxsXG4gICAgICAgICYmIG9yaWdpbmFsLmxpbmUgIT09IG51bGxcbiAgICAgICAgJiYgb3JpZ2luYWwuY29sdW1uICE9PSBudWxsKSB7XG4gICAgICBpZihsYXN0T3JpZ2luYWxTb3VyY2UgIT09IG9yaWdpbmFsLnNvdXJjZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTGluZSAhPT0gb3JpZ2luYWwubGluZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsQ29sdW1uICE9PSBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbE5hbWUgIT09IG9yaWdpbmFsLm5hbWUpIHtcbiAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICBsYXN0T3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgIGxhc3RPcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgIGxhc3RPcmlnaW5hbE5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGlkeCA9IDAsIGxlbmd0aCA9IGNodW5rLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgaWYgKGNodW5rLmNoYXJDb2RlQXQoaWR4KSA9PT0gTkVXTElORV9DT0RFKSB7XG4gICAgICAgIGdlbmVyYXRlZC5saW5lKys7XG4gICAgICAgIGdlbmVyYXRlZC5jb2x1bW4gPSAwO1xuICAgICAgICAvLyBNYXBwaW5ncyBlbmQgYXQgZW9sXG4gICAgICAgIGlmIChpZHggKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW5lcmF0ZWQuY29sdW1uKys7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdGhpcy53YWxrU291cmNlQ29udGVudHMoZnVuY3Rpb24gKHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpIHtcbiAgICBtYXAuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgY29kZTogZ2VuZXJhdGVkLmNvZGUsIG1hcDogbWFwIH07XG59O1xuXG5leHBvcnRzLlNvdXJjZU5vZGUgPSBTb3VyY2VOb2RlO1xuIl0sIm5hbWVzIjpbIlNvdXJjZU1hcEdlbmVyYXRvciIsInJlcXVpcmUiLCJ1dGlsIiwiUkVHRVhfTkVXTElORSIsIk5FV0xJTkVfQ09ERSIsImlzU291cmNlTm9kZSIsIlNvdXJjZU5vZGUiLCJhTGluZSIsImFDb2x1bW4iLCJhU291cmNlIiwiYUNodW5rcyIsImFOYW1lIiwiY2hpbGRyZW4iLCJzb3VyY2VDb250ZW50cyIsImxpbmUiLCJjb2x1bW4iLCJzb3VyY2UiLCJuYW1lIiwiYWRkIiwiZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAiLCJTb3VyY2VOb2RlX2Zyb21TdHJpbmdXaXRoU291cmNlTWFwIiwiYUdlbmVyYXRlZENvZGUiLCJhU291cmNlTWFwQ29uc3VtZXIiLCJhUmVsYXRpdmVQYXRoIiwibm9kZSIsInJlbWFpbmluZ0xpbmVzIiwic3BsaXQiLCJyZW1haW5pbmdMaW5lc0luZGV4Iiwic2hpZnROZXh0TGluZSIsImxpbmVDb250ZW50cyIsImdldE5leHRMaW5lIiwibmV3TGluZSIsImxlbmd0aCIsInVuZGVmaW5lZCIsImxhc3RHZW5lcmF0ZWRMaW5lIiwibGFzdEdlbmVyYXRlZENvbHVtbiIsImxhc3RNYXBwaW5nIiwiZWFjaE1hcHBpbmciLCJtYXBwaW5nIiwiZ2VuZXJhdGVkTGluZSIsImFkZE1hcHBpbmdXaXRoQ29kZSIsIm5leHRMaW5lIiwiY29kZSIsInN1YnN0ciIsImdlbmVyYXRlZENvbHVtbiIsInNwbGljZSIsImpvaW4iLCJzb3VyY2VzIiwiZm9yRWFjaCIsInNvdXJjZUZpbGUiLCJjb250ZW50Iiwic291cmNlQ29udGVudEZvciIsInNldFNvdXJjZUNvbnRlbnQiLCJvcmlnaW5hbExpbmUiLCJvcmlnaW5hbENvbHVtbiIsInByb3RvdHlwZSIsIlNvdXJjZU5vZGVfYWRkIiwiYUNodW5rIiwiQXJyYXkiLCJpc0FycmF5IiwiY2h1bmsiLCJwdXNoIiwiVHlwZUVycm9yIiwicHJlcGVuZCIsIlNvdXJjZU5vZGVfcHJlcGVuZCIsImkiLCJ1bnNoaWZ0Iiwid2FsayIsIlNvdXJjZU5vZGVfd2FsayIsImFGbiIsImxlbiIsIlNvdXJjZU5vZGVfam9pbiIsImFTZXAiLCJuZXdDaGlsZHJlbiIsInJlcGxhY2VSaWdodCIsIlNvdXJjZU5vZGVfcmVwbGFjZVJpZ2h0IiwiYVBhdHRlcm4iLCJhUmVwbGFjZW1lbnQiLCJsYXN0Q2hpbGQiLCJyZXBsYWNlIiwiU291cmNlTm9kZV9zZXRTb3VyY2VDb250ZW50IiwiYVNvdXJjZUZpbGUiLCJhU291cmNlQ29udGVudCIsInRvU2V0U3RyaW5nIiwid2Fsa1NvdXJjZUNvbnRlbnRzIiwiU291cmNlTm9kZV93YWxrU291cmNlQ29udGVudHMiLCJPYmplY3QiLCJrZXlzIiwiZnJvbVNldFN0cmluZyIsInRvU3RyaW5nIiwiU291cmNlTm9kZV90b1N0cmluZyIsInN0ciIsInRvU3RyaW5nV2l0aFNvdXJjZU1hcCIsIlNvdXJjZU5vZGVfdG9TdHJpbmdXaXRoU291cmNlTWFwIiwiYUFyZ3MiLCJnZW5lcmF0ZWQiLCJtYXAiLCJzb3VyY2VNYXBwaW5nQWN0aXZlIiwibGFzdE9yaWdpbmFsU291cmNlIiwibGFzdE9yaWdpbmFsTGluZSIsImxhc3RPcmlnaW5hbENvbHVtbiIsImxhc3RPcmlnaW5hbE5hbWUiLCJvcmlnaW5hbCIsImFkZE1hcHBpbmciLCJpZHgiLCJjaGFyQ29kZUF0Iiwic291cmNlQ29udGVudCIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../source-map-js/lib/source-node.js\n");

/***/ }),

/***/ "(rsc)/../source-map-js/lib/source-node.js":
/*!*******************************************!*\
  !*** ../source-map-js/lib/source-node.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ var SourceMapGenerator = (__webpack_require__(/*! ./source-map-generator */ \"(rsc)/../source-map-js/lib/source-map-generator.js\").SourceMapGenerator);\nvar util = __webpack_require__(/*! ./util */ \"(rsc)/../source-map-js/lib/util.js\");\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */ function SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n    this.children = [];\n    this.sourceContents = {};\n    this.line = aLine == null ? null : aLine;\n    this.column = aColumn == null ? null : aColumn;\n    this.source = aSource == null ? null : aSource;\n    this.name = aName == null ? null : aName;\n    this[isSourceNode] = true;\n    if (aChunks != null) this.add(aChunks);\n}\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */ SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var remainingLinesIndex = 0;\n    var shiftNextLine = function() {\n        var lineContents = getNextLine();\n        // The last line of a file might not have a newline.\n        var newLine = getNextLine() || \"\";\n        return lineContents + newLine;\n        function getNextLine() {\n            return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;\n        }\n    };\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n    aSourceMapConsumer.eachMapping(function(mapping) {\n        if (lastMapping !== null) {\n            // We add the code from \"lastMapping\" to \"mapping\":\n            // First check if there is a new line in between.\n            if (lastGeneratedLine < mapping.generatedLine) {\n                // Associate first line with \"lastMapping\"\n                addMappingWithCode(lastMapping, shiftNextLine());\n                lastGeneratedLine++;\n                lastGeneratedColumn = 0;\n            // The remaining code is added without mapping\n            } else {\n                // There is no new line in between.\n                // Associate the code between \"lastGeneratedColumn\" and\n                // \"mapping.generatedColumn\" with \"lastMapping\"\n                var nextLine = remainingLines[remainingLinesIndex] || \"\";\n                var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);\n                remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);\n                lastGeneratedColumn = mapping.generatedColumn;\n                addMappingWithCode(lastMapping, code);\n                // No more remaining code, continue\n                lastMapping = mapping;\n                return;\n            }\n        }\n        // We add the generated code until the first mapping\n        // to the SourceNode without any mapping.\n        // Each line is added as separate string.\n        while(lastGeneratedLine < mapping.generatedLine){\n            node.add(shiftNextLine());\n            lastGeneratedLine++;\n        }\n        if (lastGeneratedColumn < mapping.generatedColumn) {\n            var nextLine = remainingLines[remainingLinesIndex] || \"\";\n            node.add(nextLine.substr(0, mapping.generatedColumn));\n            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n            lastGeneratedColumn = mapping.generatedColumn;\n        }\n        lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n        if (lastMapping) {\n            // Associate the remaining code in the current line with \"lastMapping\"\n            addMappingWithCode(lastMapping, shiftNextLine());\n        }\n        // and add the remaining lines without any mapping\n        node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function(sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n            if (aRelativePath != null) {\n                sourceFile = util.join(aRelativePath, sourceFile);\n            }\n            node.setSourceContent(sourceFile, content);\n        }\n    });\n    return node;\n    function addMappingWithCode(mapping, code) {\n        if (mapping === null || mapping.source === undefined) {\n            node.add(code);\n        } else {\n            var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;\n            node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));\n        }\n    }\n};\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */ SourceNode.prototype.add = function SourceNode_add(aChunk) {\n    if (Array.isArray(aChunk)) {\n        aChunk.forEach(function(chunk) {\n            this.add(chunk);\n        }, this);\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n        if (aChunk) {\n            this.children.push(aChunk);\n        }\n    } else {\n        throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n    }\n    return this;\n};\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */ SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n    if (Array.isArray(aChunk)) {\n        for(var i = aChunk.length - 1; i >= 0; i--){\n            this.prepend(aChunk[i]);\n        }\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n        this.children.unshift(aChunk);\n    } else {\n        throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n    }\n    return this;\n};\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */ SourceNode.prototype.walk = function SourceNode_walk(aFn) {\n    var chunk;\n    for(var i = 0, len = this.children.length; i < len; i++){\n        chunk = this.children[i];\n        if (chunk[isSourceNode]) {\n            chunk.walk(aFn);\n        } else {\n            if (chunk !== \"\") {\n                aFn(chunk, {\n                    source: this.source,\n                    line: this.line,\n                    column: this.column,\n                    name: this.name\n                });\n            }\n        }\n    }\n};\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */ SourceNode.prototype.join = function SourceNode_join(aSep) {\n    var newChildren;\n    var i;\n    var len = this.children.length;\n    if (len > 0) {\n        newChildren = [];\n        for(i = 0; i < len - 1; i++){\n            newChildren.push(this.children[i]);\n            newChildren.push(aSep);\n        }\n        newChildren.push(this.children[i]);\n        this.children = newChildren;\n    }\n    return this;\n};\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */ SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n    var lastChild = this.children[this.children.length - 1];\n    if (lastChild[isSourceNode]) {\n        lastChild.replaceRight(aPattern, aReplacement);\n    } else if (typeof lastChild === \"string\") {\n        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n    } else {\n        this.children.push(\"\".replace(aPattern, aReplacement));\n    }\n    return this;\n};\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */ SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n};\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */ SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {\n    for(var i = 0, len = this.children.length; i < len; i++){\n        if (this.children[i][isSourceNode]) {\n            this.children[i].walkSourceContents(aFn);\n        }\n    }\n    var sources = Object.keys(this.sourceContents);\n    for(var i = 0, len = sources.length; i < len; i++){\n        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n};\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */ SourceNode.prototype.toString = function SourceNode_toString() {\n    var str = \"\";\n    this.walk(function(chunk) {\n        str += chunk;\n    });\n    return str;\n};\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */ SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n    var generated = {\n        code: \"\",\n        line: 1,\n        column: 0\n    };\n    var map = new SourceMapGenerator(aArgs);\n    var sourceMappingActive = false;\n    var lastOriginalSource = null;\n    var lastOriginalLine = null;\n    var lastOriginalColumn = null;\n    var lastOriginalName = null;\n    this.walk(function(chunk, original) {\n        generated.code += chunk;\n        if (original.source !== null && original.line !== null && original.column !== null) {\n            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {\n                map.addMapping({\n                    source: original.source,\n                    original: {\n                        line: original.line,\n                        column: original.column\n                    },\n                    generated: {\n                        line: generated.line,\n                        column: generated.column\n                    },\n                    name: original.name\n                });\n            }\n            lastOriginalSource = original.source;\n            lastOriginalLine = original.line;\n            lastOriginalColumn = original.column;\n            lastOriginalName = original.name;\n            sourceMappingActive = true;\n        } else if (sourceMappingActive) {\n            map.addMapping({\n                generated: {\n                    line: generated.line,\n                    column: generated.column\n                }\n            });\n            lastOriginalSource = null;\n            sourceMappingActive = false;\n        }\n        for(var idx = 0, length = chunk.length; idx < length; idx++){\n            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n                generated.line++;\n                generated.column = 0;\n                // Mappings end at eol\n                if (idx + 1 === length) {\n                    lastOriginalSource = null;\n                    sourceMappingActive = false;\n                } else if (sourceMappingActive) {\n                    map.addMapping({\n                        source: original.source,\n                        original: {\n                            line: original.line,\n                            column: original.column\n                        },\n                        generated: {\n                            line: generated.line,\n                            column: generated.column\n                        },\n                        name: original.name\n                    });\n                }\n            } else {\n                generated.column++;\n            }\n        }\n    });\n    this.walkSourceContents(function(sourceFile, sourceContent) {\n        map.setSourceContent(sourceFile, sourceContent);\n    });\n    return {\n        code: generated.code,\n        map: map\n    };\n};\nexports.SourceNode = SourceNode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vc291cmNlLW1hcC1qcy9saWIvc291cmNlLW5vZGUuanMiLCJtYXBwaW5ncyI6IkFBQUEseUNBQXlDLEdBQ3pDOzs7O0NBSUMsR0FFRCxJQUFJQSxxQkFBcUJDLDRIQUFvRDtBQUM3RSxJQUFJQyxPQUFPRCxtQkFBT0EsQ0FBQztBQUVuQiw2RUFBNkU7QUFDN0UsdURBQXVEO0FBQ3ZELElBQUlFLGdCQUFnQjtBQUVwQixzREFBc0Q7QUFDdEQsSUFBSUMsZUFBZTtBQUVuQix5RUFBeUU7QUFDekUsaUVBQWlFO0FBQ2pFLFlBQVk7QUFDWixJQUFJQyxlQUFlO0FBRW5COzs7Ozs7Ozs7OztDQVdDLEdBQ0QsU0FBU0MsV0FBV0MsS0FBSyxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxLQUFLO0lBQ3pELElBQUksQ0FBQ0MsUUFBUSxHQUFHLEVBQUU7SUFDbEIsSUFBSSxDQUFDQyxjQUFjLEdBQUcsQ0FBQztJQUN2QixJQUFJLENBQUNDLElBQUksR0FBR1AsU0FBUyxPQUFPLE9BQU9BO0lBQ25DLElBQUksQ0FBQ1EsTUFBTSxHQUFHUCxXQUFXLE9BQU8sT0FBT0E7SUFDdkMsSUFBSSxDQUFDUSxNQUFNLEdBQUdQLFdBQVcsT0FBTyxPQUFPQTtJQUN2QyxJQUFJLENBQUNRLElBQUksR0FBR04sU0FBUyxPQUFPLE9BQU9BO0lBQ25DLElBQUksQ0FBQ04sYUFBYSxHQUFHO0lBQ3JCLElBQUlLLFdBQVcsTUFBTSxJQUFJLENBQUNRLEdBQUcsQ0FBQ1I7QUFDaEM7QUFFQTs7Ozs7OztDQU9DLEdBQ0RKLFdBQVdhLHVCQUF1QixHQUNoQyxTQUFTQyxtQ0FBbUNDLGNBQWMsRUFBRUMsa0JBQWtCLEVBQUVDLGFBQWE7SUFDM0YseURBQXlEO0lBQ3pELG9CQUFvQjtJQUNwQixJQUFJQyxPQUFPLElBQUlsQjtJQUVmLHFFQUFxRTtJQUNyRSxvRUFBb0U7SUFDcEUsOENBQThDO0lBQzlDLCtEQUErRDtJQUMvRCxJQUFJbUIsaUJBQWlCSixlQUFlSyxLQUFLLENBQUN2QjtJQUMxQyxJQUFJd0Isc0JBQXNCO0lBQzFCLElBQUlDLGdCQUFnQjtRQUNsQixJQUFJQyxlQUFlQztRQUNuQixvREFBb0Q7UUFDcEQsSUFBSUMsVUFBVUQsaUJBQWlCO1FBQy9CLE9BQU9ELGVBQWVFO1FBRXRCLFNBQVNEO1lBQ1AsT0FBT0gsc0JBQXNCRixlQUFlTyxNQUFNLEdBQzlDUCxjQUFjLENBQUNFLHNCQUFzQixHQUFHTTtRQUM5QztJQUNGO0lBRUEsdURBQXVEO0lBQ3ZELElBQUlDLG9CQUFvQixHQUFHQyxzQkFBc0I7SUFFakQsaURBQWlEO0lBQ2pELGtEQUFrRDtJQUNsRCxrQ0FBa0M7SUFDbEMsSUFBSUMsY0FBYztJQUVsQmQsbUJBQW1CZSxXQUFXLENBQUMsU0FBVUMsT0FBTztRQUM5QyxJQUFJRixnQkFBZ0IsTUFBTTtZQUN4QixtREFBbUQ7WUFDbkQsaURBQWlEO1lBQ2pELElBQUlGLG9CQUFvQkksUUFBUUMsYUFBYSxFQUFFO2dCQUM3QywwQ0FBMEM7Z0JBQzFDQyxtQkFBbUJKLGFBQWFSO2dCQUNoQ007Z0JBQ0FDLHNCQUFzQjtZQUN0Qiw4Q0FBOEM7WUFDaEQsT0FBTztnQkFDTCxtQ0FBbUM7Z0JBQ25DLHVEQUF1RDtnQkFDdkQsK0NBQStDO2dCQUMvQyxJQUFJTSxXQUFXaEIsY0FBYyxDQUFDRSxvQkFBb0IsSUFBSTtnQkFDdEQsSUFBSWUsT0FBT0QsU0FBU0UsTUFBTSxDQUFDLEdBQUdMLFFBQVFNLGVBQWUsR0FDdkJUO2dCQUM5QlYsY0FBYyxDQUFDRSxvQkFBb0IsR0FBR2MsU0FBU0UsTUFBTSxDQUFDTCxRQUFRTSxlQUFlLEdBQ3pDVDtnQkFDcENBLHNCQUFzQkcsUUFBUU0sZUFBZTtnQkFDN0NKLG1CQUFtQkosYUFBYU07Z0JBQ2hDLG1DQUFtQztnQkFDbkNOLGNBQWNFO2dCQUNkO1lBQ0Y7UUFDRjtRQUNBLG9EQUFvRDtRQUNwRCx5Q0FBeUM7UUFDekMseUNBQXlDO1FBQ3pDLE1BQU9KLG9CQUFvQkksUUFBUUMsYUFBYSxDQUFFO1lBQ2hEZixLQUFLTixHQUFHLENBQUNVO1lBQ1RNO1FBQ0Y7UUFDQSxJQUFJQyxzQkFBc0JHLFFBQVFNLGVBQWUsRUFBRTtZQUNqRCxJQUFJSCxXQUFXaEIsY0FBYyxDQUFDRSxvQkFBb0IsSUFBSTtZQUN0REgsS0FBS04sR0FBRyxDQUFDdUIsU0FBU0UsTUFBTSxDQUFDLEdBQUdMLFFBQVFNLGVBQWU7WUFDbkRuQixjQUFjLENBQUNFLG9CQUFvQixHQUFHYyxTQUFTRSxNQUFNLENBQUNMLFFBQVFNLGVBQWU7WUFDN0VULHNCQUFzQkcsUUFBUU0sZUFBZTtRQUMvQztRQUNBUixjQUFjRTtJQUNoQixHQUFHLElBQUk7SUFDUCxrQ0FBa0M7SUFDbEMsSUFBSVgsc0JBQXNCRixlQUFlTyxNQUFNLEVBQUU7UUFDL0MsSUFBSUksYUFBYTtZQUNmLHNFQUFzRTtZQUN0RUksbUJBQW1CSixhQUFhUjtRQUNsQztRQUNBLGtEQUFrRDtRQUNsREosS0FBS04sR0FBRyxDQUFDTyxlQUFlb0IsTUFBTSxDQUFDbEIscUJBQXFCbUIsSUFBSSxDQUFDO0lBQzNEO0lBRUEsc0NBQXNDO0lBQ3RDeEIsbUJBQW1CeUIsT0FBTyxDQUFDQyxPQUFPLENBQUMsU0FBVUMsVUFBVTtRQUNyRCxJQUFJQyxVQUFVNUIsbUJBQW1CNkIsZ0JBQWdCLENBQUNGO1FBQ2xELElBQUlDLFdBQVcsTUFBTTtZQUNuQixJQUFJM0IsaUJBQWlCLE1BQU07Z0JBQ3pCMEIsYUFBYS9DLEtBQUs0QyxJQUFJLENBQUN2QixlQUFlMEI7WUFDeEM7WUFDQXpCLEtBQUs0QixnQkFBZ0IsQ0FBQ0gsWUFBWUM7UUFDcEM7SUFDRjtJQUVBLE9BQU8xQjtJQUVQLFNBQVNnQixtQkFBbUJGLE9BQU8sRUFBRUksSUFBSTtRQUN2QyxJQUFJSixZQUFZLFFBQVFBLFFBQVF0QixNQUFNLEtBQUtpQixXQUFXO1lBQ3BEVCxLQUFLTixHQUFHLENBQUN3QjtRQUNYLE9BQU87WUFDTCxJQUFJMUIsU0FBU08sZ0JBQ1RyQixLQUFLNEMsSUFBSSxDQUFDdkIsZUFBZWUsUUFBUXRCLE1BQU0sSUFDdkNzQixRQUFRdEIsTUFBTTtZQUNsQlEsS0FBS04sR0FBRyxDQUFDLElBQUlaLFdBQVdnQyxRQUFRZSxZQUFZLEVBQ3BCZixRQUFRZ0IsY0FBYyxFQUN0QnRDLFFBQ0EwQixNQUNBSixRQUFRckIsSUFBSTtRQUN0QztJQUNGO0FBQ0Y7QUFFRjs7Ozs7Q0FLQyxHQUNEWCxXQUFXaUQsU0FBUyxDQUFDckMsR0FBRyxHQUFHLFNBQVNzQyxlQUFlQyxNQUFNO0lBQ3ZELElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0YsU0FBUztRQUN6QkEsT0FBT1QsT0FBTyxDQUFDLFNBQVVZLEtBQUs7WUFDNUIsSUFBSSxDQUFDMUMsR0FBRyxDQUFDMEM7UUFDWCxHQUFHLElBQUk7SUFDVCxPQUNLLElBQUlILE1BQU0sQ0FBQ3BELGFBQWEsSUFBSSxPQUFPb0QsV0FBVyxVQUFVO1FBQzNELElBQUlBLFFBQVE7WUFDVixJQUFJLENBQUM3QyxRQUFRLENBQUNpRCxJQUFJLENBQUNKO1FBQ3JCO0lBQ0YsT0FDSztRQUNILE1BQU0sSUFBSUssVUFDUixnRkFBZ0ZMO0lBRXBGO0lBQ0EsT0FBTyxJQUFJO0FBQ2I7QUFFQTs7Ozs7Q0FLQyxHQUNEbkQsV0FBV2lELFNBQVMsQ0FBQ1EsT0FBTyxHQUFHLFNBQVNDLG1CQUFtQlAsTUFBTTtJQUMvRCxJQUFJQyxNQUFNQyxPQUFPLENBQUNGLFNBQVM7UUFDekIsSUFBSyxJQUFJUSxJQUFJUixPQUFPekIsTUFBTSxHQUFDLEdBQUdpQyxLQUFLLEdBQUdBLElBQUs7WUFDekMsSUFBSSxDQUFDRixPQUFPLENBQUNOLE1BQU0sQ0FBQ1EsRUFBRTtRQUN4QjtJQUNGLE9BQ0ssSUFBSVIsTUFBTSxDQUFDcEQsYUFBYSxJQUFJLE9BQU9vRCxXQUFXLFVBQVU7UUFDM0QsSUFBSSxDQUFDN0MsUUFBUSxDQUFDc0QsT0FBTyxDQUFDVDtJQUN4QixPQUNLO1FBQ0gsTUFBTSxJQUFJSyxVQUNSLGdGQUFnRkw7SUFFcEY7SUFDQSxPQUFPLElBQUk7QUFDYjtBQUVBOzs7Ozs7Q0FNQyxHQUNEbkQsV0FBV2lELFNBQVMsQ0FBQ1ksSUFBSSxHQUFHLFNBQVNDLGdCQUFnQkMsR0FBRztJQUN0RCxJQUFJVDtJQUNKLElBQUssSUFBSUssSUFBSSxHQUFHSyxNQUFNLElBQUksQ0FBQzFELFFBQVEsQ0FBQ29CLE1BQU0sRUFBRWlDLElBQUlLLEtBQUtMLElBQUs7UUFDeERMLFFBQVEsSUFBSSxDQUFDaEQsUUFBUSxDQUFDcUQsRUFBRTtRQUN4QixJQUFJTCxLQUFLLENBQUN2RCxhQUFhLEVBQUU7WUFDdkJ1RCxNQUFNTyxJQUFJLENBQUNFO1FBQ2IsT0FDSztZQUNILElBQUlULFVBQVUsSUFBSTtnQkFDaEJTLElBQUlULE9BQU87b0JBQUU1QyxRQUFRLElBQUksQ0FBQ0EsTUFBTTtvQkFDbkJGLE1BQU0sSUFBSSxDQUFDQSxJQUFJO29CQUNmQyxRQUFRLElBQUksQ0FBQ0EsTUFBTTtvQkFDbkJFLE1BQU0sSUFBSSxDQUFDQSxJQUFJO2dCQUFDO1lBQy9CO1FBQ0Y7SUFDRjtBQUNGO0FBRUE7Ozs7O0NBS0MsR0FDRFgsV0FBV2lELFNBQVMsQ0FBQ1QsSUFBSSxHQUFHLFNBQVN5QixnQkFBZ0JDLElBQUk7SUFDdkQsSUFBSUM7SUFDSixJQUFJUjtJQUNKLElBQUlLLE1BQU0sSUFBSSxDQUFDMUQsUUFBUSxDQUFDb0IsTUFBTTtJQUM5QixJQUFJc0MsTUFBTSxHQUFHO1FBQ1hHLGNBQWMsRUFBRTtRQUNoQixJQUFLUixJQUFJLEdBQUdBLElBQUlLLE1BQUksR0FBR0wsSUFBSztZQUMxQlEsWUFBWVosSUFBSSxDQUFDLElBQUksQ0FBQ2pELFFBQVEsQ0FBQ3FELEVBQUU7WUFDakNRLFlBQVlaLElBQUksQ0FBQ1c7UUFDbkI7UUFDQUMsWUFBWVosSUFBSSxDQUFDLElBQUksQ0FBQ2pELFFBQVEsQ0FBQ3FELEVBQUU7UUFDakMsSUFBSSxDQUFDckQsUUFBUSxHQUFHNkQ7SUFDbEI7SUFDQSxPQUFPLElBQUk7QUFDYjtBQUVBOzs7Ozs7Q0FNQyxHQUNEbkUsV0FBV2lELFNBQVMsQ0FBQ21CLFlBQVksR0FBRyxTQUFTQyx3QkFBd0JDLFFBQVEsRUFBRUMsWUFBWTtJQUN6RixJQUFJQyxZQUFZLElBQUksQ0FBQ2xFLFFBQVEsQ0FBQyxJQUFJLENBQUNBLFFBQVEsQ0FBQ29CLE1BQU0sR0FBRyxFQUFFO0lBQ3ZELElBQUk4QyxTQUFTLENBQUN6RSxhQUFhLEVBQUU7UUFDM0J5RSxVQUFVSixZQUFZLENBQUNFLFVBQVVDO0lBQ25DLE9BQ0ssSUFBSSxPQUFPQyxjQUFjLFVBQVU7UUFDdEMsSUFBSSxDQUFDbEUsUUFBUSxDQUFDLElBQUksQ0FBQ0EsUUFBUSxDQUFDb0IsTUFBTSxHQUFHLEVBQUUsR0FBRzhDLFVBQVVDLE9BQU8sQ0FBQ0gsVUFBVUM7SUFDeEUsT0FDSztRQUNILElBQUksQ0FBQ2pFLFFBQVEsQ0FBQ2lELElBQUksQ0FBQyxHQUFHa0IsT0FBTyxDQUFDSCxVQUFVQztJQUMxQztJQUNBLE9BQU8sSUFBSTtBQUNiO0FBRUE7Ozs7OztDQU1DLEdBQ0R2RSxXQUFXaUQsU0FBUyxDQUFDSCxnQkFBZ0IsR0FDbkMsU0FBUzRCLDRCQUE0QkMsV0FBVyxFQUFFQyxjQUFjO0lBQzlELElBQUksQ0FBQ3JFLGNBQWMsQ0FBQ1gsS0FBS2lGLFdBQVcsQ0FBQ0YsYUFBYSxHQUFHQztBQUN2RDtBQUVGOzs7OztDQUtDLEdBQ0Q1RSxXQUFXaUQsU0FBUyxDQUFDNkIsa0JBQWtCLEdBQ3JDLFNBQVNDLDhCQUE4QmhCLEdBQUc7SUFDeEMsSUFBSyxJQUFJSixJQUFJLEdBQUdLLE1BQU0sSUFBSSxDQUFDMUQsUUFBUSxDQUFDb0IsTUFBTSxFQUFFaUMsSUFBSUssS0FBS0wsSUFBSztRQUN4RCxJQUFJLElBQUksQ0FBQ3JELFFBQVEsQ0FBQ3FELEVBQUUsQ0FBQzVELGFBQWEsRUFBRTtZQUNsQyxJQUFJLENBQUNPLFFBQVEsQ0FBQ3FELEVBQUUsQ0FBQ21CLGtCQUFrQixDQUFDZjtRQUN0QztJQUNGO0lBRUEsSUFBSXRCLFVBQVV1QyxPQUFPQyxJQUFJLENBQUMsSUFBSSxDQUFDMUUsY0FBYztJQUM3QyxJQUFLLElBQUlvRCxJQUFJLEdBQUdLLE1BQU12QixRQUFRZixNQUFNLEVBQUVpQyxJQUFJSyxLQUFLTCxJQUFLO1FBQ2xESSxJQUFJbkUsS0FBS3NGLGFBQWEsQ0FBQ3pDLE9BQU8sQ0FBQ2tCLEVBQUUsR0FBRyxJQUFJLENBQUNwRCxjQUFjLENBQUNrQyxPQUFPLENBQUNrQixFQUFFLENBQUM7SUFDckU7QUFDRjtBQUVGOzs7Q0FHQyxHQUNEM0QsV0FBV2lELFNBQVMsQ0FBQ2tDLFFBQVEsR0FBRyxTQUFTQztJQUN2QyxJQUFJQyxNQUFNO0lBQ1YsSUFBSSxDQUFDeEIsSUFBSSxDQUFDLFNBQVVQLEtBQUs7UUFDdkIrQixPQUFPL0I7SUFDVDtJQUNBLE9BQU8rQjtBQUNUO0FBRUE7OztDQUdDLEdBQ0RyRixXQUFXaUQsU0FBUyxDQUFDcUMscUJBQXFCLEdBQUcsU0FBU0MsaUNBQWlDQyxLQUFLO0lBQzFGLElBQUlDLFlBQVk7UUFDZHJELE1BQU07UUFDTjVCLE1BQU07UUFDTkMsUUFBUTtJQUNWO0lBQ0EsSUFBSWlGLE1BQU0sSUFBSWhHLG1CQUFtQjhGO0lBQ2pDLElBQUlHLHNCQUFzQjtJQUMxQixJQUFJQyxxQkFBcUI7SUFDekIsSUFBSUMsbUJBQW1CO0lBQ3ZCLElBQUlDLHFCQUFxQjtJQUN6QixJQUFJQyxtQkFBbUI7SUFDdkIsSUFBSSxDQUFDbEMsSUFBSSxDQUFDLFNBQVVQLEtBQUssRUFBRTBDLFFBQVE7UUFDakNQLFVBQVVyRCxJQUFJLElBQUlrQjtRQUNsQixJQUFJMEMsU0FBU3RGLE1BQU0sS0FBSyxRQUNqQnNGLFNBQVN4RixJQUFJLEtBQUssUUFDbEJ3RixTQUFTdkYsTUFBTSxLQUFLLE1BQU07WUFDL0IsSUFBR21GLHVCQUF1QkksU0FBU3RGLE1BQU0sSUFDbkNtRixxQkFBcUJHLFNBQVN4RixJQUFJLElBQ2xDc0YsdUJBQXVCRSxTQUFTdkYsTUFBTSxJQUN0Q3NGLHFCQUFxQkMsU0FBU3JGLElBQUksRUFBRTtnQkFDeEMrRSxJQUFJTyxVQUFVLENBQUM7b0JBQ2J2RixRQUFRc0YsU0FBU3RGLE1BQU07b0JBQ3ZCc0YsVUFBVTt3QkFDUnhGLE1BQU13RixTQUFTeEYsSUFBSTt3QkFDbkJDLFFBQVF1RixTQUFTdkYsTUFBTTtvQkFDekI7b0JBQ0FnRixXQUFXO3dCQUNUakYsTUFBTWlGLFVBQVVqRixJQUFJO3dCQUNwQkMsUUFBUWdGLFVBQVVoRixNQUFNO29CQUMxQjtvQkFDQUUsTUFBTXFGLFNBQVNyRixJQUFJO2dCQUNyQjtZQUNGO1lBQ0FpRixxQkFBcUJJLFNBQVN0RixNQUFNO1lBQ3BDbUYsbUJBQW1CRyxTQUFTeEYsSUFBSTtZQUNoQ3NGLHFCQUFxQkUsU0FBU3ZGLE1BQU07WUFDcENzRixtQkFBbUJDLFNBQVNyRixJQUFJO1lBQ2hDZ0Ysc0JBQXNCO1FBQ3hCLE9BQU8sSUFBSUEscUJBQXFCO1lBQzlCRCxJQUFJTyxVQUFVLENBQUM7Z0JBQ2JSLFdBQVc7b0JBQ1RqRixNQUFNaUYsVUFBVWpGLElBQUk7b0JBQ3BCQyxRQUFRZ0YsVUFBVWhGLE1BQU07Z0JBQzFCO1lBQ0Y7WUFDQW1GLHFCQUFxQjtZQUNyQkQsc0JBQXNCO1FBQ3hCO1FBQ0EsSUFBSyxJQUFJTyxNQUFNLEdBQUd4RSxTQUFTNEIsTUFBTTVCLE1BQU0sRUFBRXdFLE1BQU14RSxRQUFRd0UsTUFBTztZQUM1RCxJQUFJNUMsTUFBTTZDLFVBQVUsQ0FBQ0QsU0FBU3BHLGNBQWM7Z0JBQzFDMkYsVUFBVWpGLElBQUk7Z0JBQ2RpRixVQUFVaEYsTUFBTSxHQUFHO2dCQUNuQixzQkFBc0I7Z0JBQ3RCLElBQUl5RixNQUFNLE1BQU14RSxRQUFRO29CQUN0QmtFLHFCQUFxQjtvQkFDckJELHNCQUFzQjtnQkFDeEIsT0FBTyxJQUFJQSxxQkFBcUI7b0JBQzlCRCxJQUFJTyxVQUFVLENBQUM7d0JBQ2J2RixRQUFRc0YsU0FBU3RGLE1BQU07d0JBQ3ZCc0YsVUFBVTs0QkFDUnhGLE1BQU13RixTQUFTeEYsSUFBSTs0QkFDbkJDLFFBQVF1RixTQUFTdkYsTUFBTTt3QkFDekI7d0JBQ0FnRixXQUFXOzRCQUNUakYsTUFBTWlGLFVBQVVqRixJQUFJOzRCQUNwQkMsUUFBUWdGLFVBQVVoRixNQUFNO3dCQUMxQjt3QkFDQUUsTUFBTXFGLFNBQVNyRixJQUFJO29CQUNyQjtnQkFDRjtZQUNGLE9BQU87Z0JBQ0w4RSxVQUFVaEYsTUFBTTtZQUNsQjtRQUNGO0lBQ0Y7SUFDQSxJQUFJLENBQUNxRSxrQkFBa0IsQ0FBQyxTQUFVbkMsVUFBVSxFQUFFeUQsYUFBYTtRQUN6RFYsSUFBSTVDLGdCQUFnQixDQUFDSCxZQUFZeUQ7SUFDbkM7SUFFQSxPQUFPO1FBQUVoRSxNQUFNcUQsVUFBVXJELElBQUk7UUFBRXNELEtBQUtBO0lBQUk7QUFDMUM7QUFFQVcsa0JBQWtCLEdBQUdyRyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWVtYWlsLy4uL3NvdXJjZS1tYXAtanMvbGliL3NvdXJjZS1ub2RlLmpzPzA0NzciXSwic291cmNlc0NvbnRlbnQiOlsiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIE1hdGNoZXMgYSBXaW5kb3dzLXN0eWxlIGBcXHJcXG5gIG5ld2xpbmUgb3IgYSBgXFxuYCBuZXdsaW5lIHVzZWQgYnkgYWxsIG90aGVyXG4vLyBvcGVyYXRpbmcgc3lzdGVtcyB0aGVzZSBkYXlzIChjYXB0dXJpbmcgdGhlIHJlc3VsdCkuXG52YXIgUkVHRVhfTkVXTElORSA9IC8oXFxyP1xcbikvO1xuXG4vLyBOZXdsaW5lIGNoYXJhY3RlciBjb2RlIGZvciBjaGFyQ29kZUF0KCkgY29tcGFyaXNvbnNcbnZhciBORVdMSU5FX0NPREUgPSAxMDtcblxuLy8gUHJpdmF0ZSBzeW1ib2wgZm9yIGlkZW50aWZ5aW5nIGBTb3VyY2VOb2RlYHMgd2hlbiBtdWx0aXBsZSB2ZXJzaW9ucyBvZlxuLy8gdGhlIHNvdXJjZS1tYXAgbGlicmFyeSBhcmUgbG9hZGVkLiBUaGlzIE1VU1QgTk9UIENIQU5HRSBhY3Jvc3Ncbi8vIHZlcnNpb25zIVxudmFyIGlzU291cmNlTm9kZSA9IFwiJCQkaXNTb3VyY2VOb2RlJCQkXCI7XG5cbi8qKlxuICogU291cmNlTm9kZXMgcHJvdmlkZSBhIHdheSB0byBhYnN0cmFjdCBvdmVyIGludGVycG9sYXRpbmcvY29uY2F0ZW5hdGluZ1xuICogc25pcHBldHMgb2YgZ2VuZXJhdGVkIEphdmFTY3JpcHQgc291cmNlIGNvZGUgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIGxpbmUgYW5kXG4gKiBjb2x1bW4gaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcGFyYW0gYUxpbmUgVGhlIG9yaWdpbmFsIGxpbmUgbnVtYmVyLlxuICogQHBhcmFtIGFDb2x1bW4gVGhlIG9yaWdpbmFsIGNvbHVtbiBudW1iZXIuXG4gKiBAcGFyYW0gYVNvdXJjZSBUaGUgb3JpZ2luYWwgc291cmNlJ3MgZmlsZW5hbWUuXG4gKiBAcGFyYW0gYUNodW5rcyBPcHRpb25hbC4gQW4gYXJyYXkgb2Ygc3RyaW5ncyB3aGljaCBhcmUgc25pcHBldHMgb2ZcbiAqICAgICAgICBnZW5lcmF0ZWQgSlMsIG9yIG90aGVyIFNvdXJjZU5vZGVzLlxuICogQHBhcmFtIGFOYW1lIFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLlxuICovXG5mdW5jdGlvbiBTb3VyY2VOb2RlKGFMaW5lLCBhQ29sdW1uLCBhU291cmNlLCBhQ2h1bmtzLCBhTmFtZSkge1xuICB0aGlzLmNoaWxkcmVuID0gW107XG4gIHRoaXMuc291cmNlQ29udGVudHMgPSB7fTtcbiAgdGhpcy5saW5lID0gYUxpbmUgPT0gbnVsbCA/IG51bGwgOiBhTGluZTtcbiAgdGhpcy5jb2x1bW4gPSBhQ29sdW1uID09IG51bGwgPyBudWxsIDogYUNvbHVtbjtcbiAgdGhpcy5zb3VyY2UgPSBhU291cmNlID09IG51bGwgPyBudWxsIDogYVNvdXJjZTtcbiAgdGhpcy5uYW1lID0gYU5hbWUgPT0gbnVsbCA/IG51bGwgOiBhTmFtZTtcbiAgdGhpc1tpc1NvdXJjZU5vZGVdID0gdHJ1ZTtcbiAgaWYgKGFDaHVua3MgIT0gbnVsbCkgdGhpcy5hZGQoYUNodW5rcyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFNvdXJjZU5vZGUgZnJvbSBnZW5lcmF0ZWQgY29kZSBhbmQgYSBTb3VyY2VNYXBDb25zdW1lci5cbiAqXG4gKiBAcGFyYW0gYUdlbmVyYXRlZENvZGUgVGhlIGdlbmVyYXRlZCBjb2RlXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAgZm9yIHRoZSBnZW5lcmF0ZWQgY29kZVxuICogQHBhcmFtIGFSZWxhdGl2ZVBhdGggT3B0aW9uYWwuIFRoZSBwYXRoIHRoYXQgcmVsYXRpdmUgc291cmNlcyBpbiB0aGVcbiAqICAgICAgICBTb3VyY2VNYXBDb25zdW1lciBzaG91bGQgYmUgcmVsYXRpdmUgdG8uXG4gKi9cblNvdXJjZU5vZGUuZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VOb2RlX2Zyb21TdHJpbmdXaXRoU291cmNlTWFwKGFHZW5lcmF0ZWRDb2RlLCBhU291cmNlTWFwQ29uc3VtZXIsIGFSZWxhdGl2ZVBhdGgpIHtcbiAgICAvLyBUaGUgU291cmNlTm9kZSB3ZSB3YW50IHRvIGZpbGwgd2l0aCB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAvLyBhbmQgdGhlIFNvdXJjZU1hcFxuICAgIHZhciBub2RlID0gbmV3IFNvdXJjZU5vZGUoKTtcblxuICAgIC8vIEFsbCBldmVuIGluZGljZXMgb2YgdGhpcyBhcnJheSBhcmUgb25lIGxpbmUgb2YgdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAgIC8vIHdoaWxlIGFsbCBvZGQgaW5kaWNlcyBhcmUgdGhlIG5ld2xpbmVzIGJldHdlZW4gdHdvIGFkamFjZW50IGxpbmVzXG4gICAgLy8gKHNpbmNlIGBSRUdFWF9ORVdMSU5FYCBjYXB0dXJlcyBpdHMgbWF0Y2gpLlxuICAgIC8vIFByb2Nlc3NlZCBmcmFnbWVudHMgYXJlIGFjY2Vzc2VkIGJ5IGNhbGxpbmcgYHNoaWZ0TmV4dExpbmVgLlxuICAgIHZhciByZW1haW5pbmdMaW5lcyA9IGFHZW5lcmF0ZWRDb2RlLnNwbGl0KFJFR0VYX05FV0xJTkUpO1xuICAgIHZhciByZW1haW5pbmdMaW5lc0luZGV4ID0gMDtcbiAgICB2YXIgc2hpZnROZXh0TGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpbmVDb250ZW50cyA9IGdldE5leHRMaW5lKCk7XG4gICAgICAvLyBUaGUgbGFzdCBsaW5lIG9mIGEgZmlsZSBtaWdodCBub3QgaGF2ZSBhIG5ld2xpbmUuXG4gICAgICB2YXIgbmV3TGluZSA9IGdldE5leHRMaW5lKCkgfHwgXCJcIjtcbiAgICAgIHJldHVybiBsaW5lQ29udGVudHMgKyBuZXdMaW5lO1xuXG4gICAgICBmdW5jdGlvbiBnZXROZXh0TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZ0xpbmVzSW5kZXggPCByZW1haW5pbmdMaW5lcy5sZW5ndGggP1xuICAgICAgICAgICAgcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleCsrXSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gV2UgbmVlZCB0byByZW1lbWJlciB0aGUgcG9zaXRpb24gb2YgXCJyZW1haW5pbmdMaW5lc1wiXG4gICAgdmFyIGxhc3RHZW5lcmF0ZWRMaW5lID0gMSwgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG5cbiAgICAvLyBUaGUgZ2VuZXJhdGUgU291cmNlTm9kZXMgd2UgbmVlZCBhIGNvZGUgcmFuZ2UuXG4gICAgLy8gVG8gZXh0cmFjdCBpdCBjdXJyZW50IGFuZCBsYXN0IG1hcHBpbmcgaXMgdXNlZC5cbiAgICAvLyBIZXJlIHdlIHN0b3JlIHRoZSBsYXN0IG1hcHBpbmcuXG4gICAgdmFyIGxhc3RNYXBwaW5nID0gbnVsbDtcblxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGFkZCB0aGUgY29kZSBmcm9tIFwibGFzdE1hcHBpbmdcIiB0byBcIm1hcHBpbmdcIjpcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlcmUgaXMgYSBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICBpZiAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAvLyBBc3NvY2lhdGUgZmlyc3QgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgY29kZSBpcyBhZGRlZCB3aXRob3V0IG1hcHBpbmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgY29kZSBiZXR3ZWVuIFwibGFzdEdlbmVyYXRlZENvbHVtblwiIGFuZFxuICAgICAgICAgIC8vIFwibWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cIiB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdIHx8ICcnO1xuICAgICAgICAgIHZhciBjb2RlID0gbmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgY29kZSk7XG4gICAgICAgICAgLy8gTm8gbW9yZSByZW1haW5pbmcgY29kZSwgY29udGludWVcbiAgICAgICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXZSBhZGQgdGhlIGdlbmVyYXRlZCBjb2RlIHVudGlsIHRoZSBmaXJzdCBtYXBwaW5nXG4gICAgICAvLyB0byB0aGUgU291cmNlTm9kZSB3aXRob3V0IGFueSBtYXBwaW5nLlxuICAgICAgLy8gRWFjaCBsaW5lIGlzIGFkZGVkIGFzIHNlcGFyYXRlIHN0cmluZy5cbiAgICAgIHdoaWxlIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICBub2RlLmFkZChzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRDb2x1bW4gPCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikge1xuICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSB8fCAnJztcbiAgICAgICAgbm9kZS5hZGQobmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSk7XG4gICAgICAgIHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgfVxuICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgIH0sIHRoaXMpO1xuICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBtYXBwaW5ncy5cbiAgICBpZiAocmVtYWluaW5nTGluZXNJbmRleCA8IHJlbWFpbmluZ0xpbmVzLmxlbmd0aCkge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nKSB7XG4gICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgcmVtYWluaW5nIGNvZGUgaW4gdGhlIGN1cnJlbnQgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICB9XG4gICAgICAvLyBhbmQgYWRkIHRoZSByZW1haW5pbmcgbGluZXMgd2l0aG91dCBhbnkgbWFwcGluZ1xuICAgICAgbm9kZS5hZGQocmVtYWluaW5nTGluZXMuc3BsaWNlKHJlbWFpbmluZ0xpbmVzSW5kZXgpLmpvaW4oXCJcIikpO1xuICAgIH1cblxuICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnQgaW50byBTb3VyY2VOb2RlXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGFSZWxhdGl2ZVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGU7XG5cbiAgICBmdW5jdGlvbiBhZGRNYXBwaW5nV2l0aENvZGUobWFwcGluZywgY29kZSkge1xuICAgICAgaWYgKG1hcHBpbmcgPT09IG51bGwgfHwgbWFwcGluZy5zb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2RlLmFkZChjb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhUmVsYXRpdmVQYXRoXG4gICAgICAgICAgPyB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgOiBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgbm9kZS5hZGQobmV3IFNvdXJjZU5vZGUobWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5uYW1lKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGlzIHNvdXJjZSBub2RlLlxuICpcbiAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfYWRkKGFDaHVuaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgYUNodW5rLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICB0aGlzLmFkZChjaHVuayk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChhQ2h1bmspIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChhQ2h1bmspO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgc291cmNlIG5vZGUuXG4gKlxuICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcHJlcGVuZChhQ2h1bmspIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgIGZvciAodmFyIGkgPSBhQ2h1bmsubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLnByZXBlbmQoYUNodW5rW2ldKTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRoaXMuY2hpbGRyZW4udW5zaGlmdChhQ2h1bmspO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIEpTIHNuaXBwZXRzIGluIHRoaXMgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLiBUaGVcbiAqIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2UgZm9yIGVhY2ggc25pcHBldCBvZiBKUyBhbmQgaXMgcGFzc2VkIHRoYXRcbiAqIHNuaXBwZXQgYW5kIHRoZSBpdHMgb3JpZ2luYWwgYXNzb2NpYXRlZCBzb3VyY2UncyBsaW5lL2NvbHVtbiBsb2NhdGlvbi5cbiAqXG4gKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGsoYUZuKSB7XG4gIHZhciBjaHVuaztcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjaHVuayA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgaWYgKGNodW5rW2lzU291cmNlTm9kZV0pIHtcbiAgICAgIGNodW5rLndhbGsoYUZuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoY2h1bmsgIT09ICcnKSB7XG4gICAgICAgIGFGbihjaHVuaywgeyBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTGlrZSBgU3RyaW5nLnByb3RvdHlwZS5qb2luYCBleGNlcHQgZm9yIFNvdXJjZU5vZGVzLiBJbnNlcnRzIGBhU3RyYCBiZXR3ZWVuXG4gKiBlYWNoIG9mIGB0aGlzLmNoaWxkcmVuYC5cbiAqXG4gKiBAcGFyYW0gYVNlcCBUaGUgc2VwYXJhdG9yLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gU291cmNlTm9kZV9qb2luKGFTZXApIHtcbiAgdmFyIG5ld0NoaWxkcmVuO1xuICB2YXIgaTtcbiAgdmFyIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICBpZiAobGVuID4gMCkge1xuICAgIG5ld0NoaWxkcmVuID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbi0xOyBpKyspIHtcbiAgICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKGFTZXApO1xuICAgIH1cbiAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBuZXdDaGlsZHJlbjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Ugb24gdGhlIHZlcnkgcmlnaHQtbW9zdCBzb3VyY2Ugc25pcHBldC4gVXNlZnVsXG4gKiBmb3IgdHJpbW1pbmcgd2hpdGVzcGFjZSBmcm9tIHRoZSBlbmQgb2YgYSBzb3VyY2Ugbm9kZSwgZXRjLlxuICpcbiAqIEBwYXJhbSBhUGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICogQHBhcmFtIGFSZXBsYWNlbWVudCBUaGUgdGhpbmcgdG8gcmVwbGFjZSB0aGUgcGF0dGVybiB3aXRoLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5yZXBsYWNlUmlnaHQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3JlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KSB7XG4gIHZhciBsYXN0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gIGlmIChsYXN0Q2hpbGRbaXNTb3VyY2VOb2RlXSkge1xuICAgIGxhc3RDaGlsZC5yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGxhc3RDaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPSBsYXN0Q2hpbGQucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goJycucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yXG4gKiBpbiB0aGUgc291cmNlc0NvbnRlbnQgZmllbGQuXG4gKlxuICogQHBhcmFtIGFTb3VyY2VGaWxlIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGVcbiAqIEBwYXJhbSBhU291cmNlQ29udGVudCBUaGUgY29udGVudCBvZiB0aGUgc291cmNlIGZpbGVcbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICB0aGlzLnNvdXJjZUNvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoYVNvdXJjZUZpbGUpXSA9IGFTb3VyY2VDb250ZW50O1xuICB9O1xuXG4vKipcbiAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBTb3VyY2VOb2Rlcy4gVGhlIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoXG4gKiBzb3VyY2UgZmlsZSBjb250ZW50IGFuZCBpcyBwYXNzZWQgdGhlIGZpbGVuYW1lIGFuZCBzb3VyY2UgY29udGVudC5cbiAqXG4gKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLndhbGtTb3VyY2VDb250ZW50cyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzKGFGbikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbltpXVtpc1NvdXJjZU5vZGVdKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0ud2Fsa1NvdXJjZUNvbnRlbnRzKGFGbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZXMgPSBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUNvbnRlbnRzKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYUZuKHV0aWwuZnJvbVNldFN0cmluZyhzb3VyY2VzW2ldKSwgdGhpcy5zb3VyY2VDb250ZW50c1tzb3VyY2VzW2ldXSk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybiB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUuIFdhbGtzIG92ZXIgdGhlIHRyZWVcbiAqIGFuZCBjb25jYXRlbmF0ZXMgYWxsIHRoZSB2YXJpb3VzIHNuaXBwZXRzIHRvZ2V0aGVyIHRvIG9uZSBzdHJpbmcuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZygpIHtcbiAgdmFyIHN0ciA9IFwiXCI7XG4gIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBzdHIgKz0gY2h1bms7XG4gIH0pO1xuICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZSBhbG9uZyB3aXRoIGEgc291cmNlXG4gKiBtYXAuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nV2l0aFNvdXJjZU1hcCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmdXaXRoU291cmNlTWFwKGFBcmdzKSB7XG4gIHZhciBnZW5lcmF0ZWQgPSB7XG4gICAgY29kZTogXCJcIixcbiAgICBsaW5lOiAxLFxuICAgIGNvbHVtbjogMFxuICB9O1xuICB2YXIgbWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncyk7XG4gIHZhciBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gIHZhciBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsTGluZSA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsTmFtZSA9IG51bGw7XG4gIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmssIG9yaWdpbmFsKSB7XG4gICAgZ2VuZXJhdGVkLmNvZGUgKz0gY2h1bms7XG4gICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPT0gbnVsbFxuICAgICAgICAmJiBvcmlnaW5hbC5saW5lICE9PSBudWxsXG4gICAgICAgICYmIG9yaWdpbmFsLmNvbHVtbiAhPT0gbnVsbCkge1xuICAgICAgaWYobGFzdE9yaWdpbmFsU291cmNlICE9PSBvcmlnaW5hbC5zb3VyY2VcbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbExpbmUgIT09IG9yaWdpbmFsLmxpbmVcbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbENvbHVtbiAhPT0gb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxOYW1lICE9PSBvcmlnaW5hbC5uYW1lKSB7XG4gICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgbGFzdE9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICBsYXN0T3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICBsYXN0T3JpZ2luYWxOYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpZHggPSAwLCBsZW5ndGggPSBjaHVuay5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgIGlmIChjaHVuay5jaGFyQ29kZUF0KGlkeCkgPT09IE5FV0xJTkVfQ09ERSkge1xuICAgICAgICBnZW5lcmF0ZWQubGluZSsrO1xuICAgICAgICBnZW5lcmF0ZWQuY29sdW1uID0gMDtcbiAgICAgICAgLy8gTWFwcGluZ3MgZW5kIGF0IGVvbFxuICAgICAgICBpZiAoaWR4ICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbisrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHRoaXMud2Fsa1NvdXJjZUNvbnRlbnRzKGZ1bmN0aW9uIChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KSB7XG4gICAgbWFwLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgc291cmNlQ29udGVudCk7XG4gIH0pO1xuXG4gIHJldHVybiB7IGNvZGU6IGdlbmVyYXRlZC5jb2RlLCBtYXA6IG1hcCB9O1xufTtcblxuZXhwb3J0cy5Tb3VyY2VOb2RlID0gU291cmNlTm9kZTtcbiJdLCJuYW1lcyI6WyJTb3VyY2VNYXBHZW5lcmF0b3IiLCJyZXF1aXJlIiwidXRpbCIsIlJFR0VYX05FV0xJTkUiLCJORVdMSU5FX0NPREUiLCJpc1NvdXJjZU5vZGUiLCJTb3VyY2VOb2RlIiwiYUxpbmUiLCJhQ29sdW1uIiwiYVNvdXJjZSIsImFDaHVua3MiLCJhTmFtZSIsImNoaWxkcmVuIiwic291cmNlQ29udGVudHMiLCJsaW5lIiwiY29sdW1uIiwic291cmNlIiwibmFtZSIsImFkZCIsImZyb21TdHJpbmdXaXRoU291cmNlTWFwIiwiU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCIsImFHZW5lcmF0ZWRDb2RlIiwiYVNvdXJjZU1hcENvbnN1bWVyIiwiYVJlbGF0aXZlUGF0aCIsIm5vZGUiLCJyZW1haW5pbmdMaW5lcyIsInNwbGl0IiwicmVtYWluaW5nTGluZXNJbmRleCIsInNoaWZ0TmV4dExpbmUiLCJsaW5lQ29udGVudHMiLCJnZXROZXh0TGluZSIsIm5ld0xpbmUiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJsYXN0R2VuZXJhdGVkTGluZSIsImxhc3RHZW5lcmF0ZWRDb2x1bW4iLCJsYXN0TWFwcGluZyIsImVhY2hNYXBwaW5nIiwibWFwcGluZyIsImdlbmVyYXRlZExpbmUiLCJhZGRNYXBwaW5nV2l0aENvZGUiLCJuZXh0TGluZSIsImNvZGUiLCJzdWJzdHIiLCJnZW5lcmF0ZWRDb2x1bW4iLCJzcGxpY2UiLCJqb2luIiwic291cmNlcyIsImZvckVhY2giLCJzb3VyY2VGaWxlIiwiY29udGVudCIsInNvdXJjZUNvbnRlbnRGb3IiLCJzZXRTb3VyY2VDb250ZW50Iiwib3JpZ2luYWxMaW5lIiwib3JpZ2luYWxDb2x1bW4iLCJwcm90b3R5cGUiLCJTb3VyY2VOb2RlX2FkZCIsImFDaHVuayIsIkFycmF5IiwiaXNBcnJheSIsImNodW5rIiwicHVzaCIsIlR5cGVFcnJvciIsInByZXBlbmQiLCJTb3VyY2VOb2RlX3ByZXBlbmQiLCJpIiwidW5zaGlmdCIsIndhbGsiLCJTb3VyY2VOb2RlX3dhbGsiLCJhRm4iLCJsZW4iLCJTb3VyY2VOb2RlX2pvaW4iLCJhU2VwIiwibmV3Q2hpbGRyZW4iLCJyZXBsYWNlUmlnaHQiLCJTb3VyY2VOb2RlX3JlcGxhY2VSaWdodCIsImFQYXR0ZXJuIiwiYVJlcGxhY2VtZW50IiwibGFzdENoaWxkIiwicmVwbGFjZSIsIlNvdXJjZU5vZGVfc2V0U291cmNlQ29udGVudCIsImFTb3VyY2VGaWxlIiwiYVNvdXJjZUNvbnRlbnQiLCJ0b1NldFN0cmluZyIsIndhbGtTb3VyY2VDb250ZW50cyIsIlNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzIiwiT2JqZWN0Iiwia2V5cyIsImZyb21TZXRTdHJpbmciLCJ0b1N0cmluZyIsIlNvdXJjZU5vZGVfdG9TdHJpbmciLCJzdHIiLCJ0b1N0cmluZ1dpdGhTb3VyY2VNYXAiLCJTb3VyY2VOb2RlX3RvU3RyaW5nV2l0aFNvdXJjZU1hcCIsImFBcmdzIiwiZ2VuZXJhdGVkIiwibWFwIiwic291cmNlTWFwcGluZ0FjdGl2ZSIsImxhc3RPcmlnaW5hbFNvdXJjZSIsImxhc3RPcmlnaW5hbExpbmUiLCJsYXN0T3JpZ2luYWxDb2x1bW4iLCJsYXN0T3JpZ2luYWxOYW1lIiwib3JpZ2luYWwiLCJhZGRNYXBwaW5nIiwiaWR4IiwiY2hhckNvZGVBdCIsInNvdXJjZUNvbnRlbnQiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../source-map-js/lib/source-node.js\n");

/***/ }),

/***/ "(action-browser)/../source-map-js/lib/util.js":
/*!************************************!*\
  !*** ../source-map-js/lib/util.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ /**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */ function getArg(aArgs, aName, aDefaultValue) {\n    if (aName in aArgs) {\n        return aArgs[aName];\n    } else if (arguments.length === 3) {\n        return aDefaultValue;\n    } else {\n        throw new Error('\"' + aName + '\" is a required argument.');\n    }\n}\nexports.getArg = getArg;\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\nfunction urlParse(aUrl) {\n    var match = aUrl.match(urlRegexp);\n    if (!match) {\n        return null;\n    }\n    return {\n        scheme: match[1],\n        auth: match[2],\n        host: match[3],\n        port: match[4],\n        path: match[5]\n    };\n}\nexports.urlParse = urlParse;\nfunction urlGenerate(aParsedUrl) {\n    var url = \"\";\n    if (aParsedUrl.scheme) {\n        url += aParsedUrl.scheme + \":\";\n    }\n    url += \"//\";\n    if (aParsedUrl.auth) {\n        url += aParsedUrl.auth + \"@\";\n    }\n    if (aParsedUrl.host) {\n        url += aParsedUrl.host;\n    }\n    if (aParsedUrl.port) {\n        url += \":\" + aParsedUrl.port;\n    }\n    if (aParsedUrl.path) {\n        url += aParsedUrl.path;\n    }\n    return url;\n}\nexports.urlGenerate = urlGenerate;\nvar MAX_CACHED_INPUTS = 32;\n/**\n * Takes some function `f(input) -> result` and returns a memoized version of\n * `f`.\n *\n * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The\n * memoization is a dumb-simple, linear least-recently-used cache.\n */ function lruMemoize(f) {\n    var cache = [];\n    return function(input) {\n        for(var i = 0; i < cache.length; i++){\n            if (cache[i].input === input) {\n                var temp = cache[0];\n                cache[0] = cache[i];\n                cache[i] = temp;\n                return cache[0].result;\n            }\n        }\n        var result = f(input);\n        cache.unshift({\n            input,\n            result\n        });\n        if (cache.length > MAX_CACHED_INPUTS) {\n            cache.pop();\n        }\n        return result;\n    };\n}\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */ var normalize = lruMemoize(function normalize(aPath) {\n    var path = aPath;\n    var url = urlParse(aPath);\n    if (url) {\n        if (!url.path) {\n            return aPath;\n        }\n        path = url.path;\n    }\n    var isAbsolute = exports.isAbsolute(path);\n    // Split the path into parts between `/` characters. This is much faster than\n    // using `.split(/\\/+/g)`.\n    var parts = [];\n    var start = 0;\n    var i = 0;\n    while(true){\n        start = i;\n        i = path.indexOf(\"/\", start);\n        if (i === -1) {\n            parts.push(path.slice(start));\n            break;\n        } else {\n            parts.push(path.slice(start, i));\n            while(i < path.length && path[i] === \"/\"){\n                i++;\n            }\n        }\n    }\n    for(var part, up = 0, i = parts.length - 1; i >= 0; i--){\n        part = parts[i];\n        if (part === \".\") {\n            parts.splice(i, 1);\n        } else if (part === \"..\") {\n            up++;\n        } else if (up > 0) {\n            if (part === \"\") {\n                // The first part is blank if the path is absolute. Trying to go\n                // above the root is a no-op. Therefore we can remove all '..' parts\n                // directly after the root.\n                parts.splice(i + 1, up);\n                up = 0;\n            } else {\n                parts.splice(i, 2);\n                up--;\n            }\n        }\n    }\n    path = parts.join(\"/\");\n    if (path === \"\") {\n        path = isAbsolute ? \"/\" : \".\";\n    }\n    if (url) {\n        url.path = path;\n        return urlGenerate(url);\n    }\n    return path;\n});\nexports.normalize = normalize;\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */ function join(aRoot, aPath) {\n    if (aRoot === \"\") {\n        aRoot = \".\";\n    }\n    if (aPath === \"\") {\n        aPath = \".\";\n    }\n    var aPathUrl = urlParse(aPath);\n    var aRootUrl = urlParse(aRoot);\n    if (aRootUrl) {\n        aRoot = aRootUrl.path || \"/\";\n    }\n    // `join(foo, '//www.example.org')`\n    if (aPathUrl && !aPathUrl.scheme) {\n        if (aRootUrl) {\n            aPathUrl.scheme = aRootUrl.scheme;\n        }\n        return urlGenerate(aPathUrl);\n    }\n    if (aPathUrl || aPath.match(dataUrlRegexp)) {\n        return aPath;\n    }\n    // `join('http://', 'www.example.com')`\n    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n        aRootUrl.host = aPath;\n        return urlGenerate(aRootUrl);\n    }\n    var joined = aPath.charAt(0) === \"/\" ? aPath : normalize(aRoot.replace(/\\/+$/, \"\") + \"/\" + aPath);\n    if (aRootUrl) {\n        aRootUrl.path = joined;\n        return urlGenerate(aRootUrl);\n    }\n    return joined;\n}\nexports.join = join;\nexports.isAbsolute = function(aPath) {\n    return aPath.charAt(0) === \"/\" || urlRegexp.test(aPath);\n};\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */ function relative(aRoot, aPath) {\n    if (aRoot === \"\") {\n        aRoot = \".\";\n    }\n    aRoot = aRoot.replace(/\\/$/, \"\");\n    // It is possible for the path to be above the root. In this case, simply\n    // checking whether the root is a prefix of the path won't work. Instead, we\n    // need to remove components from the root one by one, until either we find\n    // a prefix that fits, or we run out of components to remove.\n    var level = 0;\n    while(aPath.indexOf(aRoot + \"/\") !== 0){\n        var index = aRoot.lastIndexOf(\"/\");\n        if (index < 0) {\n            return aPath;\n        }\n        // If the only part of the root that is left is the scheme (i.e. http://,\n        // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n        // have exhausted all components, so the path is not relative to the root.\n        aRoot = aRoot.slice(0, index);\n        if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n            return aPath;\n        }\n        ++level;\n    }\n    // Make sure we add a \"../\" for each component we removed from the root.\n    return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\nvar supportsNullProto = function() {\n    var obj = Object.create(null);\n    return !(\"__proto__\" in obj);\n}();\nfunction identity(s) {\n    return s;\n}\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */ function toSetString(aStr) {\n    if (isProtoString(aStr)) {\n        return \"$\" + aStr;\n    }\n    return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\nfunction fromSetString(aStr) {\n    if (isProtoString(aStr)) {\n        return aStr.slice(1);\n    }\n    return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\nfunction isProtoString(s) {\n    if (!s) {\n        return false;\n    }\n    var length = s.length;\n    if (length < 9 /* \"__proto__\".length */ ) {\n        return false;\n    }\n    if (s.charCodeAt(length - 1) !== 95 /* '_' */  || s.charCodeAt(length - 2) !== 95 /* '_' */  || s.charCodeAt(length - 3) !== 111 /* 'o' */  || s.charCodeAt(length - 4) !== 116 /* 't' */  || s.charCodeAt(length - 5) !== 111 /* 'o' */  || s.charCodeAt(length - 6) !== 114 /* 'r' */  || s.charCodeAt(length - 7) !== 112 /* 'p' */  || s.charCodeAt(length - 8) !== 95 /* '_' */  || s.charCodeAt(length - 9) !== 95 /* '_' */ ) {\n        return false;\n    }\n    for(var i = length - 10; i >= 0; i--){\n        if (s.charCodeAt(i) !== 36 /* '$' */ ) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */ function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n    var cmp = strcmp(mappingA.source, mappingB.source);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp !== 0 || onlyCompareOriginal) {\n        return cmp;\n    }\n    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\nfunction compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {\n    var cmp;\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp !== 0 || onlyCompareOriginal) {\n        return cmp;\n    }\n    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */ function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n    var cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp !== 0 || onlyCompareGenerated) {\n        return cmp;\n    }\n    cmp = strcmp(mappingA.source, mappingB.source);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\nfunction compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {\n    var cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp !== 0 || onlyCompareGenerated) {\n        return cmp;\n    }\n    cmp = strcmp(mappingA.source, mappingB.source);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;\nfunction strcmp(aStr1, aStr2) {\n    if (aStr1 === aStr2) {\n        return 0;\n    }\n    if (aStr1 === null) {\n        return 1; // aStr2 !== null\n    }\n    if (aStr2 === null) {\n        return -1; // aStr1 !== null\n    }\n    if (aStr1 > aStr2) {\n        return 1;\n    }\n    return -1;\n}\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */ function compareByGeneratedPositionsInflated(mappingA, mappingB) {\n    var cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = strcmp(mappingA.source, mappingB.source);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */ function parseSourceMapInput(str) {\n    return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, \"\"));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */ function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n    sourceURL = sourceURL || \"\";\n    if (sourceRoot) {\n        // This follows what Chrome does.\n        if (sourceRoot[sourceRoot.length - 1] !== \"/\" && sourceURL[0] !== \"/\") {\n            sourceRoot += \"/\";\n        }\n        // The spec says:\n        //   Line 4: An optional source root, useful for relocating source\n        //   files on a server or removing repeated values in the\n        //   “sources” entry.  This value is prepended to the individual\n        //   entries in the “source” field.\n        sourceURL = sourceRoot + sourceURL;\n    }\n    // Historically, SourceMapConsumer did not take the sourceMapURL as\n    // a parameter.  This mode is still somewhat supported, which is why\n    // this code block is conditional.  However, it's preferable to pass\n    // the source map URL to SourceMapConsumer, so that this function\n    // can implement the source URL resolution algorithm as outlined in\n    // the spec.  This block is basically the equivalent of:\n    //    new URL(sourceURL, sourceMapURL).toString()\n    // ... except it avoids using URL, which wasn't available in the\n    // older releases of node still supported by this library.\n    //\n    // The spec says:\n    //   If the sources are not absolute URLs after prepending of the\n    //   “sourceRoot”, the sources are resolved relative to the\n    //   SourceMap (like resolving script src in a html document).\n    if (sourceMapURL) {\n        var parsed = urlParse(sourceMapURL);\n        if (!parsed) {\n            throw new Error(\"sourceMapURL could not be parsed\");\n        }\n        if (parsed.path) {\n            // Strip the last path component, but keep the \"/\".\n            var index = parsed.path.lastIndexOf(\"/\");\n            if (index >= 0) {\n                parsed.path = parsed.path.substring(0, index + 1);\n            }\n        }\n        sourceURL = join(urlGenerate(parsed), sourceURL);\n    }\n    return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9zb3VyY2UtbWFwLWpzL2xpYi91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBLHlDQUF5QyxHQUN6Qzs7OztDQUlDLEdBRUQ7Ozs7Ozs7OztDQVNDLEdBQ0QsU0FBU0EsT0FBT0MsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLGFBQWE7SUFDekMsSUFBSUQsU0FBU0QsT0FBTztRQUNsQixPQUFPQSxLQUFLLENBQUNDLE1BQU07SUFDckIsT0FBTyxJQUFJRSxVQUFVQyxNQUFNLEtBQUssR0FBRztRQUNqQyxPQUFPRjtJQUNULE9BQU87UUFDTCxNQUFNLElBQUlHLE1BQU0sTUFBTUosUUFBUTtJQUNoQztBQUNGO0FBQ0FLLGNBQWMsR0FBR1A7QUFFakIsSUFBSVEsWUFBWTtBQUNoQixJQUFJQyxnQkFBZ0I7QUFFcEIsU0FBU0MsU0FBU0MsSUFBSTtJQUNwQixJQUFJQyxRQUFRRCxLQUFLQyxLQUFLLENBQUNKO0lBQ3ZCLElBQUksQ0FBQ0ksT0FBTztRQUNWLE9BQU87SUFDVDtJQUNBLE9BQU87UUFDTEMsUUFBUUQsS0FBSyxDQUFDLEVBQUU7UUFDaEJFLE1BQU1GLEtBQUssQ0FBQyxFQUFFO1FBQ2RHLE1BQU1ILEtBQUssQ0FBQyxFQUFFO1FBQ2RJLE1BQU1KLEtBQUssQ0FBQyxFQUFFO1FBQ2RLLE1BQU1MLEtBQUssQ0FBQyxFQUFFO0lBQ2hCO0FBQ0Y7QUFDQUwsZ0JBQWdCLEdBQUdHO0FBRW5CLFNBQVNRLFlBQVlDLFVBQVU7SUFDN0IsSUFBSUMsTUFBTTtJQUNWLElBQUlELFdBQVdOLE1BQU0sRUFBRTtRQUNyQk8sT0FBT0QsV0FBV04sTUFBTSxHQUFHO0lBQzdCO0lBQ0FPLE9BQU87SUFDUCxJQUFJRCxXQUFXTCxJQUFJLEVBQUU7UUFDbkJNLE9BQU9ELFdBQVdMLElBQUksR0FBRztJQUMzQjtJQUNBLElBQUlLLFdBQVdKLElBQUksRUFBRTtRQUNuQkssT0FBT0QsV0FBV0osSUFBSTtJQUN4QjtJQUNBLElBQUlJLFdBQVdILElBQUks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L3NvdXJjZS1tYXAtanMvbGliL3V0aWwuanM/Zjk3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbi8qKlxuICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBwYXJhbWV0ZXIvb3B0aW9uc1xuICogb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gYXJncyBUaGUgb2JqZWN0IHdlIGFyZSBleHRyYWN0aW5nIHZhbHVlcyBmcm9tXG4gKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2UgYXJlIGdldHRpbmcuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIEFuIG9wdGlvbmFsIHZhbHVlIHRvIHJldHVybiBpZiB0aGUgcHJvcGVydHkgaXMgbWlzc2luZ1xuICogZnJvbSB0aGUgb2JqZWN0LiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQgYW5kIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nLCBhblxuICogZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gKi9cbmZ1bmN0aW9uIGdldEFyZyhhQXJncywgYU5hbWUsIGFEZWZhdWx0VmFsdWUpIHtcbiAgaWYgKGFOYW1lIGluIGFBcmdzKSB7XG4gICAgcmV0dXJuIGFBcmdzW2FOYW1lXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgcmV0dXJuIGFEZWZhdWx0VmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhTmFtZSArICdcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LicpO1xuICB9XG59XG5leHBvcnRzLmdldEFyZyA9IGdldEFyZztcblxudmFyIHVybFJlZ2V4cCA9IC9eKD86KFtcXHcrXFwtLl0rKTopP1xcL1xcLyg/OihcXHcrOlxcdyspQCk/KFtcXHcuLV0qKSg/OjooXFxkKykpPyguKikkLztcbnZhciBkYXRhVXJsUmVnZXhwID0gL15kYXRhOi4rXFwsLiskLztcblxuZnVuY3Rpb24gdXJsUGFyc2UoYVVybCkge1xuICB2YXIgbWF0Y2ggPSBhVXJsLm1hdGNoKHVybFJlZ2V4cCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNjaGVtZTogbWF0Y2hbMV0sXG4gICAgYXV0aDogbWF0Y2hbMl0sXG4gICAgaG9zdDogbWF0Y2hbM10sXG4gICAgcG9ydDogbWF0Y2hbNF0sXG4gICAgcGF0aDogbWF0Y2hbNV1cbiAgfTtcbn1cbmV4cG9ydHMudXJsUGFyc2UgPSB1cmxQYXJzZTtcblxuZnVuY3Rpb24gdXJsR2VuZXJhdGUoYVBhcnNlZFVybCkge1xuICB2YXIgdXJsID0gJyc7XG4gIGlmIChhUGFyc2VkVXJsLnNjaGVtZSkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLnNjaGVtZSArICc6JztcbiAgfVxuICB1cmwgKz0gJy8vJztcbiAgaWYgKGFQYXJzZWRVcmwuYXV0aCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmF1dGggKyAnQCc7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwuaG9zdCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmhvc3Q7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwucG9ydCkge1xuICAgIHVybCArPSBcIjpcIiArIGFQYXJzZWRVcmwucG9ydFxuICB9XG4gIGlmIChhUGFyc2VkVXJsLnBhdGgpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5wYXRoO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5leHBvcnRzLnVybEdlbmVyYXRlID0gdXJsR2VuZXJhdGU7XG5cbnZhciBNQVhfQ0FDSEVEX0lOUFVUUyA9IDMyO1xuXG4vKipcbiAqIFRha2VzIHNvbWUgZnVuY3Rpb24gYGYoaW5wdXQpIC0+IHJlc3VsdGAgYW5kIHJldHVybnMgYSBtZW1vaXplZCB2ZXJzaW9uIG9mXG4gKiBgZmAuXG4gKlxuICogV2Uga2VlcCBhdCBtb3N0IGBNQVhfQ0FDSEVEX0lOUFVUU2AgbWVtb2l6ZWQgcmVzdWx0cyBvZiBgZmAgYWxpdmUuIFRoZVxuICogbWVtb2l6YXRpb24gaXMgYSBkdW1iLXNpbXBsZSwgbGluZWFyIGxlYXN0LXJlY2VudGx5LXVzZWQgY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIGxydU1lbW9pemUoZikge1xuICB2YXIgY2FjaGUgPSBbXTtcblxuICByZXR1cm4gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhY2hlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoY2FjaGVbaV0uaW5wdXQgPT09IGlucHV0KSB7XG4gICAgICAgIHZhciB0ZW1wID0gY2FjaGVbMF07XG4gICAgICAgIGNhY2hlWzBdID0gY2FjaGVbaV07XG4gICAgICAgIGNhY2hlW2ldID0gdGVtcDtcbiAgICAgICAgcmV0dXJuIGNhY2hlWzBdLnJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gZihpbnB1dCk7XG5cbiAgICBjYWNoZS51bnNoaWZ0KHtcbiAgICAgIGlucHV0LFxuICAgICAgcmVzdWx0LFxuICAgIH0pO1xuXG4gICAgaWYgKGNhY2hlLmxlbmd0aCA+IE1BWF9DQUNIRURfSU5QVVRTKSB7XG4gICAgICBjYWNoZS5wb3AoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZXMgYSBwYXRoLCBvciB0aGUgcGF0aCBwb3J0aW9uIG9mIGEgVVJMOlxuICpcbiAqIC0gUmVwbGFjZXMgY29uc2VjdXRpdmUgc2xhc2hlcyB3aXRoIG9uZSBzbGFzaC5cbiAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnLicgcGFydHMuXG4gKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJzxkaXI+Ly4uJyBwYXJ0cy5cbiAqXG4gKiBCYXNlZCBvbiBjb2RlIGluIHRoZSBOb2RlLmpzICdwYXRoJyBjb3JlIG1vZHVsZS5cbiAqXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgdXJsIHRvIG5vcm1hbGl6ZS5cbiAqL1xudmFyIG5vcm1hbGl6ZSA9IGxydU1lbW9pemUoZnVuY3Rpb24gbm9ybWFsaXplKGFQYXRoKSB7XG4gIHZhciBwYXRoID0gYVBhdGg7XG4gIHZhciB1cmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gIGlmICh1cmwpIHtcbiAgICBpZiAoIXVybC5wYXRoKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuICAgIHBhdGggPSB1cmwucGF0aDtcbiAgfVxuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKTtcbiAgLy8gU3BsaXQgdGhlIHBhdGggaW50byBwYXJ0cyBiZXR3ZWVuIGAvYCBjaGFyYWN0ZXJzLiBUaGlzIGlzIG11Y2ggZmFzdGVyIHRoYW5cbiAgLy8gdXNpbmcgYC5zcGxpdCgvXFwvKy9nKWAuXG4gIHZhciBwYXJ0cyA9IFtdO1xuICB2YXIgc3RhcnQgPSAwO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3RhcnQgPSBpO1xuICAgIGkgPSBwYXRoLmluZGV4T2YoXCIvXCIsIHN0YXJ0KTtcbiAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgIHBhcnRzLnB1c2gocGF0aC5zbGljZShzdGFydCkpO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRzLnB1c2gocGF0aC5zbGljZShzdGFydCwgaSkpO1xuICAgICAgd2hpbGUgKGkgPCBwYXRoLmxlbmd0aCAmJiBwYXRoW2ldID09PSBcIi9cIikge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgcGFydCwgdXAgPSAwLCBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwID4gMCkge1xuICAgICAgaWYgKHBhcnQgPT09ICcnKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwYXJ0IGlzIGJsYW5rIGlmIHRoZSBwYXRoIGlzIGFic29sdXRlLiBUcnlpbmcgdG8gZ29cbiAgICAgICAgLy8gYWJvdmUgdGhlIHJvb3QgaXMgYSBuby1vcC4gVGhlcmVmb3JlIHdlIGNhbiByZW1vdmUgYWxsICcuLicgcGFydHNcbiAgICAgICAgLy8gZGlyZWN0bHkgYWZ0ZXIgdGhlIHJvb3QuXG4gICAgICAgIHBhcnRzLnNwbGljZShpICsgMSwgdXApO1xuICAgICAgICB1cCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMik7XG4gICAgICAgIHVwLS07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhdGggPSBwYXJ0cy5qb2luKCcvJyk7XG5cbiAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgcGF0aCA9IGlzQWJzb2x1dGUgPyAnLycgOiAnLic7XG4gIH1cblxuICBpZiAodXJsKSB7XG4gICAgdXJsLnBhdGggPSBwYXRoO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZSh1cmwpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufSk7XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcblxuLyoqXG4gKiBKb2lucyB0d28gcGF0aHMvVVJMcy5cbiAqXG4gKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIGpvaW5lZCB3aXRoIHRoZSByb290LlxuICpcbiAqIC0gSWYgYVBhdGggaXMgYSBVUkwgb3IgYSBkYXRhIFVSSSwgYVBhdGggaXMgcmV0dXJuZWQsIHVubGVzcyBhUGF0aCBpcyBhXG4gKiAgIHNjaGVtZS1yZWxhdGl2ZSBVUkw6IFRoZW4gdGhlIHNjaGVtZSBvZiBhUm9vdCwgaWYgYW55LCBpcyBwcmVwZW5kZWRcbiAqICAgZmlyc3QuXG4gKiAtIE90aGVyd2lzZSBhUGF0aCBpcyBhIHBhdGguIElmIGFSb290IGlzIGEgVVJMLCB0aGVuIGl0cyBwYXRoIHBvcnRpb25cbiAqICAgaXMgdXBkYXRlZCB3aXRoIHRoZSByZXN1bHQgYW5kIGFSb290IGlzIHJldHVybmVkLiBPdGhlcndpc2UgdGhlIHJlc3VsdFxuICogICBpcyByZXR1cm5lZC5cbiAqICAgLSBJZiBhUGF0aCBpcyBhYnNvbHV0ZSwgdGhlIHJlc3VsdCBpcyBhUGF0aC5cbiAqICAgLSBPdGhlcndpc2UgdGhlIHR3byBwYXRocyBhcmUgam9pbmVkIHdpdGggYSBzbGFzaC5cbiAqIC0gSm9pbmluZyBmb3IgZXhhbXBsZSAnaHR0cDovLycgYW5kICd3d3cuZXhhbXBsZS5jb20nIGlzIGFsc28gc3VwcG9ydGVkLlxuICovXG5mdW5jdGlvbiBqb2luKGFSb290LCBhUGF0aCkge1xuICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICBhUm9vdCA9IFwiLlwiO1xuICB9XG4gIGlmIChhUGF0aCA9PT0gXCJcIikge1xuICAgIGFQYXRoID0gXCIuXCI7XG4gIH1cbiAgdmFyIGFQYXRoVXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICB2YXIgYVJvb3RVcmwgPSB1cmxQYXJzZShhUm9vdCk7XG4gIGlmIChhUm9vdFVybCkge1xuICAgIGFSb290ID0gYVJvb3RVcmwucGF0aCB8fCAnLyc7XG4gIH1cblxuICAvLyBgam9pbihmb28sICcvL3d3dy5leGFtcGxlLm9yZycpYFxuICBpZiAoYVBhdGhVcmwgJiYgIWFQYXRoVXJsLnNjaGVtZSkge1xuICAgIGlmIChhUm9vdFVybCkge1xuICAgICAgYVBhdGhVcmwuc2NoZW1lID0gYVJvb3RVcmwuc2NoZW1lO1xuICAgIH1cbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVBhdGhVcmwpO1xuICB9XG5cbiAgaWYgKGFQYXRoVXJsIHx8IGFQYXRoLm1hdGNoKGRhdGFVcmxSZWdleHApKSB7XG4gICAgcmV0dXJuIGFQYXRoO1xuICB9XG5cbiAgLy8gYGpvaW4oJ2h0dHA6Ly8nLCAnd3d3LmV4YW1wbGUuY29tJylgXG4gIGlmIChhUm9vdFVybCAmJiAhYVJvb3RVcmwuaG9zdCAmJiAhYVJvb3RVcmwucGF0aCkge1xuICAgIGFSb290VXJsLmhvc3QgPSBhUGF0aDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICB9XG5cbiAgdmFyIGpvaW5lZCA9IGFQYXRoLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgPyBhUGF0aFxuICAgIDogbm9ybWFsaXplKGFSb290LnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgYVBhdGgpO1xuXG4gIGlmIChhUm9vdFVybCkge1xuICAgIGFSb290VXJsLnBhdGggPSBqb2luZWQ7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgfVxuICByZXR1cm4gam9pbmVkO1xufVxuZXhwb3J0cy5qb2luID0gam9pbjtcblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24gKGFQYXRoKSB7XG4gIHJldHVybiBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJyB8fCB1cmxSZWdleHAudGVzdChhUGF0aCk7XG59O1xuXG4vKipcbiAqIE1ha2UgYSBwYXRoIHJlbGF0aXZlIHRvIGEgVVJMIG9yIGFub3RoZXIgcGF0aC5cbiAqXG4gKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIG1hZGUgcmVsYXRpdmUgdG8gYVJvb3QuXG4gKi9cbmZ1bmN0aW9uIHJlbGF0aXZlKGFSb290LCBhUGF0aCkge1xuICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICBhUm9vdCA9IFwiLlwiO1xuICB9XG5cbiAgYVJvb3QgPSBhUm9vdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuXG4gIC8vIEl0IGlzIHBvc3NpYmxlIGZvciB0aGUgcGF0aCB0byBiZSBhYm92ZSB0aGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBzaW1wbHlcbiAgLy8gY2hlY2tpbmcgd2hldGhlciB0aGUgcm9vdCBpcyBhIHByZWZpeCBvZiB0aGUgcGF0aCB3b24ndCB3b3JrLiBJbnN0ZWFkLCB3ZVxuICAvLyBuZWVkIHRvIHJlbW92ZSBjb21wb25lbnRzIGZyb20gdGhlIHJvb3Qgb25lIGJ5IG9uZSwgdW50aWwgZWl0aGVyIHdlIGZpbmRcbiAgLy8gYSBwcmVmaXggdGhhdCBmaXRzLCBvciB3ZSBydW4gb3V0IG9mIGNvbXBvbmVudHMgdG8gcmVtb3ZlLlxuICB2YXIgbGV2ZWwgPSAwO1xuICB3aGlsZSAoYVBhdGguaW5kZXhPZihhUm9vdCArICcvJykgIT09IDApIHtcbiAgICB2YXIgaW5kZXggPSBhUm9vdC5sYXN0SW5kZXhPZihcIi9cIik7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBvbmx5IHBhcnQgb2YgdGhlIHJvb3QgdGhhdCBpcyBsZWZ0IGlzIHRoZSBzY2hlbWUgKGkuZS4gaHR0cDovLyxcbiAgICAvLyBmaWxlOi8vLywgZXRjLiksIG9uZSBvciBtb3JlIHNsYXNoZXMgKC8pLCBvciBzaW1wbHkgbm90aGluZyBhdCBhbGwsIHdlXG4gICAgLy8gaGF2ZSBleGhhdXN0ZWQgYWxsIGNvbXBvbmVudHMsIHNvIHRoZSBwYXRoIGlzIG5vdCByZWxhdGl2ZSB0byB0aGUgcm9vdC5cbiAgICBhUm9vdCA9IGFSb290LnNsaWNlKDAsIGluZGV4KTtcbiAgICBpZiAoYVJvb3QubWF0Y2goL14oW15cXC9dKzpcXC8pP1xcLyokLykpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICArK2xldmVsO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHdlIGFkZCBhIFwiLi4vXCIgZm9yIGVhY2ggY29tcG9uZW50IHdlIHJlbW92ZWQgZnJvbSB0aGUgcm9vdC5cbiAgcmV0dXJuIEFycmF5KGxldmVsICsgMSkuam9pbihcIi4uL1wiKSArIGFQYXRoLnN1YnN0cihhUm9vdC5sZW5ndGggKyAxKTtcbn1cbmV4cG9ydHMucmVsYXRpdmUgPSByZWxhdGl2ZTtcblxudmFyIHN1cHBvcnRzTnVsbFByb3RvID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAhKCdfX3Byb3RvX18nIGluIG9iaik7XG59KCkpO1xuXG5mdW5jdGlvbiBpZGVudGl0eSAocykge1xuICByZXR1cm4gcztcbn1cblxuLyoqXG4gKiBCZWNhdXNlIGJlaGF2aW9yIGdvZXMgd2Fja3kgd2hlbiB5b3Ugc2V0IGBfX3Byb3RvX19gIG9uIG9iamVjdHMsIHdlXG4gKiBoYXZlIHRvIHByZWZpeCBhbGwgdGhlIHN0cmluZ3MgaW4gb3VyIHNldCB3aXRoIGFuIGFyYml0cmFyeSBjaGFyYWN0ZXIuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvcHVsbC8zMSBhbmRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzMwXG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbmZ1bmN0aW9uIHRvU2V0U3RyaW5nKGFTdHIpIHtcbiAgaWYgKGlzUHJvdG9TdHJpbmcoYVN0cikpIHtcbiAgICByZXR1cm4gJyQnICsgYVN0cjtcbiAgfVxuXG4gIHJldHVybiBhU3RyO1xufVxuZXhwb3J0cy50b1NldFN0cmluZyA9IHN1cHBvcnRzTnVsbFByb3RvID8gaWRlbnRpdHkgOiB0b1NldFN0cmluZztcblxuZnVuY3Rpb24gZnJvbVNldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuIGFTdHIuc2xpY2UoMSk7XG4gIH1cblxuICByZXR1cm4gYVN0cjtcbn1cbmV4cG9ydHMuZnJvbVNldFN0cmluZyA9IHN1cHBvcnRzTnVsbFByb3RvID8gaWRlbnRpdHkgOiBmcm9tU2V0U3RyaW5nO1xuXG5mdW5jdGlvbiBpc1Byb3RvU3RyaW5nKHMpIHtcbiAgaWYgKCFzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IHMubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPCA5IC8qIFwiX19wcm90b19fXCIubGVuZ3RoICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHMuY2hhckNvZGVBdChsZW5ndGggLSAxKSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDIpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMykgIT09IDExMSAvKiAnbycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA0KSAhPT0gMTE2IC8qICd0JyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDUpICE9PSAxMTEgLyogJ28nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNikgIT09IDExNCAvKiAncicgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA3KSAhPT0gMTEyIC8qICdwJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDgpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gOSkgIT09IDk1ICAvKiAnXycgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTA7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKHMuY2hhckNvZGVBdChpKSAhPT0gMzYgLyogJyQnICovKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aGVyZSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqXG4gKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiwgYnV0IGRpZmZlcmVudCBnZW5lcmF0ZWRcbiAqIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhIG1hcHBpbmcgd2l0aCBhXG4gKiBzdHViYmVkIG91dCBtYXBwaW5nLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyhtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgdmFyIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMgPSBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucztcblxuZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnNOb1NvdXJjZShtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgdmFyIGNtcFxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG59XG5leHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zTm9Tb3VyY2UgPSBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9uc05vU291cmNlO1xuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBkZWZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgaW5kaWNlcyB3aGVyZVxuICogdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICpcbiAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiwgYnV0IGRpZmZlcmVudFxuICogc291cmNlL25hbWUvb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGFcbiAqIG1hcHBpbmcgd2l0aCBhIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG59XG5leHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQ7XG5cbmZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkTm9MaW5lKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG59XG5leHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkTm9MaW5lID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWROb0xpbmU7XG5cbmZ1bmN0aW9uIHN0cmNtcChhU3RyMSwgYVN0cjIpIHtcbiAgaWYgKGFTdHIxID09PSBhU3RyMikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGFTdHIxID09PSBudWxsKSB7XG4gICAgcmV0dXJuIDE7IC8vIGFTdHIyICE9PSBudWxsXG4gIH1cblxuICBpZiAoYVN0cjIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gLTE7IC8vIGFTdHIxICE9PSBudWxsXG4gIH1cblxuICBpZiAoYVN0cjEgPiBhU3RyMikge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBpbmZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgc3RyaW5ncyB3aGVyZVxuICogdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG59XG5leHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQ7XG5cbi8qKlxuICogU3RyaXAgYW55IEpTT04gWFNTSSBhdm9pZGFuY2UgcHJlZml4IGZyb20gdGhlIHN0cmluZyAoYXMgZG9jdW1lbnRlZFxuICogaW4gdGhlIHNvdXJjZSBtYXBzIHNwZWNpZmljYXRpb24pLCBhbmQgdGhlbiBwYXJzZSB0aGUgc3RyaW5nIGFzXG4gKiBKU09OLlxuICovXG5mdW5jdGlvbiBwYXJzZVNvdXJjZU1hcElucHV0KHN0cikge1xuICByZXR1cm4gSlNPTi5wYXJzZShzdHIucmVwbGFjZSgvXlxcKV19J1teXFxuXSpcXG4vLCAnJykpO1xufVxuZXhwb3J0cy5wYXJzZVNvdXJjZU1hcElucHV0ID0gcGFyc2VTb3VyY2VNYXBJbnB1dDtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBVUkwgb2YgYSBzb3VyY2UgZ2l2ZW4gdGhlIHRoZSBzb3VyY2Ugcm9vdCwgdGhlIHNvdXJjZSdzXG4gKiBVUkwsIGFuZCB0aGUgc291cmNlIG1hcCdzIFVSTC5cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVNvdXJjZVVSTChzb3VyY2VSb290LCBzb3VyY2VVUkwsIHNvdXJjZU1hcFVSTCkge1xuICBzb3VyY2VVUkwgPSBzb3VyY2VVUkwgfHwgJyc7XG5cbiAgaWYgKHNvdXJjZVJvb3QpIHtcbiAgICAvLyBUaGlzIGZvbGxvd3Mgd2hhdCBDaHJvbWUgZG9lcy5cbiAgICBpZiAoc291cmNlUm9vdFtzb3VyY2VSb290Lmxlbmd0aCAtIDFdICE9PSAnLycgJiYgc291cmNlVVJMWzBdICE9PSAnLycpIHtcbiAgICAgIHNvdXJjZVJvb3QgKz0gJy8nO1xuICAgIH1cbiAgICAvLyBUaGUgc3BlYyBzYXlzOlxuICAgIC8vICAgTGluZSA0OiBBbiBvcHRpb25hbCBzb3VyY2Ugcm9vdCwgdXNlZnVsIGZvciByZWxvY2F0aW5nIHNvdXJjZVxuICAgIC8vICAgZmlsZXMgb24gYSBzZXJ2ZXIgb3IgcmVtb3ZpbmcgcmVwZWF0ZWQgdmFsdWVzIGluIHRoZVxuICAgIC8vICAg4oCcc291cmNlc+KAnSBlbnRyeS4gIFRoaXMgdmFsdWUgaXMgcHJlcGVuZGVkIHRvIHRoZSBpbmRpdmlkdWFsXG4gICAgLy8gICBlbnRyaWVzIGluIHRoZSDigJxzb3VyY2XigJ0gZmllbGQuXG4gICAgc291cmNlVVJMID0gc291cmNlUm9vdCArIHNvdXJjZVVSTDtcbiAgfVxuXG4gIC8vIEhpc3RvcmljYWxseSwgU291cmNlTWFwQ29uc3VtZXIgZGlkIG5vdCB0YWtlIHRoZSBzb3VyY2VNYXBVUkwgYXNcbiAgLy8gYSBwYXJhbWV0ZXIuICBUaGlzIG1vZGUgaXMgc3RpbGwgc29tZXdoYXQgc3VwcG9ydGVkLCB3aGljaCBpcyB3aHlcbiAgLy8gdGhpcyBjb2RlIGJsb2NrIGlzIGNvbmRpdGlvbmFsLiAgSG93ZXZlciwgaXQncyBwcmVmZXJhYmxlIHRvIHBhc3NcbiAgLy8gdGhlIHNvdXJjZSBtYXAgVVJMIHRvIFNvdXJjZU1hcENvbnN1bWVyLCBzbyB0aGF0IHRoaXMgZnVuY3Rpb25cbiAgLy8gY2FuIGltcGxlbWVudCB0aGUgc291cmNlIFVSTCByZXNvbHV0aW9uIGFsZ29yaXRobSBhcyBvdXRsaW5lZCBpblxuICAvLyB0aGUgc3BlYy4gIFRoaXMgYmxvY2sgaXMgYmFzaWNhbGx5IHRoZSBlcXVpdmFsZW50IG9mOlxuICAvLyAgICBuZXcgVVJMKHNvdXJjZVVSTCwgc291cmNlTWFwVVJMKS50b1N0cmluZygpXG4gIC8vIC4uLiBleGNlcHQgaXQgYXZvaWRzIHVzaW5nIFVSTCwgd2hpY2ggd2Fzbid0IGF2YWlsYWJsZSBpbiB0aGVcbiAgLy8gb2xkZXIgcmVsZWFzZXMgb2Ygbm9kZSBzdGlsbCBzdXBwb3J0ZWQgYnkgdGhpcyBsaWJyYXJ5LlxuICAvL1xuICAvLyBUaGUgc3BlYyBzYXlzOlxuICAvLyAgIElmIHRoZSBzb3VyY2VzIGFyZSBub3QgYWJzb2x1dGUgVVJMcyBhZnRlciBwcmVwZW5kaW5nIG9mIHRoZVxuICAvLyAgIOKAnHNvdXJjZVJvb3TigJ0sIHRoZSBzb3VyY2VzIGFyZSByZXNvbHZlZCByZWxhdGl2ZSB0byB0aGVcbiAgLy8gICBTb3VyY2VNYXAgKGxpa2UgcmVzb2x2aW5nIHNjcmlwdCBzcmMgaW4gYSBodG1sIGRvY3VtZW50KS5cbiAgaWYgKHNvdXJjZU1hcFVSTCkge1xuICAgIHZhciBwYXJzZWQgPSB1cmxQYXJzZShzb3VyY2VNYXBVUkwpO1xuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2VNYXBVUkwgY291bGQgbm90IGJlIHBhcnNlZFwiKTtcbiAgICB9XG4gICAgaWYgKHBhcnNlZC5wYXRoKSB7XG4gICAgICAvLyBTdHJpcCB0aGUgbGFzdCBwYXRoIGNvbXBvbmVudCwgYnV0IGtlZXAgdGhlIFwiL1wiLlxuICAgICAgdmFyIGluZGV4ID0gcGFyc2VkLnBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHBhcnNlZC5wYXRoID0gcGFyc2VkLnBhdGguc3Vic3RyaW5nKDAsIGluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZVVSTCA9IGpvaW4odXJsR2VuZXJhdGUocGFyc2VkKSwgc291cmNlVVJMKTtcbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemUoc291cmNlVVJMKTtcbn1cbmV4cG9ydHMuY29tcHV0ZVNvdXJjZVVSTCA9IGNvbXB1dGVTb3VyY2VVUkw7XG4iXSwibmFtZXMiOlsiZ2V0QXJnIiwiYUFyZ3MiLCJhTmFtZSIsImFEZWZhdWx0VmFsdWUiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJFcnJvciIsImV4cG9ydHMiLCJ1cmxSZWdleHAiLCJkYXRhVXJsUmVnZXhwIiwidXJsUGFyc2UiLCJhVXJsIiwibWF0Y2giLCJzY2hlbWUiLCJhdXRoIiwiaG9zdCIsInBvcnQiLCJwYXRoIiwidXJsR2VuZXJhdGUiLCJhUGFyc2VkVXJsIiwidXJsIiwiTUFYX0NBQ0hFRF9JTlBVVFMiLCJscnVNZW1vaXplIiwiZiIsImNhY2hlIiwiaW5wdXQiLCJpIiwidGVtcCIsInJlc3VsdCIsInVuc2hpZnQiLCJwb3AiLCJub3JtYWxpemUiLCJhUGF0aCIsImlzQWJzb2x1dGUiLCJwYXJ0cyIsInN0YXJ0IiwiaW5kZXhPZiIsInB1c2giLCJzbGljZSIsInBhcnQiLCJ1cCIsInNwbGljZSIsImpvaW4iLCJhUm9vdCIsImFQYXRoVXJsIiwiYVJvb3RVcmwiLCJqb2luZWQiLCJjaGFyQXQiLCJyZXBsYWNlIiwidGVzdCIsInJlbGF0aXZlIiwibGV2ZWwiLCJpbmRleCIsImxhc3RJbmRleE9mIiwiQXJyYXkiLCJzdWJzdHIiLCJzdXBwb3J0c051bGxQcm90byIsIm9iaiIsIk9iamVjdCIsImNyZWF0ZSIsImlkZW50aXR5IiwicyIsInRvU2V0U3RyaW5nIiwiYVN0ciIsImlzUHJvdG9TdHJpbmciLCJmcm9tU2V0U3RyaW5nIiwiY2hhckNvZGVBdCIsImNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zIiwibWFwcGluZ0EiLCJtYXBwaW5nQiIsIm9ubHlDb21wYXJlT3JpZ2luYWwiLCJjbXAiLCJzdHJjbXAiLCJzb3VyY2UiLCJvcmlnaW5hbExpbmUiLCJvcmlnaW5hbENvbHVtbiIsImdlbmVyYXRlZENvbHVtbiIsImdlbmVyYXRlZExpbmUiLCJuYW1lIiwiY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnNOb1NvdXJjZSIsImNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkIiwib25seUNvbXBhcmVHZW5lcmF0ZWQiLCJjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZE5vTGluZSIsImFTdHIxIiwiYVN0cjIiLCJjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCIsInBhcnNlU291cmNlTWFwSW5wdXQiLCJzdHIiLCJKU09OIiwicGFyc2UiLCJjb21wdXRlU291cmNlVVJMIiwic291cmNlUm9vdCIsInNvdXJjZVVSTCIsInNvdXJjZU1hcFVSTCIsInBhcnNlZCIsInN1YnN0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/../source-map-js/lib/util.js\n");

/***/ }),

/***/ "(rsc)/../source-map-js/lib/util.js":
/*!************************************!*\
  !*** ../source-map-js/lib/util.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ /**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */ function getArg(aArgs, aName, aDefaultValue) {\n    if (aName in aArgs) {\n        return aArgs[aName];\n    } else if (arguments.length === 3) {\n        return aDefaultValue;\n    } else {\n        throw new Error('\"' + aName + '\" is a required argument.');\n    }\n}\nexports.getArg = getArg;\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\nfunction urlParse(aUrl) {\n    var match = aUrl.match(urlRegexp);\n    if (!match) {\n        return null;\n    }\n    return {\n        scheme: match[1],\n        auth: match[2],\n        host: match[3],\n        port: match[4],\n        path: match[5]\n    };\n}\nexports.urlParse = urlParse;\nfunction urlGenerate(aParsedUrl) {\n    var url = \"\";\n    if (aParsedUrl.scheme) {\n        url += aParsedUrl.scheme + \":\";\n    }\n    url += \"//\";\n    if (aParsedUrl.auth) {\n        url += aParsedUrl.auth + \"@\";\n    }\n    if (aParsedUrl.host) {\n        url += aParsedUrl.host;\n    }\n    if (aParsedUrl.port) {\n        url += \":\" + aParsedUrl.port;\n    }\n    if (aParsedUrl.path) {\n        url += aParsedUrl.path;\n    }\n    return url;\n}\nexports.urlGenerate = urlGenerate;\nvar MAX_CACHED_INPUTS = 32;\n/**\n * Takes some function `f(input) -> result` and returns a memoized version of\n * `f`.\n *\n * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The\n * memoization is a dumb-simple, linear least-recently-used cache.\n */ function lruMemoize(f) {\n    var cache = [];\n    return function(input) {\n        for(var i = 0; i < cache.length; i++){\n            if (cache[i].input === input) {\n                var temp = cache[0];\n                cache[0] = cache[i];\n                cache[i] = temp;\n                return cache[0].result;\n            }\n        }\n        var result = f(input);\n        cache.unshift({\n            input,\n            result\n        });\n        if (cache.length > MAX_CACHED_INPUTS) {\n            cache.pop();\n        }\n        return result;\n    };\n}\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */ var normalize = lruMemoize(function normalize(aPath) {\n    var path = aPath;\n    var url = urlParse(aPath);\n    if (url) {\n        if (!url.path) {\n            return aPath;\n        }\n        path = url.path;\n    }\n    var isAbsolute = exports.isAbsolute(path);\n    // Split the path into parts between `/` characters. This is much faster than\n    // using `.split(/\\/+/g)`.\n    var parts = [];\n    var start = 0;\n    var i = 0;\n    while(true){\n        start = i;\n        i = path.indexOf(\"/\", start);\n        if (i === -1) {\n            parts.push(path.slice(start));\n            break;\n        } else {\n            parts.push(path.slice(start, i));\n            while(i < path.length && path[i] === \"/\"){\n                i++;\n            }\n        }\n    }\n    for(var part, up = 0, i = parts.length - 1; i >= 0; i--){\n        part = parts[i];\n        if (part === \".\") {\n            parts.splice(i, 1);\n        } else if (part === \"..\") {\n            up++;\n        } else if (up > 0) {\n            if (part === \"\") {\n                // The first part is blank if the path is absolute. Trying to go\n                // above the root is a no-op. Therefore we can remove all '..' parts\n                // directly after the root.\n                parts.splice(i + 1, up);\n                up = 0;\n            } else {\n                parts.splice(i, 2);\n                up--;\n            }\n        }\n    }\n    path = parts.join(\"/\");\n    if (path === \"\") {\n        path = isAbsolute ? \"/\" : \".\";\n    }\n    if (url) {\n        url.path = path;\n        return urlGenerate(url);\n    }\n    return path;\n});\nexports.normalize = normalize;\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */ function join(aRoot, aPath) {\n    if (aRoot === \"\") {\n        aRoot = \".\";\n    }\n    if (aPath === \"\") {\n        aPath = \".\";\n    }\n    var aPathUrl = urlParse(aPath);\n    var aRootUrl = urlParse(aRoot);\n    if (aRootUrl) {\n        aRoot = aRootUrl.path || \"/\";\n    }\n    // `join(foo, '//www.example.org')`\n    if (aPathUrl && !aPathUrl.scheme) {\n        if (aRootUrl) {\n            aPathUrl.scheme = aRootUrl.scheme;\n        }\n        return urlGenerate(aPathUrl);\n    }\n    if (aPathUrl || aPath.match(dataUrlRegexp)) {\n        return aPath;\n    }\n    // `join('http://', 'www.example.com')`\n    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n        aRootUrl.host = aPath;\n        return urlGenerate(aRootUrl);\n    }\n    var joined = aPath.charAt(0) === \"/\" ? aPath : normalize(aRoot.replace(/\\/+$/, \"\") + \"/\" + aPath);\n    if (aRootUrl) {\n        aRootUrl.path = joined;\n        return urlGenerate(aRootUrl);\n    }\n    return joined;\n}\nexports.join = join;\nexports.isAbsolute = function(aPath) {\n    return aPath.charAt(0) === \"/\" || urlRegexp.test(aPath);\n};\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */ function relative(aRoot, aPath) {\n    if (aRoot === \"\") {\n        aRoot = \".\";\n    }\n    aRoot = aRoot.replace(/\\/$/, \"\");\n    // It is possible for the path to be above the root. In this case, simply\n    // checking whether the root is a prefix of the path won't work. Instead, we\n    // need to remove components from the root one by one, until either we find\n    // a prefix that fits, or we run out of components to remove.\n    var level = 0;\n    while(aPath.indexOf(aRoot + \"/\") !== 0){\n        var index = aRoot.lastIndexOf(\"/\");\n        if (index < 0) {\n            return aPath;\n        }\n        // If the only part of the root that is left is the scheme (i.e. http://,\n        // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n        // have exhausted all components, so the path is not relative to the root.\n        aRoot = aRoot.slice(0, index);\n        if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n            return aPath;\n        }\n        ++level;\n    }\n    // Make sure we add a \"../\" for each component we removed from the root.\n    return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\nvar supportsNullProto = function() {\n    var obj = Object.create(null);\n    return !(\"__proto__\" in obj);\n}();\nfunction identity(s) {\n    return s;\n}\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */ function toSetString(aStr) {\n    if (isProtoString(aStr)) {\n        return \"$\" + aStr;\n    }\n    return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\nfunction fromSetString(aStr) {\n    if (isProtoString(aStr)) {\n        return aStr.slice(1);\n    }\n    return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\nfunction isProtoString(s) {\n    if (!s) {\n        return false;\n    }\n    var length = s.length;\n    if (length < 9 /* \"__proto__\".length */ ) {\n        return false;\n    }\n    if (s.charCodeAt(length - 1) !== 95 /* '_' */  || s.charCodeAt(length - 2) !== 95 /* '_' */  || s.charCodeAt(length - 3) !== 111 /* 'o' */  || s.charCodeAt(length - 4) !== 116 /* 't' */  || s.charCodeAt(length - 5) !== 111 /* 'o' */  || s.charCodeAt(length - 6) !== 114 /* 'r' */  || s.charCodeAt(length - 7) !== 112 /* 'p' */  || s.charCodeAt(length - 8) !== 95 /* '_' */  || s.charCodeAt(length - 9) !== 95 /* '_' */ ) {\n        return false;\n    }\n    for(var i = length - 10; i >= 0; i--){\n        if (s.charCodeAt(i) !== 36 /* '$' */ ) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */ function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n    var cmp = strcmp(mappingA.source, mappingB.source);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp !== 0 || onlyCompareOriginal) {\n        return cmp;\n    }\n    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\nfunction compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {\n    var cmp;\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp !== 0 || onlyCompareOriginal) {\n        return cmp;\n    }\n    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */ function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n    var cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp !== 0 || onlyCompareGenerated) {\n        return cmp;\n    }\n    cmp = strcmp(mappingA.source, mappingB.source);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\nfunction compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {\n    var cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp !== 0 || onlyCompareGenerated) {\n        return cmp;\n    }\n    cmp = strcmp(mappingA.source, mappingB.source);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;\nfunction strcmp(aStr1, aStr2) {\n    if (aStr1 === aStr2) {\n        return 0;\n    }\n    if (aStr1 === null) {\n        return 1; // aStr2 !== null\n    }\n    if (aStr2 === null) {\n        return -1; // aStr1 !== null\n    }\n    if (aStr1 > aStr2) {\n        return 1;\n    }\n    return -1;\n}\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */ function compareByGeneratedPositionsInflated(mappingA, mappingB) {\n    var cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = strcmp(mappingA.source, mappingB.source);\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp !== 0) {\n        return cmp;\n    }\n    return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */ function parseSourceMapInput(str) {\n    return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, \"\"));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */ function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n    sourceURL = sourceURL || \"\";\n    if (sourceRoot) {\n        // This follows what Chrome does.\n        if (sourceRoot[sourceRoot.length - 1] !== \"/\" && sourceURL[0] !== \"/\") {\n            sourceRoot += \"/\";\n        }\n        // The spec says:\n        //   Line 4: An optional source root, useful for relocating source\n        //   files on a server or removing repeated values in the\n        //   “sources” entry.  This value is prepended to the individual\n        //   entries in the “source” field.\n        sourceURL = sourceRoot + sourceURL;\n    }\n    // Historically, SourceMapConsumer did not take the sourceMapURL as\n    // a parameter.  This mode is still somewhat supported, which is why\n    // this code block is conditional.  However, it's preferable to pass\n    // the source map URL to SourceMapConsumer, so that this function\n    // can implement the source URL resolution algorithm as outlined in\n    // the spec.  This block is basically the equivalent of:\n    //    new URL(sourceURL, sourceMapURL).toString()\n    // ... except it avoids using URL, which wasn't available in the\n    // older releases of node still supported by this library.\n    //\n    // The spec says:\n    //   If the sources are not absolute URLs after prepending of the\n    //   “sourceRoot”, the sources are resolved relative to the\n    //   SourceMap (like resolving script src in a html document).\n    if (sourceMapURL) {\n        var parsed = urlParse(sourceMapURL);\n        if (!parsed) {\n            throw new Error(\"sourceMapURL could not be parsed\");\n        }\n        if (parsed.path) {\n            // Strip the last path component, but keep the \"/\".\n            var index = parsed.path.lastIndexOf(\"/\");\n            if (index >= 0) {\n                parsed.path = parsed.path.substring(0, index + 1);\n            }\n        }\n        sourceURL = join(urlGenerate(parsed), sourceURL);\n    }\n    return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LWpzL2xpYi91dGlsLmpzP2Y5NzYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG4vKipcbiAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldHRpbmcgdmFsdWVzIGZyb20gcGFyYW1ldGVyL29wdGlvbnNcbiAqIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIGFyZ3MgVGhlIG9iamVjdCB3ZSBhcmUgZXh0cmFjdGluZyB2YWx1ZXMgZnJvbVxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdlIGFyZSBnZXR0aW5nLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBbiBvcHRpb25hbCB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmdcbiAqIGZyb20gdGhlIG9iamVjdC4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkIGFuZCB0aGUgcHJvcGVydHkgaXMgbWlzc2luZywgYW5cbiAqIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICovXG5mdW5jdGlvbiBnZXRBcmcoYUFyZ3MsIGFOYW1lLCBhRGVmYXVsdFZhbHVlKSB7XG4gIGlmIChhTmFtZSBpbiBhQXJncykge1xuICAgIHJldHVybiBhQXJnc1thTmFtZV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHJldHVybiBhRGVmYXVsdFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYU5hbWUgKyAnXCIgaXMgYSByZXF1aXJlZCBhcmd1bWVudC4nKTtcbiAgfVxufVxuZXhwb3J0cy5nZXRBcmcgPSBnZXRBcmc7XG5cbnZhciB1cmxSZWdleHAgPSAvXig/OihbXFx3K1xcLS5dKyk6KT9cXC9cXC8oPzooXFx3KzpcXHcrKUApPyhbXFx3Li1dKikoPzo6KFxcZCspKT8oLiopJC87XG52YXIgZGF0YVVybFJlZ2V4cCA9IC9eZGF0YTouK1xcLC4rJC87XG5cbmZ1bmN0aW9uIHVybFBhcnNlKGFVcmwpIHtcbiAgdmFyIG1hdGNoID0gYVVybC5tYXRjaCh1cmxSZWdleHApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY2hlbWU6IG1hdGNoWzFdLFxuICAgIGF1dGg6IG1hdGNoWzJdLFxuICAgIGhvc3Q6IG1hdGNoWzNdLFxuICAgIHBvcnQ6IG1hdGNoWzRdLFxuICAgIHBhdGg6IG1hdGNoWzVdXG4gIH07XG59XG5leHBvcnRzLnVybFBhcnNlID0gdXJsUGFyc2U7XG5cbmZ1bmN0aW9uIHVybEdlbmVyYXRlKGFQYXJzZWRVcmwpIHtcbiAgdmFyIHVybCA9ICcnO1xuICBpZiAoYVBhcnNlZFVybC5zY2hlbWUpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5zY2hlbWUgKyAnOic7XG4gIH1cbiAgdXJsICs9ICcvLyc7XG4gIGlmIChhUGFyc2VkVXJsLmF1dGgpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5hdXRoICsgJ0AnO1xuICB9XG4gIGlmIChhUGFyc2VkVXJsLmhvc3QpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5ob3N0O1xuICB9XG4gIGlmIChhUGFyc2VkVXJsLnBvcnQpIHtcbiAgICB1cmwgKz0gXCI6XCIgKyBhUGFyc2VkVXJsLnBvcnRcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5wYXRoKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwucGF0aDtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuZXhwb3J0cy51cmxHZW5lcmF0ZSA9IHVybEdlbmVyYXRlO1xuXG52YXIgTUFYX0NBQ0hFRF9JTlBVVFMgPSAzMjtcblxuLyoqXG4gKiBUYWtlcyBzb21lIGZ1bmN0aW9uIGBmKGlucHV0KSAtPiByZXN1bHRgIGFuZCByZXR1cm5zIGEgbWVtb2l6ZWQgdmVyc2lvbiBvZlxuICogYGZgLlxuICpcbiAqIFdlIGtlZXAgYXQgbW9zdCBgTUFYX0NBQ0hFRF9JTlBVVFNgIG1lbW9pemVkIHJlc3VsdHMgb2YgYGZgIGFsaXZlLiBUaGVcbiAqIG1lbW9pemF0aW9uIGlzIGEgZHVtYi1zaW1wbGUsIGxpbmVhciBsZWFzdC1yZWNlbnRseS11c2VkIGNhY2hlLlxuICovXG5mdW5jdGlvbiBscnVNZW1vaXplKGYpIHtcbiAgdmFyIGNhY2hlID0gW107XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGNhY2hlW2ldLmlucHV0ID09PSBpbnB1dCkge1xuICAgICAgICB2YXIgdGVtcCA9IGNhY2hlWzBdO1xuICAgICAgICBjYWNoZVswXSA9IGNhY2hlW2ldO1xuICAgICAgICBjYWNoZVtpXSA9IHRlbXA7XG4gICAgICAgIHJldHVybiBjYWNoZVswXS5yZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IGYoaW5wdXQpO1xuXG4gICAgY2FjaGUudW5zaGlmdCh7XG4gICAgICBpbnB1dCxcbiAgICAgIHJlc3VsdCxcbiAgICB9KTtcblxuICAgIGlmIChjYWNoZS5sZW5ndGggPiBNQVhfQ0FDSEVEX0lOUFVUUykge1xuICAgICAgY2FjaGUucG9wKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIGEgcGF0aCwgb3IgdGhlIHBhdGggcG9ydGlvbiBvZiBhIFVSTDpcbiAqXG4gKiAtIFJlcGxhY2VzIGNvbnNlY3V0aXZlIHNsYXNoZXMgd2l0aCBvbmUgc2xhc2guXG4gKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJy4nIHBhcnRzLlxuICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICc8ZGlyPi8uLicgcGFydHMuXG4gKlxuICogQmFzZWQgb24gY29kZSBpbiB0aGUgTm9kZS5qcyAncGF0aCcgY29yZSBtb2R1bGUuXG4gKlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIHVybCB0byBub3JtYWxpemUuXG4gKi9cbnZhciBub3JtYWxpemUgPSBscnVNZW1vaXplKGZ1bmN0aW9uIG5vcm1hbGl6ZShhUGF0aCkge1xuICB2YXIgcGF0aCA9IGFQYXRoO1xuICB2YXIgdXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICBpZiAodXJsKSB7XG4gICAgaWYgKCF1cmwucGF0aCkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cbiAgICBwYXRoID0gdXJsLnBhdGg7XG4gIH1cbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCk7XG4gIC8vIFNwbGl0IHRoZSBwYXRoIGludG8gcGFydHMgYmV0d2VlbiBgL2AgY2hhcmFjdGVycy4gVGhpcyBpcyBtdWNoIGZhc3RlciB0aGFuXG4gIC8vIHVzaW5nIGAuc3BsaXQoL1xcLysvZylgLlxuICB2YXIgcGFydHMgPSBbXTtcbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN0YXJ0ID0gaTtcbiAgICBpID0gcGF0aC5pbmRleE9mKFwiL1wiLCBzdGFydCk7XG4gICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICBwYXJ0cy5wdXNoKHBhdGguc2xpY2Uoc3RhcnQpKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0cy5wdXNoKHBhdGguc2xpY2Uoc3RhcnQsIGkpKTtcbiAgICAgIHdoaWxlIChpIDwgcGF0aC5sZW5ndGggJiYgcGF0aFtpXSA9PT0gXCIvXCIpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIHBhcnQsIHVwID0gMCwgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgcGFydCA9IHBhcnRzW2ldO1xuICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCA+IDApIHtcbiAgICAgIGlmIChwYXJ0ID09PSAnJykge1xuICAgICAgICAvLyBUaGUgZmlyc3QgcGFydCBpcyBibGFuayBpZiB0aGUgcGF0aCBpcyBhYnNvbHV0ZS4gVHJ5aW5nIHRvIGdvXG4gICAgICAgIC8vIGFib3ZlIHRoZSByb290IGlzIGEgbm8tb3AuIFRoZXJlZm9yZSB3ZSBjYW4gcmVtb3ZlIGFsbCAnLi4nIHBhcnRzXG4gICAgICAgIC8vIGRpcmVjdGx5IGFmdGVyIHRoZSByb290LlxuICAgICAgICBwYXJ0cy5zcGxpY2UoaSArIDEsIHVwKTtcbiAgICAgICAgdXAgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMuc3BsaWNlKGksIDIpO1xuICAgICAgICB1cC0tO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXRoID0gcGFydHMuam9pbignLycpO1xuXG4gIGlmIChwYXRoID09PSAnJykge1xuICAgIHBhdGggPSBpc0Fic29sdXRlID8gJy8nIDogJy4nO1xuICB9XG5cbiAgaWYgKHVybCkge1xuICAgIHVybC5wYXRoID0gcGF0aDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUodXJsKTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn0pO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5cbi8qKlxuICogSm9pbnMgdHdvIHBhdGhzL1VSTHMuXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBqb2luZWQgd2l0aCB0aGUgcm9vdC5cbiAqXG4gKiAtIElmIGFQYXRoIGlzIGEgVVJMIG9yIGEgZGF0YSBVUkksIGFQYXRoIGlzIHJldHVybmVkLCB1bmxlc3MgYVBhdGggaXMgYVxuICogICBzY2hlbWUtcmVsYXRpdmUgVVJMOiBUaGVuIHRoZSBzY2hlbWUgb2YgYVJvb3QsIGlmIGFueSwgaXMgcHJlcGVuZGVkXG4gKiAgIGZpcnN0LlxuICogLSBPdGhlcndpc2UgYVBhdGggaXMgYSBwYXRoLiBJZiBhUm9vdCBpcyBhIFVSTCwgdGhlbiBpdHMgcGF0aCBwb3J0aW9uXG4gKiAgIGlzIHVwZGF0ZWQgd2l0aCB0aGUgcmVzdWx0IGFuZCBhUm9vdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoZSByZXN1bHRcbiAqICAgaXMgcmV0dXJuZWQuXG4gKiAgIC0gSWYgYVBhdGggaXMgYWJzb2x1dGUsIHRoZSByZXN1bHQgaXMgYVBhdGguXG4gKiAgIC0gT3RoZXJ3aXNlIHRoZSB0d28gcGF0aHMgYXJlIGpvaW5lZCB3aXRoIGEgc2xhc2guXG4gKiAtIEpvaW5pbmcgZm9yIGV4YW1wbGUgJ2h0dHA6Ly8nIGFuZCAnd3d3LmV4YW1wbGUuY29tJyBpcyBhbHNvIHN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gam9pbihhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuICBpZiAoYVBhdGggPT09IFwiXCIpIHtcbiAgICBhUGF0aCA9IFwiLlwiO1xuICB9XG4gIHZhciBhUGF0aFVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgdmFyIGFSb290VXJsID0gdXJsUGFyc2UoYVJvb3QpO1xuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdCA9IGFSb290VXJsLnBhdGggfHwgJy8nO1xuICB9XG5cbiAgLy8gYGpvaW4oZm9vLCAnLy93d3cuZXhhbXBsZS5vcmcnKWBcbiAgaWYgKGFQYXRoVXJsICYmICFhUGF0aFVybC5zY2hlbWUpIHtcbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFQYXRoVXJsLnNjaGVtZSA9IGFSb290VXJsLnNjaGVtZTtcbiAgICB9XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFQYXRoVXJsKTtcbiAgfVxuXG4gIGlmIChhUGF0aFVybCB8fCBhUGF0aC5tYXRjaChkYXRhVXJsUmVnZXhwKSkge1xuICAgIHJldHVybiBhUGF0aDtcbiAgfVxuXG4gIC8vIGBqb2luKCdodHRwOi8vJywgJ3d3dy5leGFtcGxlLmNvbScpYFxuICBpZiAoYVJvb3RVcmwgJiYgIWFSb290VXJsLmhvc3QgJiYgIWFSb290VXJsLnBhdGgpIHtcbiAgICBhUm9vdFVybC5ob3N0ID0gYVBhdGg7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgfVxuXG4gIHZhciBqb2luZWQgPSBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJ1xuICAgID8gYVBhdGhcbiAgICA6IG5vcm1hbGl6ZShhUm9vdC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIGFQYXRoKTtcblxuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdFVybC5wYXRoID0gam9pbmVkO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gIH1cbiAgcmV0dXJuIGpvaW5lZDtcbn1cbmV4cG9ydHMuam9pbiA9IGpvaW47XG5cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uIChhUGF0aCkge1xuICByZXR1cm4gYVBhdGguY2hhckF0KDApID09PSAnLycgfHwgdXJsUmVnZXhwLnRlc3QoYVBhdGgpO1xufTtcblxuLyoqXG4gKiBNYWtlIGEgcGF0aCByZWxhdGl2ZSB0byBhIFVSTCBvciBhbm90aGVyIHBhdGguXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBtYWRlIHJlbGF0aXZlIHRvIGFSb290LlxuICovXG5mdW5jdGlvbiByZWxhdGl2ZShhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuXG4gIGFSb290ID0gYVJvb3QucmVwbGFjZSgvXFwvJC8sICcnKTtcblxuICAvLyBJdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHBhdGggdG8gYmUgYWJvdmUgdGhlIHJvb3QuIEluIHRoaXMgY2FzZSwgc2ltcGx5XG4gIC8vIGNoZWNraW5nIHdoZXRoZXIgdGhlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlIHBhdGggd29uJ3Qgd29yay4gSW5zdGVhZCwgd2VcbiAgLy8gbmVlZCB0byByZW1vdmUgY29tcG9uZW50cyBmcm9tIHRoZSByb290IG9uZSBieSBvbmUsIHVudGlsIGVpdGhlciB3ZSBmaW5kXG4gIC8vIGEgcHJlZml4IHRoYXQgZml0cywgb3Igd2UgcnVuIG91dCBvZiBjb21wb25lbnRzIHRvIHJlbW92ZS5cbiAgdmFyIGxldmVsID0gMDtcbiAgd2hpbGUgKGFQYXRoLmluZGV4T2YoYVJvb3QgKyAnLycpICE9PSAwKSB7XG4gICAgdmFyIGluZGV4ID0gYVJvb3QubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgb25seSBwYXJ0IG9mIHRoZSByb290IHRoYXQgaXMgbGVmdCBpcyB0aGUgc2NoZW1lIChpLmUuIGh0dHA6Ly8sXG4gICAgLy8gZmlsZTovLy8sIGV0Yy4pLCBvbmUgb3IgbW9yZSBzbGFzaGVzICgvKSwgb3Igc2ltcGx5IG5vdGhpbmcgYXQgYWxsLCB3ZVxuICAgIC8vIGhhdmUgZXhoYXVzdGVkIGFsbCBjb21wb25lbnRzLCBzbyB0aGUgcGF0aCBpcyBub3QgcmVsYXRpdmUgdG8gdGhlIHJvb3QuXG4gICAgYVJvb3QgPSBhUm9vdC5zbGljZSgwLCBpbmRleCk7XG4gICAgaWYgKGFSb290Lm1hdGNoKC9eKFteXFwvXSs6XFwvKT9cXC8qJC8pKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgKytsZXZlbDtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB3ZSBhZGQgYSBcIi4uL1wiIGZvciBlYWNoIGNvbXBvbmVudCB3ZSByZW1vdmVkIGZyb20gdGhlIHJvb3QuXG4gIHJldHVybiBBcnJheShsZXZlbCArIDEpLmpvaW4oXCIuLi9cIikgKyBhUGF0aC5zdWJzdHIoYVJvb3QubGVuZ3RoICsgMSk7XG59XG5leHBvcnRzLnJlbGF0aXZlID0gcmVsYXRpdmU7XG5cbnZhciBzdXBwb3J0c051bGxQcm90byA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gISgnX19wcm90b19fJyBpbiBvYmopO1xufSgpKTtcblxuZnVuY3Rpb24gaWRlbnRpdHkgKHMpIHtcbiAgcmV0dXJuIHM7XG59XG5cbi8qKlxuICogQmVjYXVzZSBiZWhhdmlvciBnb2VzIHdhY2t5IHdoZW4geW91IHNldCBgX19wcm90b19fYCBvbiBvYmplY3RzLCB3ZVxuICogaGF2ZSB0byBwcmVmaXggYWxsIHRoZSBzdHJpbmdzIGluIG91ciBzZXQgd2l0aCBhbiBhcmJpdHJhcnkgY2hhcmFjdGVyLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL3B1bGwvMzEgYW5kXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8zMFxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5mdW5jdGlvbiB0b1NldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuICckJyArIGFTdHI7XG4gIH1cblxuICByZXR1cm4gYVN0cjtcbn1cbmV4cG9ydHMudG9TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogdG9TZXRTdHJpbmc7XG5cbmZ1bmN0aW9uIGZyb21TZXRTdHJpbmcoYVN0cikge1xuICBpZiAoaXNQcm90b1N0cmluZyhhU3RyKSkge1xuICAgIHJldHVybiBhU3RyLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuIGFTdHI7XG59XG5leHBvcnRzLmZyb21TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogZnJvbVNldFN0cmluZztcblxuZnVuY3Rpb24gaXNQcm90b1N0cmluZyhzKSB7XG4gIGlmICghcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBzLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDwgOSAvKiBcIl9fcHJvdG9fX1wiLmxlbmd0aCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMSkgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSAyKSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDMpICE9PSAxMTEgLyogJ28nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNCkgIT09IDExNiAvKiAndCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA1KSAhPT0gMTExIC8qICdvJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDYpICE9PSAxMTQgLyogJ3InICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNykgIT09IDExMiAvKiAncCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA4KSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDkpICE9PSA5NSAgLyogJ18nICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDEwOyBpID49IDA7IGktLSkge1xuICAgIGlmIChzLmNoYXJDb2RlQXQoaSkgIT09IDM2IC8qICckJyAqLykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2hlcmUgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4sIGJ1dCBkaWZmZXJlbnQgZ2VuZXJhdGVkXG4gKiBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYSBtYXBwaW5nIHdpdGggYVxuICogc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gIHZhciBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG59XG5leHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM7XG5cbmZ1bmN0aW9uIGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zTm9Tb3VyY2UobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gIHZhciBjbXBcblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9uc05vU291cmNlID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnNOb1NvdXJjZTtcblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdpdGggZGVmbGF0ZWQgc291cmNlIGFuZCBuYW1lIGluZGljZXMgd2hlcmVcbiAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqXG4gKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4sIGJ1dCBkaWZmZXJlbnRcbiAqIHNvdXJjZS9uYW1lL29yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhXG4gKiBtYXBwaW5nIHdpdGggYSBzdHViYmVkIG91dCBtYXBwaW5nLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gc3RyY21wKG1hcHBpbmdBLnNvdXJjZSwgbWFwcGluZ0Iuc291cmNlKTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkO1xuXG5mdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZE5vTGluZShtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gc3RyY21wKG1hcHBpbmdBLnNvdXJjZSwgbWFwcGluZ0Iuc291cmNlKTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZE5vTGluZSA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkTm9MaW5lO1xuXG5mdW5jdGlvbiBzdHJjbXAoYVN0cjEsIGFTdHIyKSB7XG4gIGlmIChhU3RyMSA9PT0gYVN0cjIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChhU3RyMSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAxOyAvLyBhU3RyMiAhPT0gbnVsbFxuICB9XG5cbiAgaWYgKGFTdHIyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIC0xOyAvLyBhU3RyMSAhPT0gbnVsbFxuICB9XG5cbiAgaWYgKGFTdHIxID4gYVN0cjIpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdpdGggaW5mbGF0ZWQgc291cmNlIGFuZCBuYW1lIHN0cmluZ3Mgd2hlcmVcbiAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gc3RyY21wKG1hcHBpbmdBLnNvdXJjZSwgbWFwcGluZ0Iuc291cmNlKTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkO1xuXG4vKipcbiAqIFN0cmlwIGFueSBKU09OIFhTU0kgYXZvaWRhbmNlIHByZWZpeCBmcm9tIHRoZSBzdHJpbmcgKGFzIGRvY3VtZW50ZWRcbiAqIGluIHRoZSBzb3VyY2UgbWFwcyBzcGVjaWZpY2F0aW9uKSwgYW5kIHRoZW4gcGFyc2UgdGhlIHN0cmluZyBhc1xuICogSlNPTi5cbiAqL1xuZnVuY3Rpb24gcGFyc2VTb3VyY2VNYXBJbnB1dChzdHIpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyLnJlcGxhY2UoL15cXCldfSdbXlxcbl0qXFxuLywgJycpKTtcbn1cbmV4cG9ydHMucGFyc2VTb3VyY2VNYXBJbnB1dCA9IHBhcnNlU291cmNlTWFwSW5wdXQ7XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgVVJMIG9mIGEgc291cmNlIGdpdmVuIHRoZSB0aGUgc291cmNlIHJvb3QsIHRoZSBzb3VyY2Unc1xuICogVVJMLCBhbmQgdGhlIHNvdXJjZSBtYXAncyBVUkwuXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVTb3VyY2VVUkwoc291cmNlUm9vdCwgc291cmNlVVJMLCBzb3VyY2VNYXBVUkwpIHtcbiAgc291cmNlVVJMID0gc291cmNlVVJMIHx8ICcnO1xuXG4gIGlmIChzb3VyY2VSb290KSB7XG4gICAgLy8gVGhpcyBmb2xsb3dzIHdoYXQgQ2hyb21lIGRvZXMuXG4gICAgaWYgKHNvdXJjZVJvb3Rbc291cmNlUm9vdC5sZW5ndGggLSAxXSAhPT0gJy8nICYmIHNvdXJjZVVSTFswXSAhPT0gJy8nKSB7XG4gICAgICBzb3VyY2VSb290ICs9ICcvJztcbiAgICB9XG4gICAgLy8gVGhlIHNwZWMgc2F5czpcbiAgICAvLyAgIExpbmUgNDogQW4gb3B0aW9uYWwgc291cmNlIHJvb3QsIHVzZWZ1bCBmb3IgcmVsb2NhdGluZyBzb3VyY2VcbiAgICAvLyAgIGZpbGVzIG9uIGEgc2VydmVyIG9yIHJlbW92aW5nIHJlcGVhdGVkIHZhbHVlcyBpbiB0aGVcbiAgICAvLyAgIOKAnHNvdXJjZXPigJ0gZW50cnkuICBUaGlzIHZhbHVlIGlzIHByZXBlbmRlZCB0byB0aGUgaW5kaXZpZHVhbFxuICAgIC8vICAgZW50cmllcyBpbiB0aGUg4oCcc291cmNl4oCdIGZpZWxkLlxuICAgIHNvdXJjZVVSTCA9IHNvdXJjZVJvb3QgKyBzb3VyY2VVUkw7XG4gIH1cblxuICAvLyBIaXN0b3JpY2FsbHksIFNvdXJjZU1hcENvbnN1bWVyIGRpZCBub3QgdGFrZSB0aGUgc291cmNlTWFwVVJMIGFzXG4gIC8vIGEgcGFyYW1ldGVyLiAgVGhpcyBtb2RlIGlzIHN0aWxsIHNvbWV3aGF0IHN1cHBvcnRlZCwgd2hpY2ggaXMgd2h5XG4gIC8vIHRoaXMgY29kZSBibG9jayBpcyBjb25kaXRpb25hbC4gIEhvd2V2ZXIsIGl0J3MgcHJlZmVyYWJsZSB0byBwYXNzXG4gIC8vIHRoZSBzb3VyY2UgbWFwIFVSTCB0byBTb3VyY2VNYXBDb25zdW1lciwgc28gdGhhdCB0aGlzIGZ1bmN0aW9uXG4gIC8vIGNhbiBpbXBsZW1lbnQgdGhlIHNvdXJjZSBVUkwgcmVzb2x1dGlvbiBhbGdvcml0aG0gYXMgb3V0bGluZWQgaW5cbiAgLy8gdGhlIHNwZWMuICBUaGlzIGJsb2NrIGlzIGJhc2ljYWxseSB0aGUgZXF1aXZhbGVudCBvZjpcbiAgLy8gICAgbmV3IFVSTChzb3VyY2VVUkwsIHNvdXJjZU1hcFVSTCkudG9TdHJpbmcoKVxuICAvLyAuLi4gZXhjZXB0IGl0IGF2b2lkcyB1c2luZyBVUkwsIHdoaWNoIHdhc24ndCBhdmFpbGFibGUgaW4gdGhlXG4gIC8vIG9sZGVyIHJlbGVhc2VzIG9mIG5vZGUgc3RpbGwgc3VwcG9ydGVkIGJ5IHRoaXMgbGlicmFyeS5cbiAgLy9cbiAgLy8gVGhlIHNwZWMgc2F5czpcbiAgLy8gICBJZiB0aGUgc291cmNlcyBhcmUgbm90IGFic29sdXRlIFVSTHMgYWZ0ZXIgcHJlcGVuZGluZyBvZiB0aGVcbiAgLy8gICDigJxzb3VyY2VSb2904oCdLCB0aGUgc291cmNlcyBhcmUgcmVzb2x2ZWQgcmVsYXRpdmUgdG8gdGhlXG4gIC8vICAgU291cmNlTWFwIChsaWtlIHJlc29sdmluZyBzY3JpcHQgc3JjIGluIGEgaHRtbCBkb2N1bWVudCkuXG4gIGlmIChzb3VyY2VNYXBVUkwpIHtcbiAgICB2YXIgcGFyc2VkID0gdXJsUGFyc2Uoc291cmNlTWFwVVJMKTtcbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic291cmNlTWFwVVJMIGNvdWxkIG5vdCBiZSBwYXJzZWRcIik7XG4gICAgfVxuICAgIGlmIChwYXJzZWQucGF0aCkge1xuICAgICAgLy8gU3RyaXAgdGhlIGxhc3QgcGF0aCBjb21wb25lbnQsIGJ1dCBrZWVwIHRoZSBcIi9cIi5cbiAgICAgIHZhciBpbmRleCA9IHBhcnNlZC5wYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBwYXJzZWQucGF0aCA9IHBhcnNlZC5wYXRoLnN1YnN0cmluZygwLCBpbmRleCArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3VyY2VVUkwgPSBqb2luKHVybEdlbmVyYXRlKHBhcnNlZCksIHNvdXJjZVVSTCk7XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplKHNvdXJjZVVSTCk7XG59XG5leHBvcnRzLmNvbXB1dGVTb3VyY2VVUkwgPSBjb21wdXRlU291cmNlVVJMO1xuIl0sIm5hbWVzIjpbImdldEFyZyIsImFBcmdzIiwiYU5hbWUiLCJhRGVmYXVsdFZhbHVlIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiRXJyb3IiLCJleHBvcnRzIiwidXJsUmVnZXhwIiwiZGF0YVVybFJlZ2V4cCIsInVybFBhcnNlIiwiYVVybCIsIm1hdGNoIiwic2NoZW1lIiwiYXV0aCIsImhvc3QiLCJwb3J0IiwicGF0aCIsInVybEdlbmVyYXRlIiwiYVBhcnNlZFVybCIsInVybCIsIk1BWF9DQUNIRURfSU5QVVRTIiwibHJ1TWVtb2l6ZSIsImYiLCJjYWNoZSIsImlucHV0IiwiaSIsInRlbXAiLCJyZXN1bHQiLCJ1bnNoaWZ0IiwicG9wIiwibm9ybWFsaXplIiwiYVBhdGgiLCJpc0Fic29sdXRlIiwicGFydHMiLCJzdGFydCIsImluZGV4T2YiLCJwdXNoIiwic2xpY2UiLCJwYXJ0IiwidXAiLCJzcGxpY2UiLCJqb2luIiwiYVJvb3QiLCJhUGF0aFVybCIsImFSb290VXJsIiwiam9pbmVkIiwiY2hhckF0IiwicmVwbGFjZSIsInRlc3QiLCJyZWxhdGl2ZSIsImxldmVsIiwiaW5kZXgiLCJsYXN0SW5kZXhPZiIsIkFycmF5Iiwic3Vic3RyIiwic3VwcG9ydHNOdWxsUHJvdG8iLCJvYmoiLCJPYmplY3QiLCJjcmVhdGUiLCJpZGVudGl0eSIsInMiLCJ0b1NldFN0cmluZyIsImFTdHIiLCJpc1Byb3RvU3RyaW5nIiwiZnJvbVNldFN0cmluZyIsImNoYXJDb2RlQXQiLCJjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyIsIm1hcHBpbmdBIiwibWFwcGluZ0IiLCJvbmx5Q29tcGFyZU9yaWdpbmFsIiwiY21wIiwic3RyY21wIiwic291cmNlIiwib3JpZ2luYWxMaW5lIiwib3JpZ2luYWxDb2x1bW4iLCJnZW5lcmF0ZWRDb2x1bW4iLCJnZW5lcmF0ZWRMaW5lIiwibmFtZSIsImNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zTm9Tb3VyY2UiLCJjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCIsIm9ubHlDb21wYXJlR2VuZXJhdGVkIiwiY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWROb0xpbmUiLCJhU3RyMSIsImFTdHIyIiwiY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQiLCJwYXJzZVNvdXJjZU1hcElucHV0Iiwic3RyIiwiSlNPTiIsInBhcnNlIiwiY29tcHV0ZVNvdXJjZVVSTCIsInNvdXJjZVJvb3QiLCJzb3VyY2VVUkwiLCJzb3VyY2VNYXBVUkwiLCJwYXJzZWQiLCJzdWJzdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../source-map-js/lib/util.js\n");

/***/ }),

/***/ "(action-browser)/../source-map-js/source-map.js":
/*!**************************************!*\
  !*** ../source-map-js/source-map.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ exports.SourceMapGenerator = __webpack_require__(/*! ./lib/source-map-generator */ \"(action-browser)/../source-map-js/lib/source-map-generator.js\").SourceMapGenerator;\nexports.SourceMapConsumer = __webpack_require__(/*! ./lib/source-map-consumer */ \"(action-browser)/../source-map-js/lib/source-map-consumer.js\").SourceMapConsumer;\nexports.SourceNode = __webpack_require__(/*! ./lib/source-node */ \"(action-browser)/../source-map-js/lib/source-node.js\").SourceNode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uLi9zb3VyY2UtbWFwLWpzL3NvdXJjZS1tYXAuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Q0FJQyxHQUNEQSxzS0FBcUY7QUFDckZBLGtLQUFrRjtBQUNsRkEsb0lBQTREIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVhY3QtZW1haWwvLi4vc291cmNlLW1hcC1qcy9zb3VyY2UtbWFwLmpzP2JiYWMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAyMDA5LTIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLnR4dCBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyJykuU291cmNlTWFwQ29uc3VtZXI7XG5leHBvcnRzLlNvdXJjZU5vZGUgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2Utbm9kZScpLlNvdXJjZU5vZGU7XG4iXSwibmFtZXMiOlsiZXhwb3J0cyIsIlNvdXJjZU1hcEdlbmVyYXRvciIsInJlcXVpcmUiLCJTb3VyY2VNYXBDb25zdW1lciIsIlNvdXJjZU5vZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/../source-map-js/source-map.js\n");

/***/ }),

/***/ "(rsc)/../source-map-js/source-map.js":
/*!**************************************!*\
  !*** ../source-map-js/source-map.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */ exports.SourceMapGenerator = __webpack_require__(/*! ./lib/source-map-generator */ \"(rsc)/../source-map-js/lib/source-map-generator.js\").SourceMapGenerator;\nexports.SourceMapConsumer = __webpack_require__(/*! ./lib/source-map-consumer */ \"(rsc)/../source-map-js/lib/source-map-consumer.js\").SourceMapConsumer;\nexports.SourceNode = __webpack_require__(/*! ./lib/source-node */ \"(rsc)/../source-map-js/lib/source-node.js\").SourceNode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vc291cmNlLW1hcC1qcy9zb3VyY2UtbWFwLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUMsR0FDREEsMkpBQXFGO0FBQ3JGQSx1SkFBa0Y7QUFDbEZBLHlIQUE0RCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LWVtYWlsLy4uL3NvdXJjZS1tYXAtanMvc291cmNlLW1hcC5qcz9iYmFjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRS50eHQgb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1jb25zdW1lcicpLlNvdXJjZU1hcENvbnN1bWVyO1xuZXhwb3J0cy5Tb3VyY2VOb2RlID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW5vZGUnKS5Tb3VyY2VOb2RlO1xuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJTb3VyY2VNYXBHZW5lcmF0b3IiLCJyZXF1aXJlIiwiU291cmNlTWFwQ29uc3VtZXIiLCJTb3VyY2VOb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../source-map-js/source-map.js\n");

/***/ })

};
;