#!/usr/bin/env node

// src/cli/index.ts
import { program } from "commander";

// package.json
var package_default = {
  name: "react-email",
  version: "2.0.0",
  description: "A live preview of your emails right in your browser.",
  bin: {
    email: "./cli/index.js"
  },
  scripts: {
    build: "tsup",
    dev: "tsup --watch",
    clean: "rm -rf dist",
    lint: "eslint . && tsc"
  },
  license: "MIT",
  repository: {
    type: "git",
    url: "https://github.com/resend/react-email.git",
    directory: "packages/react-email"
  },
  keywords: [
    "react",
    "email"
  ],
  engines: {
    node: ">=18.0.0"
  },
  dependencies: {
    "@radix-ui/colors": "1.0.1",
    "@radix-ui/react-collapsible": "1.0.3",
    "@radix-ui/react-popover": "1.0.6",
    "@radix-ui/react-slot": "1.0.2",
    "@radix-ui/react-toggle-group": "1.0.4",
    "@radix-ui/react-tooltip": "1.0.6",
    "@react-email/components": "0.0.14",
    "@react-email/render": "0.0.12",
    "@swc/core": "1.3.101",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@types/webpack": "5.28.5",
    autoprefixer: "10.4.14",
    chalk: "4.1.2",
    chokidar: "3.5.3",
    clsx: "2.1.0",
    commander: "11.1.0",
    debounce: "2.0.0",
    esbuild: "0.19.11",
    "eslint-config-prettier": "9.0.0",
    "eslint-config-turbo": "1.10.12",
    "framer-motion": "10.17.4",
    glob: "10.3.4",
    "log-symbols": "4.1.0",
    "mime-types": "2.1.35",
    next: "14.0.5-canary.46",
    "normalize-path": "3.0.0",
    ora: "5.4.1",
    postcss: "8.4.32",
    "prism-react-renderer": "2.1.0",
    react: "^18.2.0",
    "react-dom": "^18.2.0",
    shelljs: "0.8.5",
    "socket.io": "4.7.3",
    "socket.io-client": "4.7.3",
    sonner: "1.3.1",
    "source-map-js": "1.0.2",
    "stacktrace-parser": "0.1.10",
    "tailwind-merge": "2.2.0",
    tailwindcss: "3.4.0",
    "tree-cli": "0.6.7",
    typescript: "5.1.6"
  },
  devDependencies: {
    "@types/fs-extra": "11.0.1",
    "@types/mime-types": "2.1.4",
    "@types/node": "20.10.4",
    "@types/normalize-path": "3.0.2",
    "@types/shelljs": "0.8.15",
    "@vercel/style-guide": "5.1.0",
    eslint: "8.50.0",
    tsup: "7.2.0",
    tsx: "4.7.0",
    vitest: "1.1.3",
    watch: "1.0.2"
  }
};

// src/cli/commands/dev.ts
import fs2 from "fs";

// src/cli/utils/tree.ts
import treeCli from "tree-cli";
var tree = async (dir, depth) => {
  const { report } = await treeCli({
    l: depth,
    base: dir
  });
  return report;
};

// src/cli/utils/preview/setup-hot-reloading.ts
import path from "path";
import { Server as SocketServer } from "socket.io";
import { watch } from "chokidar";
import debounce from "debounce";
var setupHotreloading = (devServer2, emailDirRelativePath) => {
  let clients = [];
  const io = new SocketServer(devServer2);
  io.on("connection", (client) => {
    clients.push(client);
    client.on("disconnect", () => {
      clients = clients.filter((item) => item !== client);
    });
  });
  const watcher = watch(emailDirRelativePath, {
    ignoreInitial: true,
    cwd: path.resolve(process.cwd()),
    // eslint-disable-next-line prefer-named-capture-group
    ignored: /(^|[/\\])\../
  });
  const exit = () => {
    void watcher.close();
  };
  process.on("SIGINT", exit);
  process.on("uncaughtException", exit);
  let changes = [];
  const reload = debounce(() => {
    clients.forEach((client) => {
      client.emit("reload", changes);
    });
    changes = [];
  }, 150);
  watcher.on("all", (event, filename) => {
    const file = filename.split(path.sep);
    if (file.length === 0) {
      return;
    }
    changes.push({
      event,
      filename
    });
    reload();
  });
  return watcher;
};

// src/cli/utils/preview/start-dev-server.ts
import path4 from "path";
import http from "http";
import url from "url";
import next from "next";
import ora from "ora";
import logSymbols from "log-symbols";
import chalk from "chalk";

// src/cli/utils/close-ora-on-sigint.ts
var closeOraOnSIGNIT = (spinner) => {
  process.on("SIGINT", () => {
    spinner.stop();
  });
};

// src/cli/utils/preview/serve-static-file.ts
import path2 from "path";
import { promises as fs, existsSync } from "fs";
import { lookup } from "mime-types";
var serveStaticFile = async (res, parsedUrl, staticDirRelativePath) => {
  const staticBaseDir = path2.join(process.cwd(), staticDirRelativePath);
  const pathname = parsedUrl.pathname;
  const ext = path2.parse(pathname).ext;
  let fileAbsolutePath = path2.join(staticBaseDir, pathname);
  const doesFileExist = existsSync(fileAbsolutePath);
  if (!doesFileExist) {
    res.statusCode = 404;
    res.end(`File ${pathname} not found!`);
  } else {
    const fileStat = await fs.stat(fileAbsolutePath);
    if (fileStat.isDirectory()) {
      fileAbsolutePath += `/index${ext}`;
    }
    const fileData = await fs.readFile(fileAbsolutePath);
    res.setHeader("Content-type", lookup(ext) || "text/plain");
    res.end(fileData);
  }
};

// src/cli/utils/preview/get-env-variables-for-preview-app.ts
import path3 from "path";
var getEnvVariablesForPreviewApp = (relativePathToEmailsDirectory, cliPackageLocation, cwd) => {
  return {
    NEXT_PUBLIC_EMAILS_DIR_RELATIVE_PATH: relativePathToEmailsDirectory,
    NEXT_PUBLIC_CLI_PACKAGE_LOCATION: cliPackageLocation,
    NEXT_PUBLIC_OS_PATH_SEPARATOR: path3.sep,
    NEXT_PUBLIC_USER_PROJECT_LOCATION: cwd
  };
};

// src/cli/utils/preview/start-dev-server.ts
var devServer;
var safeAsyncServerListen = (server, port) => {
  return new Promise((resolve) => {
    server.listen(port, () => {
      resolve({ portAlreadyInUse: false });
    });
    server.on("error", (e) => {
      if (e.code === "EADDRINUSE") {
        resolve({ portAlreadyInUse: true });
      }
    });
  });
};
var isRunningBuilt = __filename.endsWith("cli/index.js");
var cliPacakgeLocation = isRunningBuilt ? path4.resolve(__dirname, "..") : path4.resolve(__dirname, "../../../..");
var startDevServer = async (emailsDirRelativePath, staticBaseDirRelativePath, port) => {
  devServer = http.createServer((req, res) => {
    if (!req.url) {
      res.end(404);
      return;
    }
    const parsedUrl = url.parse(req.url, true);
    res.setHeader(
      "Cache-Control",
      "no-cache, max-age=0, must-revalidate, no-store"
    );
    res.setHeader("Pragma", "no-cache");
    res.setHeader("Expires", "-1");
    try {
      if (parsedUrl.path && parsedUrl.path.includes("static/") && !parsedUrl.path.includes("_next/static/")) {
        void serveStaticFile(res, parsedUrl, staticBaseDirRelativePath);
      } else if (!isNextReady) {
        void nextReadyPromise.then(
          () => nextHandleRequest?.(req, res, parsedUrl)
        );
      } else {
        void nextHandleRequest?.(req, res, parsedUrl);
      }
    } catch (e) {
      console.error("caught error", e);
      res.writeHead(500);
      res.end();
    }
  });
  const { portAlreadyInUse } = await safeAsyncServerListen(devServer, port);
  if (!portAlreadyInUse) {
    console.log(chalk.greenBright(`    React Email ${package_default.version}`));
    console.log(`    Running preview at:          http://localhost:${port}
`);
  } else {
    const nextPortToTry = port + 1;
    console.warn(
      ` ${logSymbols.warning} Port ${port} is already in use, trying ${nextPortToTry}`
    );
    return startDevServer(
      emailsDirRelativePath,
      staticBaseDirRelativePath,
      nextPortToTry
    );
  }
  devServer.on("close", async () => {
    await app.close();
  });
  devServer.on("error", (e) => {
    console.error(
      ` ${logSymbols.error} preview server error: `,
      JSON.stringify(e)
    );
    process.exit(1);
  });
  const spinner = ora({
    text: "Getting react-email preview server ready...\n",
    prefixText: " "
  }).start();
  closeOraOnSIGNIT(spinner);
  const timeBeforeNextReady = performance.now();
  process.env = {
    ...process.env,
    ...getEnvVariablesForPreviewApp(
      emailsDirRelativePath,
      cliPacakgeLocation,
      process.cwd()
    )
  };
  const app = next({
    // passing in env here does not get the environment variables there
    dev: true,
    hostname: "localhost",
    port,
    dir: cliPacakgeLocation
  });
  let isNextReady = false;
  const nextReadyPromise = app.prepare();
  await nextReadyPromise;
  isNextReady = true;
  const nextHandleRequest = app.getRequestHandler();
  const secondsToNextReady = ((performance.now() - timeBeforeNextReady) / 1e3).toFixed(1);
  spinner.stopAndPersist({
    text: `Ready in ${secondsToNextReady}s
`,
    symbol: logSymbols.success
  });
  return devServer;
};
var makeExitHandler = (options) => (_codeOrSignal) => {
  if (typeof devServer !== "undefined") {
    console.log("\nshutting down dev server");
    devServer.close();
    devServer = void 0;
  }
  if (options?.shouldKillProcess) {
    process.exit(options.killWithErrorCode ? 1 : 0);
  }
};
process.on("exit", makeExitHandler());
process.on(
  "SIGINT",
  makeExitHandler({ shouldKillProcess: true, killWithErrorCode: false })
);
process.on(
  "SIGUSR1",
  makeExitHandler({ shouldKillProcess: true, killWithErrorCode: false })
);
process.on(
  "SIGUSR2",
  makeExitHandler({ shouldKillProcess: true, killWithErrorCode: false })
);
process.on(
  "uncaughtException",
  makeExitHandler({ shouldKillProcess: true, killWithErrorCode: true })
);

// src/cli/commands/dev.ts
var dev = async ({ dir: emailsDirRelativePath, port }) => {
  try {
    if (!fs2.existsSync(emailsDirRelativePath)) {
      throw new Error(`Missing ${emailsDirRelativePath} folder`);
    }
    const devServer2 = await startDevServer(
      emailsDirRelativePath,
      "./emails",
      // defualts to ./emails/static for the static files that are served to the preview
      parseInt(port)
    );
    setupHotreloading(devServer2, emailsDirRelativePath);
  } catch (error) {
    console.log(error);
    process.exit(1);
  }
};

// src/cli/commands/export.ts
import fs3, { unlinkSync, writeFileSync } from "fs";
import path5 from "path";
import { glob } from "glob";
import { buildSync } from "esbuild";
import ora2 from "ora";
import logSymbols2 from "log-symbols";
import { render } from "@react-email/render";
import normalize from "normalize-path";
import { cp } from "shelljs";
var exportTemplates = async (outDir, srcDir, options) => {
  const spinner = ora2("Preparing files...\n").start();
  closeOraOnSIGNIT(spinner);
  const allTemplates = glob.sync(normalize(path5.join(srcDir, "*.{tsx,jsx}")));
  const buildResult = buildSync({
    bundle: true,
    entryPoints: allTemplates,
    platform: "node",
    format: "cjs",
    jsx: "transform",
    write: true,
    outdir: outDir
  });
  if (buildResult.warnings.length > 0) {
    console.warn(buildResult.warnings);
  }
  if (buildResult.errors.length > 0) {
    spinner.stopAndPersist({
      symbol: logSymbols2.error,
      text: "Failed to build emails"
    });
    console.error(buildResult.errors);
    throw new Error(
      `esbuild bundling process for email templates:
${allTemplates.map((p) => `- ${p}`).join("\n")}`
    );
  }
  spinner.succeed();
  const allBuiltTemplates = glob.sync(normalize(`${outDir}/*.js`), {
    absolute: true
  });
  for (const template of allBuiltTemplates) {
    try {
      spinner.text = `rendering ${template.split("/").pop()}`;
      spinner.render();
      const component = await import(template);
      const rendered = render(component.default({}), options);
      const htmlPath = template.replace(
        ".js",
        options.plainText ? ".txt" : ".html"
      );
      writeFileSync(htmlPath, rendered);
      unlinkSync(template);
    } catch (exception) {
      spinner.stopAndPersist({
        symbol: logSymbols2.error,
        text: `failed when rendering ${template.split("/").pop()}`
      });
      console.error(exception);
      throw exception;
    }
  }
  spinner.succeed("Rendered all files");
  spinner.text = `Copying static files`;
  spinner.render();
  const staticDir = path5.join(srcDir, "static");
  const hasStaticDirectory = fs3.existsSync(staticDir);
  if (hasStaticDirectory) {
    const result = cp("-r", staticDir, path5.join(outDir, "static"));
    if (result.code > 0) {
      spinner.stopAndPersist({
        symbol: logSymbols2.error,
        text: "Failed to copy static files"
      });
      throw new Error(
        `Something went wrong while copying the file to ${outDir}/static, ${result.cat()}`
      );
    }
  }
  spinner.succeed();
  const fileTree = await tree(outDir, 4);
  console.log(fileTree);
  spinner.stopAndPersist({
    symbol: logSymbols2.success,
    text: "Successfully exported emails"
  });
  process.exit();
};

// src/cli/commands/build.ts
import fs5 from "fs";
import path7 from "path";
import ora3 from "ora";
import shell from "shelljs";
import { spawn } from "child_process";

// src/actions/get-emails-directory-metadata.ts
import fs4 from "fs";
import path6 from "path";
var isFileAnEmail = (fullPath) => {
  const unixFullPath = fullPath.replaceAll(path6.sep, "/");
  if (/(\/|^)_[^/]*/.test(unixFullPath))
    return false;
  const stat = fs4.statSync(fullPath);
  if (stat.isDirectory())
    return false;
  const { ext } = path6.parse(fullPath);
  if (![".js", ".tsx", ".jsx"].includes(ext))
    return false;
  const fileContents = fs4.readFileSync(fullPath, "utf8");
  return /\bexport\s+default\b/gm.test(fileContents);
};
var mergeDirectoriesWithSubDirectories = (emailsDirectoryMetadata) => {
  let currentResultingMergedDirectory = emailsDirectoryMetadata;
  while (currentResultingMergedDirectory.emailFilenames.length === 0 && currentResultingMergedDirectory.subDirectories.length === 1) {
    const onlySubDirectory = currentResultingMergedDirectory.subDirectories[0];
    currentResultingMergedDirectory = {
      subDirectories: onlySubDirectory.subDirectories,
      emailFilenames: onlySubDirectory.emailFilenames,
      absolutePath: onlySubDirectory.absolutePath,
      directoryName: path6.join(
        currentResultingMergedDirectory.directoryName,
        onlySubDirectory.directoryName
      )
    };
  }
  return currentResultingMergedDirectory;
};
var getEmailsDirectoryMetadata = async (absolutePathToEmailsDirectory) => {
  if (!fs4.existsSync(absolutePathToEmailsDirectory))
    return;
  const dirents = await fs4.promises.readdir(absolutePathToEmailsDirectory, {
    withFileTypes: true
  });
  const emailFilenames = dirents.filter((dirent) => isFileAnEmail(path6.join(dirent.path, dirent.name))).map((dirent) => dirent.name);
  const subDirectories = await Promise.all(
    dirents.filter(
      (dirent) => dirent.isDirectory() && !dirent.name.startsWith("_") && dirent.name !== "static"
    ).map(
      (dirent) => getEmailsDirectoryMetadata(
        path6.join(dirent.path, dirent.name)
      )
    )
  );
  return mergeDirectoriesWithSubDirectories({
    absolutePath: absolutePathToEmailsDirectory,
    directoryName: absolutePathToEmailsDirectory.split(path6.sep).pop(),
    emailFilenames,
    subDirectories
  });
};

// src/cli/commands/build.ts
import logSymbols3 from "log-symbols";
var buildPreviewApp = (absoluteDirectory) => {
  return new Promise((resolve, reject) => {
    const nextBuild = spawn("npm", ["run", "build"], {
      cwd: absoluteDirectory
    });
    nextBuild.stdout.on("data", (msg) => {
      process.stdout.write(msg);
    });
    nextBuild.stderr.on("data", (msg) => {
      process.stderr.write(msg);
    });
    nextBuild.on("close", (code) => {
      if (code === 0) {
        resolve();
      } else {
        reject(
          new Error(
            `Unable to build the Next app and it exited with code: ${code}`
          )
        );
      }
    });
  });
};
var setNextEnvironmentVariablesForBuild = async (builtPreviewAppPath) => {
  const envVariables = {
    ...getEnvVariablesForPreviewApp("emails", "PLACEHOLDER", "PLACEHOLDER"),
    NEXT_PUBLIC_IS_BUILDING: "true"
  };
  const nextConfigContents = `
const path = require('path');
/** @type {import('next').NextConfig} */
module.exports = {
  env: {
    ...${JSON.stringify(envVariables)},
    NEXT_PUBLIC_USER_PROJECT_LOCATION: path.resolve(process.cwd(), '../'),
    NEXT_PUBLIC_CLI_PACKAGE_LOCATION: process.cwd(),
  },
  // this is needed so that the code for building emails works properly
  webpack: (
    /** @type {import('webpack').Configuration & { externals: string[] }} */
    config,
    { isServer }
  ) => {
    if (isServer) {
      config.externals.push('esbuild');
    }

    return config;
  },
  typescript: {
    ignoreBuildErrors: true
  },
  eslint: {
    ignoreDuringBuilds: true
  },
  experimental: {
    webpackBuildWorker: true,
    serverComponentsExternalPackages: [
      '@react-email/components',
      '@react-email/render',
      '@react-email/tailwind',
    ],
  },
}`;
  await fs5.promises.writeFile(
    path7.resolve(builtPreviewAppPath, "./next.config.js"),
    nextConfigContents,
    "utf8"
  );
};
var getEmailSlugsFromEmailDirectory = (emailDirectory, emailsDirectoryAbsolutePath) => {
  const directoryPathRelativeToEmailsDirectory = emailDirectory.absolutePath.replace(emailsDirectoryAbsolutePath, "").trim();
  const slugs = [];
  emailDirectory.emailFilenames.forEach(
    (filename) => slugs.push(path7.join(directoryPathRelativeToEmailsDirectory, filename))
  );
  emailDirectory.subDirectories.forEach((directory) => {
    slugs.push(
      ...getEmailSlugsFromEmailDirectory(
        directory,
        emailsDirectoryAbsolutePath
      )
    );
  });
  return slugs;
};
var forceSSGForEmailPreviews = async (emailsDirPath, builtPreviewAppPath) => {
  const emailDirectoryMetadata = (
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    await getEmailsDirectoryMetadata(emailsDirPath)
  );
  const parameters = getEmailSlugsFromEmailDirectory(
    emailDirectoryMetadata,
    emailsDirPath
  ).map((slug) => ({ slug }));
  await fs5.promises.appendFile(
    path7.resolve(builtPreviewAppPath, "./src/app/preview/[slug]/page.tsx"),
    `

export async function generateStaticParams() { 
  return ${JSON.stringify(parameters)};
}`,
    "utf8"
  );
};
var updatePackageJsonScripts = async (builtPreviewAppPath) => {
  const packageJsonPath = path7.resolve(builtPreviewAppPath, "./package.json");
  const packageJson = JSON.parse(
    await fs5.promises.readFile(packageJsonPath, "utf8")
  );
  packageJson.scripts.build = "next build";
  packageJson.scripts.start = "next start";
  await fs5.promises.writeFile(
    packageJsonPath,
    JSON.stringify(packageJson),
    "utf8"
  );
};
var npmInstall = async (builtPreviewAppPath, packageManager) => {
  return new Promise((resolve, reject) => {
    shell.exec(
      `${packageManager} install --silent`,
      { cwd: builtPreviewAppPath },
      (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(
            new Error(
              `Unable to install the dependencies and it exited with code: ${code}`
            )
          );
        }
      }
    );
  });
};
var build = async ({
  dir: emailsDirRelativePath,
  packageManager
}) => {
  try {
    const spinner = ora3({
      text: "Starting build process...",
      prefixText: "  "
    }).start();
    closeOraOnSIGNIT(spinner);
    spinner.text = "Checking if emails folder exists";
    if (!fs5.existsSync(emailsDirRelativePath)) {
      throw new Error(`Missing ${emailsDirRelativePath} folder`);
    }
    const emailsDirPath = path7.join(process.cwd(), emailsDirRelativePath);
    const staticPath = path7.join(process.cwd(), "emails", "static");
    const builtPreviewAppPath = path7.join(process.cwd(), ".react-email");
    if (fs5.existsSync(builtPreviewAppPath)) {
      spinner.text = "Deleting pre-existent `.react-email` folder";
      await fs5.promises.rm(builtPreviewAppPath, { recursive: true });
    }
    spinner.text = "Copying preview app from CLI to `.react-email`";
    await fs5.promises.cp(cliPacakgeLocation, builtPreviewAppPath, {
      recursive: true,
      filter: (source) => {
        return !source.includes("/cli/") && !source.includes("/.next/") && !/\/node_modules\/?$/.test(source);
      }
    });
    if (fs5.existsSync(staticPath)) {
      spinner.text = "Copying `emails/static` folder into `.react-email/public/static`";
      const builtStaticDirectory = path7.resolve(
        builtPreviewAppPath,
        "./public/static"
      );
      await fs5.promises.cp(staticPath, builtStaticDirectory, {
        recursive: true
      });
    }
    spinner.text = "Setting Next environment variables for preview app to work properly";
    await setNextEnvironmentVariablesForBuild(builtPreviewAppPath);
    spinner.text = "Setting server side generation for the email preview pages";
    await forceSSGForEmailPreviews(emailsDirPath, builtPreviewAppPath);
    spinner.text = "Updating package.json's build and start scripts";
    await updatePackageJsonScripts(builtPreviewAppPath);
    spinner.text = "Installing dependencies on `.react-email`";
    await npmInstall(builtPreviewAppPath, packageManager);
    spinner.stopAndPersist({
      text: "Successfully preapred `.react-email` for `next build`",
      symbol: logSymbols3.success
    });
    await buildPreviewApp(builtPreviewAppPath);
  } catch (error) {
    console.log(error);
    process.exit(1);
  }
};

// src/cli/commands/start.ts
import fs6 from "fs";
import path8 from "path";
import { spawn as spawn2 } from "child_process";
var start = async () => {
  try {
    const usersProjectLocation = process.cwd();
    const builtPreviewPath = path8.resolve(
      usersProjectLocation,
      "./.react-email"
    );
    if (!fs6.existsSync(builtPreviewPath)) {
      throw new Error(
        "Could not find `.react-email`, maybe you haven't ran `email build`?"
      );
    }
    const nextStart = spawn2("npm", ["start"], {
      cwd: builtPreviewPath
    });
    nextStart.stdout.on("data", (msg) => {
      process.stdout.write(msg);
    });
    nextStart.stderr.on("data", (msg) => {
      process.stderr.write(msg);
    });
  } catch (error) {
    console.log(error);
    process.exit(1);
  }
};

// src/cli/index.ts
var PACKAGE_NAME = "react-email";
program.name(PACKAGE_NAME).description("A live preview of your emails right in your browser").version(package_default.version);
program.command("dev").description("Starts the preview email development app").option("-d, --dir <path>", "Directory with your email templates", "./emails").option("-p --port <port>", "Port to run dev server on", "3000").action(dev);
program.command("build").description("Copies the preivew app for onto .react-email and builds it").option("-d, --dir <path>", "Directory with your email templates", "./emails").option(
  "-p --packageManager <name>",
  "Package name to use on installation on `.react-email`",
  "npm"
).action(build);
program.command("start").description('Runs the built preview app that is inside of ".react-email"').action(start);
program.command("export").description("Build the templates to the `out` directory").option("--outDir <path>", "Output directory", "out").option("-p, --pretty", "Pretty print the output", false).option("-t, --plainText", "Set output format as plain text", false).option("-d, --dir <path>", "Directory with your email templates", "./emails").action(
  ({ outDir, pretty, plainText, dir: srcDir }) => exportTemplates(outDir, srcDir, { pretty, plainText })
);
program.parse();
